[{"path":"https://andrjohns.github.io/boostmath/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 boostmath authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/articles/constants.html","id":"retrieve-specific-constants","dir":"Articles","previous_headings":"Constants","what":"Retrieve Specific Constants","title":"Boost Math - Constants","text":"","code":"constants(\"pi\") #> [1] 3.141593 constants(\"e\") #> [1] 2.718282 constants(\"phi\") #> [1] 1.618034"},{"path":"https://andrjohns.github.io/boostmath/articles/constants.html","id":"list-all-available-constants","dir":"Articles","previous_headings":"Constants","what":"List All Available Constants","title":"Boost Math - Constants","text":"","code":"constants() #> $half #> [1] 0.5 #>  #> $third #> [1] 0.3333333 #>  #> $twothirds #> [1] 0.6666667 #>  #> $two_thirds #> [1] 0.6666667 #>  #> $sixth #> [1] 0.1666667 #>  #> $three_quarters #> [1] 0.75 #>  #> $root_two #> [1] 1.414214 #>  #> $root_three #> [1] 1.732051 #>  #> $half_root_two #> [1] 0.7071068 #>  #> $ln_two #> [1] 0.6931472 #>  #> $ln_ln_two #> [1] -0.3665129 #>  #> $root_ln_four #> [1] 1.17741 #>  #> $one_div_root_two #> [1] 0.7071068 #>  #> $pi #> [1] 3.141593 #>  #> $half_pi #> [1] 1.570796 #>  #> $third_pi #> [1] 1.047198 #>  #> $sixth_pi #> [1] 0.5235988 #>  #> $two_pi #> [1] 6.283185 #>  #> $two_thirds_pi #> [1] 2.094395 #>  #> $three_quarters_pi #> [1] 2.356194 #>  #> $four_thirds_pi #> [1] 4.18879 #>  #> $one_div_two_pi #> [1] 0.1591549 #>  #> $one_div_root_two_pi #> [1] 0.3989423 #>  #> $log_pi #> [1] 1.14473 #>  #> $root_pi #> [1] 1.772454 #>  #> $root_half_pi #> [1] 1.253314 #>  #> $root_two_pi #> [1] 2.506628 #>  #> $log_root_two_pi #> [1] 0.9189385 #>  #> $one_div_root_pi #> [1] 0.5641896 #>  #> $root_one_div_pi #> [1] 0.5641896 #>  #> $pi_minus_three #> [1] 0.1415927 #>  #> $four_minus_pi #> [1] 0.8584073 #>  #> $pi_pow_e #> [1] 22.45916 #>  #> $pi_sqr #> [1] 9.869604 #>  #> $pi_sqr_div_six #> [1] 1.644934 #>  #> $pi_cubed #> [1] 31.00628 #>  #> $cbrt_pi #> [1] 1.464592 #>  #> $one_div_cbrt_pi #> [1] 0.6827841 #>  #> $log2_e #> [1] 1.442695 #>  #> $e #> [1] 2.718282 #>  #> $exp_minus_half #> [1] 0.6065307 #>  #> $exp_minus_one #> [1] 0.3678794 #>  #> $e_pow_pi #> [1] 23.14069 #>  #> $root_e #> [1] 1.648721 #>  #> $log10_e #> [1] 0.4342945 #>  #> $one_div_log10_e #> [1] 2.302585 #>  #> $ln_ten #> [1] 2.302585 #>  #> $degree #> [1] 0.01745329 #>  #> $radian #> [1] 57.29578 #>  #> $sin_one #> [1] 0.841471 #>  #> $cos_one #> [1] 0.5403023 #>  #> $sinh_one #> [1] 1.175201 #>  #> $cosh_one #> [1] 1.543081 #>  #> $phi #> [1] 1.618034 #>  #> $ln_phi #> [1] 0.4812118 #>  #> $one_div_ln_phi #> [1] 2.078087 #>  #> $euler #> [1] 0.5772157 #>  #> $one_div_euler #> [1] 1.732455 #>  #> $euler_sqr #> [1] 0.3331779 #>  #> $zeta_two #> [1] 1.644934 #>  #> $zeta_three #> [1] 1.202057 #>  #> $catalan #> [1] 0.9159656 #>  #> $glaisher #> [1] 1.282427 #>  #> $khinchin #> [1] 2.685452 #>  #> $extreme_value_skewness #> [1] 1.139547 #>  #> $rayleigh_skewness #> [1] 0.6311107 #>  #> $rayleigh_kurtosis #> [1] 3.245089 #>  #> $rayleigh_kurtosis_excess #> [1] 0.2450893 #>  #> $two_div_pi #> [1] 0.6366198 #>  #> $root_two_div_pi #> [1] 0.7978846 #>  #> $quarter_pi #> [1] 0.7853982 #>  #> $one_div_pi #> [1] 0.3183099 #>  #> $two_div_root_pi #> [1] 1.128379 #>  #> $first_feigenbaum #> [1] 4.669202 #>  #> $plastic #> [1] 1.324718 #>  #> $gauss #> [1] 0.8346268 #>  #> $dottie #> [1] 0.7390851 #>  #> $reciprocal_fibonacci #> [1] 3.359886 #>  #> $laplace_limit #> [1] 0.6627434"},{"path":"https://andrjohns.github.io/boostmath/articles/filters.html","id":"filters","dir":"Articles","previous_headings":"","what":"Filters","title":"Boost Math - Filters","text":"Filters section Boost Math library cover broad range areas","code":""},{"path":"https://andrjohns.github.io/boostmath/articles/filters.html","id":"daubechies-filters","dir":"Articles","previous_headings":"Filters","what":"Daubechies Filters","title":"Boost Math - Filters","text":"","code":"# Daubechies Scaling Filter of order 4 daubechies_scaling_filter(4) #> [1]  0.23037781  0.71484657  0.63088077 -0.02798377 -0.18703481  0.03084138 #> [7]  0.03288301 -0.01059740 # Daubechies Wavelet Filter of order 4 daubechies_wavelet_filter(4) #> [1] -0.01059740 -0.03288301  0.03084138  0.18703481 -0.02798377 -0.63088077 #> [7]  0.71484657 -0.23037781"},{"path":"https://andrjohns.github.io/boostmath/articles/fp_utilities.html","id":"floating-point-utilities","dir":"Articles","previous_headings":"","what":"Floating Point Utilities","title":"Boost Math - Floating Point Utilities","text":"Floating Point Utilities section Boost Math library cover broad range areas","code":""},{"path":"https://andrjohns.github.io/boostmath/articles/fp_utilities.html","id":"floating-point-representation-distance-ulp-and-finding-adjacent-floating-point-values","dir":"Articles","previous_headings":"Floating Point Utilities","what":"Floating-Point Representation Distance (ULP), and Finding Adjacent Floating-Point Values","title":"Boost Math - Floating Point Utilities","text":"","code":"#  The next representable value which is greater than x print(float_next(1.0), digits = 20) #> [1] 1.000000000000000222 #  The next representable value which is smaller than x print(float_prior(1.0), digits = 20) #> [1] 0.99999999999999988898 # The number of distinct representations between a and b print(float_distance(1.0, 2.0), digits = 20) #> [1] 4503599627370496 # A floating-point number r such that float_distance(val, r) == distance. print(float_advance(1.0, 10), digits = 20) #> [1] 1.0000000000000022204 # One unit in the last place of x print(ulp(1.0), digits = 20) #> [1] 2.2204460492503130808e-16"},{"path":"https://andrjohns.github.io/boostmath/articles/fp_utilities.html","id":"floating-point-comparison","dir":"Articles","previous_headings":"Floating Point Utilities","what":"Floating-point Comparison","title":"Boost Math - Floating Point Utilities","text":"","code":"# The relative distance/error E between two values as defined by: fabs((a - b) / min(a, b)) print(relative_difference(1.1, 1.1000009), digits = 20) #> [1] 8.1818181805395140825e-07 # A convenience function that returns relative_difference(a, b) / eps where eps is the machine epsilon for the result type print(epsilon_difference(1.1, 1.1000009), digits = 20) #> [1] 3684763330.909090519"},{"path":"https://andrjohns.github.io/boostmath/articles/fp_utilities.html","id":"condition-numbers","dir":"Articles","previous_headings":"Floating Point Utilities","what":"Condition Numbers","title":"Boost Math - Floating Point Utilities","text":"","code":"# Create a summation condition number object scn <- summation_condition_number(kahan = TRUE) # Add some values scn$add(1.0) scn$add(2.0) scn$add(3.0) # Compute sum, condition number, and L1 norm print(scn$sum()) #> [1] 6 print(scn$condition_number()) #> [1] 1 print(scn$l1_norm()) #> [1] 6  # Compute evaluation condition number for a function f <- function(x) { x^2 + 3*x + 2 } print(evaluation_condition_number(f, 1.0)) #> [1] 0.8333333"},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"interpolation","dir":"Articles","previous_headings":"","what":"Interpolation","title":"Boost Math - Interpolation","text":"Interpolation section Boost Math library provides methods numerical integration differentiation functions. methods can used directly R without needing additional compilation.","code":""},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"cardinal-cubic-b-spline","dir":"Articles","previous_headings":"Interpolation","what":"Cardinal Cubic B-Spline","title":"Boost Math - Interpolation","text":"","code":"y <- c(1, 2, 0, 2, 1) t0 <- 0 h <- 1 spline_obj <- cardinal_cubic_b_spline(y, t0, h) x <- 0.5 spline_obj$interpolate(x) #> [1] 2.895833 spline_obj$prime(x) #> [1] 0.125 spline_obj$double_prime(x) #> [1] -11.16667"},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"barycentric-rational-interpolation","dir":"Articles","previous_headings":"Interpolation","what":"Barycentric Rational Interpolation","title":"Boost Math - Interpolation","text":"","code":"x <- c(0, 1, 2, 3) y <- c(1, 2, 0, 2) order <- 3 interpolator <- barycentric_rational(x, y, order) xi <- 1.5 interpolator$interpolate(xi) #> [1] 0.9375 interpolator$prime(xi) #> [1] -2.291667"},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"bezier-polynomial","dir":"Articles","previous_headings":"Interpolation","what":"Bezier Polynomial","title":"Boost Math - Interpolation","text":"","code":"control_points <- list(c(0, 0, 0), c(1, 2, 0), c(2, 0, 0), c(3, 3, 0)) interpolator <- bezier_polynomial(control_points) xi <- 0.8 interpolator$interpolate(xi) #> [1] 2.400 1.728 0.000 interpolator$prime(xi) #> [1] 3.00 4.08 0.00 new_control_point <- c(1.5, 1, 0) interpolator$edit_control_point(new_control_point, 2)"},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"bilinear-uniform","dir":"Articles","previous_headings":"Interpolation","what":"Bilinear Uniform","title":"Boost Math - Interpolation","text":"","code":"x <- seq(0, 1, length.out = 10) interpolator <- bilinear_uniform(x, rows = 2, cols = 5) xi <- 0.5 yi <- 0.5 interpolator$interpolate(xi, yi) #> [1] 0.3333333"},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"cardinal-quadratic-b-spline","dir":"Articles","previous_headings":"Interpolation","what":"Cardinal Quadratic B-Spline","title":"Boost Math - Interpolation","text":"","code":"y <- c(0, 1, 0, 1) t0 <- 0 h <- 1 interpolator <- cardinal_quadratic_b_spline(y, t0, h) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.7857143 interpolator$prime(xi) #> [1] 1.142857"},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"cardinal-quintic-b-spline","dir":"Articles","previous_headings":"Interpolation","what":"Cardinal Quintic B-Spline","title":"Boost Math - Interpolation","text":"","code":"y <- seq(0, 1, length.out = 20) t0 <- 0 h <- 1 interpolator <- cardinal_quintic_b_spline(y, t0, h) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.02631579 interpolator$prime(xi) #> [1] 0.05263158 interpolator$double_prime(xi) #> [1] 8.84709e-17"},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"catmull-rom","dir":"Articles","previous_headings":"Interpolation","what":"Catmull-Rom","title":"Boost Math - Interpolation","text":"","code":"control_points <- list(c(0, 0, 0), c(1, 1, 0), c(2, 0, 0), c(3, 1, 0)) interpolator <- catmull_rom(control_points) xi <- 1.5 interpolator$interpolate(xi) #> [1] 1.2613446 0.8307972 0.0000000 interpolator$prime(xi) #> [1]  0.8408964 -1.1363078  0.0000000 interpolator$max_parameter() #> [1] 3.567621 interpolator$parameter_at_point(2) #> [1] 2.378414"},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"cubic-hermite","dir":"Articles","previous_headings":"Interpolation","what":"Cubic Hermite","title":"Boost Math - Interpolation","text":"","code":"x <- c(0, 1, 2) y <- c(0, 1, 0) dydx <- c(1, 0, -1) interpolator <- cubic_hermite(x, y, dydx) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.625 interpolator$prime(xi) #> [1] 1.25 interpolator$domain() #> [1] 0 2  # Add a new point interpolator$push_back(3, 0, 1) interpolator$interpolate(xi) #> [1] 0.625 interpolator$prime(xi) #> [1] 1.25 interpolator$domain() #> [1] 0 3"},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"cardinal-cubic-hermite","dir":"Articles","previous_headings":"Interpolation","what":"Cardinal Cubic Hermite","title":"Boost Math - Interpolation","text":"","code":"y <- c(0, 1, 0) dydx <- c(1, 0, -1) interpolator <- cardinal_cubic_hermite(y, dydx, 0, 1) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.625 interpolator$prime(xi) #> [1] 1.25 interpolator$domain() #> [1] 0 2"},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"modified-akima","dir":"Articles","previous_headings":"Interpolation","what":"Modified Akima","title":"Boost Math - Interpolation","text":"","code":"x <- c(0, 1, 2, 3) y <- c(0, 1, 0, 1) interpolator <- makima(x, y) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.7291667 interpolator$prime(xi) #> [1] 1.208333  # Add a new point interpolator$push_back(4, 1) interpolator$interpolate(xi) #> [1] 0.7291667 interpolator$prime(xi) #> [1] 1.208333"},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"pchip","dir":"Articles","previous_headings":"Interpolation","what":"PCHIP","title":"Boost Math - Interpolation","text":"","code":"x <- c(0, 1, 2, 3) y <- c(0, 1, 0, 1) interpolator <- pchip(x, y) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.625 interpolator$prime(xi) #> [1] 1.25  # Add a new point interpolator$push_back(4, 1) interpolator$interpolate(xi) #> [1] 0.625 interpolator$prime(xi) #> [1] 1.25"},{"path":"https://andrjohns.github.io/boostmath/articles/interpolation.html","id":"quintic-hermite","dir":"Articles","previous_headings":"Interpolation","what":"Quintic Hermite","title":"Boost Math - Interpolation","text":"","code":"x <- c(0, 1, 2) y <- c(0, 1, 0) dydx <- c(1, 0, -1) d2ydx2 <- c(0, -1, 0) interpolator <- quintic_hermite(x, y, dydx, d2ydx2) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.640625 interpolator$prime(xi) #> [1] 1.40625 interpolator$double_prime(xi) #> [1] -1.25 interpolator$domain() #> [1] 0 2  # Add a new point interpolator$push_back(3, 0, 1, 0) #> NULL interpolator$interpolate(xi) #> [1] 0.640625 interpolator$prime(xi) #> [1] 1.40625 interpolator$double_prime(xi) #> [1] -1.25 interpolator$domain() #> [1] 0 3"},{"path":"https://andrjohns.github.io/boostmath/articles/quadrature-differentiation.html","id":"quadrature-and-differentiation","dir":"Articles","previous_headings":"","what":"Quadrature and Differentiation","title":"Boost Math - Quadrature and Differentiation","text":"Quadrature Differentiation section Boost Math library provides methods numerical integration differentiation functions. methods can used directly R without needing additional compilation.","code":""},{"path":"https://andrjohns.github.io/boostmath/articles/quadrature-differentiation.html","id":"trapezoidal-quadrature","dir":"Articles","previous_headings":"Quadrature and Differentiation","what":"Trapezoidal Quadrature","title":"Boost Math - Quadrature and Differentiation","text":"","code":"# Trapezoidal rule integration of sin(x) from 0 to pi trapezoidal(sin, 0, pi) #> [1] 2"},{"path":"https://andrjohns.github.io/boostmath/articles/quadrature-differentiation.html","id":"gauss-legendre-quadrature","dir":"Articles","previous_headings":"Quadrature and Differentiation","what":"Gauss-Legendre Quadrature","title":"Boost Math - Quadrature and Differentiation","text":"","code":"# Gauss-Legendre integration of exp(x) from 0 to 1 gauss_legendre(exp, 0, 1, points = 7) #> [1] 1.718282"},{"path":"https://andrjohns.github.io/boostmath/articles/quadrature-differentiation.html","id":"gauss-kronrod-quadrature","dir":"Articles","previous_headings":"Quadrature and Differentiation","what":"Gauss-Kronrod Quadrature","title":"Boost Math - Quadrature and Differentiation","text":"","code":"# Adaptive Gauss-Kronrod integration of log(x) from 1 to 2 gauss_kronrod(log, 1, 2, points = 15, max_depth = 10) #> [1] 0.3862944  # Non-adaptive Gauss-Kronrod integration of log(x) from 1 to 2 gauss_kronrod(log, 1, 2, points = 15, max_depth = 0) #> [1] 0.3862944"},{"path":"https://andrjohns.github.io/boostmath/articles/quadrature-differentiation.html","id":"double-exponential-quadrature","dir":"Articles","previous_headings":"Quadrature and Differentiation","what":"Double-Exponential Quadrature","title":"Boost Math - Quadrature and Differentiation","text":"","code":"# Tanh-sinh quadrature of log(x) from 0 to 1 tanh_sinh(function(x) { log(x) * log1p(-x) }, a = 0, b = 1) #> [1] 0.3550659 # Sinh-sinh quadrature of exp(-x^2) sinh_sinh(function(x) { exp(-x * x) }) #> [1] 1.772454 # Exp-sinh quadrature of exp(-3*x) from 0 to Inf exp_sinh(function(x) { exp(-3 * x) }, a = 0, b = Inf) #> [1] 0.3333333"},{"path":"https://andrjohns.github.io/boostmath/articles/quadrature-differentiation.html","id":"fourier-integrals","dir":"Articles","previous_headings":"Quadrature and Differentiation","what":"Fourier Integrals","title":"Boost Math - Quadrature and Differentiation","text":"","code":"# Fourier sine integral of sin(x) with omega = 1 ooura_fourier_sin(function(x) { 1 / x }, omega = 1) #> [1] 1.570796 #> attr(,\"relative_error\") #> [1] 1.265522e-11 # Fourier cosine integral of cos(x) with omega = 1 ooura_fourier_cos(function(x) { 1/ (x * x + 1) }, omega = 1) #> [1] 0.5778637 #> attr(,\"relative_error\") #> [1] 6.417739e-09"},{"path":"https://andrjohns.github.io/boostmath/articles/quadrature-differentiation.html","id":"numerical-differentiation","dir":"Articles","previous_headings":"Quadrature and Differentiation","what":"Numerical Differentiation","title":"Boost Math - Quadrature and Differentiation","text":"","code":"# Finite difference derivative of sin(x) at pi/4 finite_difference_derivative(sin, pi / 4) #> [1] 0.7071068 # Complex step derivative of exp(x) at 1.7 complex_step_derivative(exp, 1.7) #> [1] 5.473947"},{"path":"https://andrjohns.github.io/boostmath/articles/rootfinding-minimisation.html","id":"root-finding-minimisation-algorithms","dir":"Articles","previous_headings":"","what":"Root Finding & Minimisation Algorithms","title":"Boost Math - Root Finding and Minimisation Algorithms","text":"Root Finding & Minimization Algorithms section Boost Math library provides methods finding minima roots functions. methods can used directly R without needing additional compilation.","code":""},{"path":"https://andrjohns.github.io/boostmath/articles/rootfinding-minimisation.html","id":"root-finding-without-derivatives","dir":"Articles","previous_headings":"Root Finding & Minimisation Algorithms","what":"Root Finding Without Derivatives","title":"Boost Math - Root Finding and Minimisation Algorithms","text":"","code":"# Example of finding a root using bisection method f <- function(x) x^2 - 2 bisect(f, lower = 0, upper = 2) #> $lower #> [1] 1.414214 #>  #> $upper #> [1] 1.414214 #>  #> $iterations #> [1] 54 # Example of finding a root using bracket and solve method f <- function(x) x^2 - 2 bracket_and_solve_root(f, guess = 1, factor = 0.1, rising = TRUE) #> $lower #> [1] 1.414214 #>  #> $upper #> [1] 1.414214 #>  #> $iterations #> [1] 91 # Example of finding a root using TOMS 748 algorithm f <- function(x) x^2 - 2 toms748_solve(f, lower = 0, upper = 2) #> $lower #> [1] 1.414214 #>  #> $upper #> [1] 1.414214 #>  #> $iterations #> [1] 9"},{"path":"https://andrjohns.github.io/boostmath/articles/rootfinding-minimisation.html","id":"root-finding-with-derivatives","dir":"Articles","previous_headings":"Root Finding & Minimisation Algorithms","what":"Root Finding With Derivatives","title":"Boost Math - Root Finding and Minimisation Algorithms","text":"","code":"# Example of finding a root using Newton-Raphson method f <- function(x) c(x^2 - 2, 2 * x) newton_raphson_iterate(f, guess = 1, lower = 0, upper = 2) #> [1] 1.414214 #> attr(,\"iterations\") #> [1] 6 # Example of finding a root using Halley's method f <- function(x) c(x^2 - 2, 2 * x, 2) halley_iterate(f, guess = 1, lower = 0, upper = 2) #> [1] 1.414214 #> attr(,\"iterations\") #> [1] 4 # Example of finding a root using Schroder's method f <- function(x) c(x^2 - 2, 2 * x, 2) schroder_iterate(f, guess = 1, lower = 0, upper = 2) #> [1] 1.414214 #> attr(,\"iterations\") #> [1] 5"},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/articles/rootfinding-minimisation.html","id":"quadratic-roots","dir":"Articles","previous_headings":"Root Finding & Minimisation Algorithms > Polynomial Roots","what":"Quadratic Roots","title":"Boost Math - Root Finding and Minimisation Algorithms","text":"","code":"# Example of finding quadratic roots quadratic_roots(1, -3, 2) #> [1] 1 2"},{"path":"https://andrjohns.github.io/boostmath/articles/rootfinding-minimisation.html","id":"cubic-roots","dir":"Articles","previous_headings":"Root Finding & Minimisation Algorithms > Polynomial Roots","what":"Cubic Roots","title":"Boost Math - Root Finding and Minimisation Algorithms","text":"","code":"# Example of finding cubic roots cubic_roots(1, -6, 11, -6) #> [1] 1 2 3 # Example of finding cubic root residual cubic_root_residual(1, -6, 11, -6, 1) #> [1] 0.000000e+00 1.110223e-14 # Example of finding cubic root condition number cubic_root_condition_number(1, -6, 11, -6, 1) #> [1] 12"},{"path":"https://andrjohns.github.io/boostmath/articles/rootfinding-minimisation.html","id":"quartic-roots","dir":"Articles","previous_headings":"Root Finding & Minimisation Algorithms > Polynomial Roots","what":"Quartic Roots","title":"Boost Math - Root Finding and Minimisation Algorithms","text":"","code":"# Example of finding quartic roots quartic_roots(1, -10, 35, -50, 24) #> [1] 1 2 3 4"},{"path":"https://andrjohns.github.io/boostmath/articles/rootfinding-minimisation.html","id":"finding-function-minima-with-brents-algorithm","dir":"Articles","previous_headings":"Root Finding & Minimisation Algorithms","what":"Finding Function Minima with Brent’s Algorithm","title":"Boost Math - Root Finding and Minimisation Algorithms","text":"","code":"# Example of finding a minimum using Brent's method f <- function(x) (x - 2)^2 + 1 brent_find_minima(f, lower = 0, upper = 4) #> $minimum #> [1] 2 #>  #> $value #> [1] 1 #>  #> $iterations #> [1] 5"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"special-math-functions","dir":"Articles","previous_headings":"","what":"Special Math Functions","title":"Boost Math - Special Functions","text":"Special Functions section Boost Math library cover broad range areas","code":""},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"number-series","dir":"Articles","previous_headings":"Special Math Functions","what":"Number Series","title":"Boost Math - Special Functions","text":"","code":"bernoulli_b2n(10) #> [1] -529.1242 max_bernoulli_b2n() #> [1] 129 unchecked_bernoulli_b2n(10) #> [1] -529.1242 bernoulli_b2n(start_index = 0, number_of_bernoullis_b2n = 10) #>  [1]  1.00000000  0.16666667 -0.03333333  0.02380952 -0.03333333  0.07575758 #>  [7] -0.25311355  1.16666667 -7.09215686 54.97117794 tangent_t2n(10) #> [1] 2.908889e+13 tangent_t2n(start_index = 0, number_of_tangent_t2n = 10) #>  [1]            0            1            2           16          272 #>  [6]         7936       353792     22368256   1903757312 209865342976 prime(10) #> [1] 31 max_prime() #> [1] 9999 fibonacci(10) #> [1] 55 unchecked_fibonacci(10) #> [1] 55"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"gamma-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Gamma Functions","title":"Boost Math - Special Functions","text":"","code":"# Gamma function for z = 5 tgamma(5) #> [1] 24 # Gamma function for (1 + z) - 1, where z = 5 tgamma1pm1(5) #> [1] 119 # Logarithm of the gamma function for z = 5 lgamma_boost(5) #> [1] 3.178054 # Digamma function for z = 5 digamma_boost(5) #> [1] 1.506118 # Trigamma function for z = 5 trigamma_boost(5) #> [1] 0.221323 # Polygamma function of order 1 for z = 5 polygamma(1, 5) #> [1] 0.221323 # Ratio of gamma functions for a = 5, b = 3 tgamma_ratio(5, 3) #> [1] 12 # Ratio of gamma functions with delta for a = 5, delta = 2 tgamma_delta_ratio(5, 2) #> [1] 0.03333333 # Normalised lower incomplete gamma function P(a, z) for a = 5, z = 2 gamma_p(5, 2) #> [1] 0.05265302 # Normalised upper incomplete gamma function Q(a, z) for a = 5, z = 2 gamma_q(5, 2) #> [1] 0.947347 # Full lower incomplete gamma function for a = 5, z = 2 tgamma_lower(5, 2) #> [1] 1.263672 # Full upper incomplete gamma function for a = 5, z = 2 tgamma_upper(5, 2) #> [1] 22.73633 # Inverse of the normalised upper incomplete gamma function for a = 5, q = 0.5 gamma_q_inv(5, 0.5) #> [1] 4.670909 # Inverse of the normalised lower incomplete gamma function for a = 5, p = 0.5 gamma_p_inv(5, 0.5) #> [1] 4.670909 # Inverse of the normalised upper incomplete gamma function with respect to a for z = 2, q = 0.5 gamma_q_inva(2, 0.5) #> [1] 2.323489 # Inverse of the normalised lower incomplete gamma function with respect to a for z = 2, p = 0.5 gamma_p_inva(2, 0.5) #> [1] 2.323489 # Derivative of the normalised upper incomplete gamma function for a = 5, z = 2 gamma_p_derivative(5, 2) #> [1] 0.09022352"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"factorials-and-binomial-coefficients","dir":"Articles","previous_headings":"Special Math Functions","what":"Factorials and Binomial Coefficients","title":"Boost Math - Special Functions","text":"","code":"# Factorial of 5 factorial_boost(5) #> [1] 120 # Unchecked factorial of 5 (using table lookup) unchecked_factorial(5) #> [1] 120 # Maximum factorial value that can be computed max_factorial() #> [1] 170 # Double factorial of 6 double_factorial(6) #> [1] 48 # Rising factorial of 3 with exponent 2 rising_factorial(3, 2) #> [1] 12 # Falling factorial of 3 with exponent 2 falling_factorial(3, 2) #> [1] 6 # Binomial coefficient \"5 choose 2\" binomial_coefficient(5, 2) #> [1] 10"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"beta-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Beta Functions","title":"Boost Math - Special Functions","text":"","code":"# Euler beta function B(2, 3) beta_boost(2, 3) #> [1] 0.08333333 # Normalised incomplete beta function I_x(2, 3) for x = 0.5 ibeta(2, 3, 0.5) #> [1] 0.6875 # Normalised complement of the incomplete beta function 1 - I_x(2, 3) for x = 0.5 ibetac(2, 3, 0.5) #> [1] 0.3125 # Full incomplete beta function B_x(2, 3) for x = 0.5 beta_boost(2, 3, 0.5) #> [1] 0.05729167 # Full complement of the incomplete beta function 1 - B_x(2, 3) for x = 0.5 betac(2, 3, 0.5) #> [1] 0.02604167 # Inverse of the normalised incomplete beta function I_x(2, 3) = 0.5 ibeta_inv(2, 3, 0.5) #> [1] 0.3857276 # Inverse of the normalised complement of the incomplete beta function I_x(2, 3) = 0.5 ibetac_inv(2, 3, 0.5) #> [1] 0.3857276 # Inverse of the normalised complement of the incomplete beta function I_x(a, b) # with respect to a for x = 0.5 and q = 0.5 ibetac_inva(3, 0.5, 0.5) #> [1] 3 # Inverse of the normalised incomplete beta function I_x(a, b) # with respect to b for x = 0.5 and p = 0.5 ibeta_invb(0.8, 0.5, 0.5) #> [1] 0.8 # Inverse of the normalised complement of the incomplete beta function I_x(a, b) # with respect to b for x = 0.5 and q = 0.5 ibetac_invb(2, 0.5, 0.5) #> [1] 2 # Derivative of the incomplete beta function with respect to x for a = 2, b = 3, x = 0.5 ibeta_derivative(2, 3, 0.5) #> [1] 1.5"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"error-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Error Functions","title":"Boost Math - Special Functions","text":"","code":"# Error function erf(0.5) #> [1] 0.5204999 # Complementary error function erfc(0.5) #> [1] 0.4795001 # Inverse error function erf_inv(0.5) #> [1] 0.4769363 # Inverse complementary error function erfc_inv(0.5) #> [1] 0.4769363"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"polynomials","dir":"Articles","previous_headings":"Special Math Functions","what":"Polynomials","title":"Boost Math - Special Functions","text":"","code":"# Legendre polynomial of the first kind P_2(0.5) legendre_p(2, 0.5) #> [1] -0.125 # Derivative of the Legendre polynomial of the first kind P_2'(0.5) legendre_p_prime(2, 0.5) #> [1] 1.5 # Zeros of the Legendre polynomial of the first kind P_2 legendre_p_zeros(2) #> [1] 0.5773503 # Legendre polynomial of the first kind with order 1 P_2^1(0.5) legendre_p_m(2, 1, 0.5) #> [1] -1.299038 # Legendre polynomial of the second kind Q_2(0.5) legendre_q(2, 0.5) #> [1] -0.8186633 # Next Legendre polynomial of the first kind P_3(0.5) using P_2(0.5) and P_1(0.5) legendre_next(2, 0.5, legendre_p(2, 0.5), legendre_p(1, 0.5)) #> [1] -0.4375 # Next Legendre polynomial of the first kind with order 1 P_3^1(0.5) using P_2^1(0.5) and P_1^1(0.5) legendre_next_m(2, 1, 0.5, legendre_p_m(2, 1, 0.5), legendre_p_m(1, 1, 0.5)) #> [1] -0.3247595 # Laguerre polynomial of the first kind L_2(0.5) laguerre(2, 0.5) #> [1] 0.125 # Laguerre polynomial of the first kind with order 1 L_2^1(0.5) laguerre_m(2, 1, 0.5) #> [1] 1.625 # Next Laguerre polynomial of the first kind L_3(0.5) using L_2(0.5) and L_1(0.5) laguerre_next(2, 0.5, laguerre(2, 0.5), laguerre(1, 0.5)) #> [1] -0.1458333 # Next Laguerre polynomial of the first kind with order 1 L_3^1(0.5) using L_2^1(0.5) and L_1^1(0.5) laguerre_next_m(2, 1, 0.5, laguerre_m(2, 1, 0.5), laguerre_m(1, 1, 0.5)) #> [1] 1.479167 # Hermite polynomial H_2(0.5) hermite(2, 0.5) #> [1] -1 # Next Hermite polynomial H_3(0.5) using H_2(0.5) and H_1(0.5) hermite_next(2, 0.5, hermite(2, 0.5), hermite(1, 0.5)) #> [1] -5 # Chebyshev polynomial of the first kind T_2(0.5) chebyshev_t(2, 0.5) #> [1] -0.5 # Chebyshev polynomial of the second kind U_2(0.5) chebyshev_u(2, 0.5) #> [1] 0 # Derivative of the Chebyshev polynomial of the first kind T_2'(0.5) chebyshev_t_prime(2, 0.5) #> [1] 2 # Next Chebyshev polynomial of the first kind T_3(0.5) using T_2(0.5) and T_1(0.5) chebyshev_next(0.5, chebyshev_t(2, 0.5), chebyshev_t(1, 0.5)) #> [1] -1 # Chebyshev polynomial of the first kind using Clenshaw's recurrence with coefficients # c = c(1, 0, -1) at x = 0.5 chebyshev_clenshaw_recurrence(c(1, 0, -1), 0.5) #> [1] 1 # Chebyshev polynomial of the first kind using Clenshaw's recurrence with interval [0, 1] chebyshev_clenshaw_recurrence_ab(c(1, 0, -1), 0, 1, 0.5) #> [1] 1.5 # Spherical harmonic function Y_2^1(0.5, 0.5) spherical_harmonic(2, 1, 0.5, 0.5) #> [1] -0.2852481-0.1558318i # Real part of the spherical harmonic function Y_2^1(0.5, 0.5) spherical_harmonic_r(2, 1, 0.5, 0.5) #> [1] -0.2852481 # Imaginary part of the spherical harmonic function Y_2^1(0.5, 0.5) spherical_harmonic_i(2, 1, 0.5, 0.5) #> [1] -0.1558318 # Gegenbauer polynomial C_2^(1)(0.5) gegenbauer(2, 1, 0.5) #> [1] 0 # Derivative of the Gegenbauer polynomial C_2^(1)'(0.5) gegenbauer_prime(2, 1, 0.5) #> [1] 4 # k-th derivative of the Gegenbauer polynomial C_2^(1)''(0.5) gegenbauer_derivative(2, 1, 0.5, 2) #> [1] 8 # Jacobi polynomial P_2^(1, 2)(0.5) jacobi(2, 1, 2, 0.5) #> [1] -0.1875 # Derivative of the Jacobi polynomial P_2^(1, 2)'(0.5) jacobi_prime(2, 1, 2, 0.5) #> [1] 3.75 # Second derivative of the Jacobi polynomial P_2^(1, 2)''(0.5) jacobi_double_prime(2, 1, 2, 0.5) #> [1] 10.5 # 3rd derivative of the Jacobi polynomial P_2^(1, 2)^(k)(0.5) jacobi_derivative(2, 1, 2, 0.5, 3) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"logistic-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Logistic Functions","title":"Boost Math - Special Functions","text":"","code":"# Logistic Sigmoid Function logistic_sigmoid(0.5) #> [1] 0.6224593 # Logit Function logit(0.7) #> [1] 0.8472979"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"bessel-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Bessel Functions","title":"Boost Math - Special Functions","text":"","code":"# Bessel function of the first kind J_0(1) cyl_bessel_j(0, 1) #> [1] 0.7651977 # Bessel function of the second kind Y_0(1) cyl_neumann(0, 1) #> [1] 0.08825696 # Modified Bessel function of the first kind I_0(1) cyl_bessel_i(0, 1) #> [1] 1.266066 # Modified Bessel function of the second kind K_0(1) cyl_bessel_k(0, 1) #> [1] 0.4210244 # Spherical Bessel function of the first kind j_0(1) sph_bessel(0, 1) #> [1] 0.841471 # Spherical Bessel function of the second kind y_0(1) sph_neumann(0, 1) #> [1] -0.5403023 # Derivative of the Bessel function of the first kind J_0(1) cyl_bessel_j_prime(0, 1) #> [1] -0.4400506 # Derivative of the Bessel function of the second kind Y_0(1) cyl_neumann_prime(0, 1) #> [1] 0.7812128 # Derivative of the modified Bessel function of the first kind I_0(1) cyl_bessel_i_prime(0, 1) #> [1] 0.5651591 # Derivative of the modified Bessel function of the second kind K_0(1) cyl_bessel_k_prime(0, 1) #> [1] -0.6019072 # Derivative of the spherical Bessel function of the first kind j_0(1) sph_bessel_prime(0, 1) #> [1] -0.3011687 # Derivative of the spherical Bessel function of the second kind y_0(1) sph_neumann_prime(0, 1) #> [1] 1.381773 # Finding the first zero of the Bessel function of the first kind J_0 cyl_bessel_j_zero(0, 1) #> [1] 2.404826 # Finding the first zero of the Bessel function of the second kind Y_0 cyl_neumann_zero(0, 1) #> [1] 0.893577 # Finding multiple zeros of the Bessel function of the first kind J_0 starting from index 1 cyl_bessel_j_zero(0, start_index = 1, number_of_zeros = 5) #> [1]  2.404826  5.520078  8.653728 11.791534 14.930918 # Finding multiple zeros of the Bessel function of the second kind Y_0 starting from index 1 cyl_neumann_zero(0, start_index = 1, number_of_zeros = 5) #> [1]  0.893577  3.957678  7.086051 10.222345 13.361097"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"hankel-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Hankel Functions","title":"Boost Math - Special Functions","text":"","code":"cyl_hankel_1(2, 0.5) #> [1] 0.03060402-5.441371i cyl_hankel_2(2, 0.5) #> [1] 0.03060402+5.441371i sph_hankel_1(2, 0.5) #> [1] 0.01637111-25.05992i sph_hankel_2(2, 0.5) #> [1] 0.01637111+25.05992i"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"airy-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Airy Functions","title":"Boost Math - Special Functions","text":"","code":"airy_ai(2) #> [1] 0.03492413 airy_bi(2) #> [1] 3.298095 airy_ai_prime(2) #> [1] -0.05309038 airy_bi_prime(2) #> [1] 4.100682 airy_ai_zero(1) #> [1] -2.338107 airy_bi_zero(1) #> [1] -1.173713 airy_ai_zero(start_index = 1, number_of_zeros = 5) #> [1] -2.338107 -4.087949 -5.520560 -6.786708 -7.944134 airy_bi_zero(start_index = 1, number_of_zeros = 5) #> [1] -1.173713 -3.271093 -4.830738 -6.169852 -7.376762"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"elliptic-integrals","dir":"Articles","previous_headings":"Special Math Functions","what":"Elliptic Integrals","title":"Boost Math - Special Functions","text":"","code":"# Carlson's elliptic integral Rf with parameters x = 1, y = 2, z = 3 ellint_rf(1, 2, 3) #> [1] 0.7269459 # Carlson's elliptic integral Rd with parameters x = 1, y = 2, z = 3 ellint_rd(1, 2, 3) #> [1] 0.2904603 # Carlson's elliptic integral Rj with parameters x = 1, y = 2, z = 3, p = 4 ellint_rj(1, 2, 3, 4) #> [1] 0.2398481 # Carlson's elliptic integral Rc with parameters x = 1, y = 2 ellint_rc(1, 2) #> [1] 0.7853982 # Carlson's elliptic integral Rg with parameters x = 1, y = 2, z = 3 ellint_rg(1, 2, 3) #> [1] 1.401847 # Incomplete elliptic integral of the first kind with k = 0.5, phi = pi/4 ellint_1(0.5, pi / 4) #> [1] 0.8043661 # Complete elliptic integral of the first kind ellint_1(0.5) #> [1] 1.68575 # Incomplete elliptic integral of the second kind with k = 0.5, phi = pi/4 ellint_2(0.5, pi / 4) #> [1] 0.767196 # Complete elliptic integral of the second kind ellint_2(0.5) #> [1] 1.467462 # Incomplete elliptic integral of the third kind with k = 0.5, n = 0.5, phi = pi/4 ellint_3(0.5, 0.5, pi / 4) #> [1] 0.8930657 # Complete elliptic integral of the third kind with k = 0.5, n = 0.5 ellint_3(0.5, 0.5) #> [1] 2.413672 # Incomplete elliptic integral D with k = 0.5, phi = pi/4 ellint_d(0.5, pi / 4) #> [1] 0.1486805 # Complete elliptic integral D ellint_d(0.5) #> [1] 0.8731526 # Jacobi zeta function with k = 0.5, phi = pi/4 jacobi_zeta(0.5, pi / 4) #> [1] 0.06698741 # Heuman's lambda function with k = 0.5, phi = pi/4 heuman_lambda(0.5, pi / 4) #> [1] 0.6632254"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"jacobi-elliptic-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Jacobi Elliptic Functions","title":"Boost Math - Special Functions","text":"","code":"# Jacobi Elliptic Functions k <- 0.5 u <- 2 jacobi_elliptic(k, u) #> $sn #> [1] 0.9628982 #>  #> $cn #> [1] -0.269865 #>  #> $dn #> [1] 0.8764741 # Individual Jacobi Elliptic Functions jacobi_cd(k, u) #> [1] -0.3078984 jacobi_cn(k, u) #> [1] -0.269865 jacobi_cs(k, u) #> [1] -0.2802632 jacobi_dc(k, u) #> [1] -3.247825 jacobi_dn(k, u) #> [1] 0.8764741 jacobi_ds(k, u) #> [1] 0.9102458 jacobi_nc(k, u) #> [1] -3.705557 jacobi_nd(k, u) #> [1] 1.140935 jacobi_ns(k, u) #> [1] 1.038531 jacobi_sc(k, u) #> [1] -3.568074 jacobi_sd(k, u) #> [1] 1.098604 jacobi_sn(k, u) #> [1] 0.9628982"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"jacobi-theta-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Jacobi Theta Functions","title":"Boost Math - Special Functions","text":"","code":"# Jacobi Theta Functions x <- 0.5 q <- 0.9 tau <- 1.5 jacobi_theta1(x, q) #> [1] 0.0001025529 jacobi_theta1tau(x, tau) #> [1] 0.2951461 jacobi_theta2(x, q) #> [1] 0.5090257 jacobi_theta2tau(x, tau) #> [1] 0.5403556 jacobi_theta3(x, q) #> [1] 0.5090257 jacobi_theta3tau(x, tau) #> [1] 1.009707 jacobi_theta3m1(x, q) #> [1] -0.4909743 jacobi_theta3m1tau(x, tau) #> [1] 0.00970738 jacobi_theta4(x, q) #> [1] 0.0001025529 jacobi_theta4tau(x, tau) #> [1] 0.9902926 jacobi_theta4m1(x, q) #> [1] -0.9998974 jacobi_theta4m1tau(x, tau) #> [1] -0.009707391"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"lambert-w-function","dir":"Articles","previous_headings":"Special Math Functions","what":"Lambert W Function","title":"Boost Math - Special Functions","text":"","code":"# Lambert W Function (Principal Branch) lambert_w0(0.3) #> [1] 0.2367553 # Lambert W Function (Branch -1) lambert_wm1(-0.3) #> [1] -1.781337 # Derivative of the Lambert W Function (Principal Branch) lambert_w0_prime(0.3) #> [1] 0.6381087 # Derivative of the Lambert W Function (Branch -1) lambert_wm1_prime(-0.3) #> [1] -7.599525"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"zeta-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Zeta Functions","title":"Boost Math - Special Functions","text":"","code":"# Riemann Zeta Function zeta(2)  # Should return pi^2 / 6 #> [1] 1.644934"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"exponential-integrals","dir":"Articles","previous_headings":"Special Math Functions","what":"Exponential Integrals","title":"Boost Math - Special Functions","text":"","code":"# Exponential integral En with n = 1 and z = 2 expint_en(1, 2) #> [1] 0.04890051 # Exponential integral Ei with z = 2 expint_ei(2) #> [1] 4.954234"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"hypergeometric-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Hypergeometric Functions","title":"Boost Math - Special Functions","text":"","code":"# Hypergeometric Function 1F0 hypergeometric_1F0(2, 0.2) #> [1] 1.5625 # Hypergeometric Function 0F1 hypergeometric_0F1(1, 0.8) #> [1] 1.974957 # Hypergeometric Function 2F0 hypergeometric_2F0(0.1, -1, 0.1) #> [1] 0.99 # Hypergeometric Function 1F1 hypergeometric_1F1(2, 3, 1) #> [1] 2 # Regularised Hypergeometric Function 1F1 hypergeometric_1F1_regularized(2, 3, 1) #> [1] 1 # Logarithm of the Hypergeometric Function 1F1 log_hypergeometric_1F1(2, 3, 1) #> [1] 0.6931472 #> attr(,\"sign\") #> [1] 1 # Hypergeometric Function pFq hypergeometric_pFq(c(2, 3), c(4, 5), 6) #> [1] 11.32427"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"basic-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Basic Functions","title":"Boost Math - Special Functions","text":"","code":"# sin(pi * 0.5) sin_pi(0.5) #> [1] 1 # cos(pi * 0.5) cos_pi(0.5) #> [1] 0 # log(1 + 0.5) log1p_boost(0.5) #> [1] 0.4054651 # exp(0.5) - 1 expm1_boost(0.5) #> [1] 0.6487213 cbrt(8) #> [1] 2 # sqrt(1 + 0.5) - 1 sqrt1pm1(0.5) #> [1] 0.2247449 # 2^3 - 1 powm1(2, 3) #> [1] 7 hypot(3, 4) #> [1] 5 rsqrt(4) #> [1] 0.5"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"sinus-cardinal-and-hyperbolic-sinus-cardinal-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Sinus Cardinal and Hyperbolic Sinus Cardinal Functions","title":"Boost Math - Special Functions","text":"","code":"# Sinus cardinal function sinc_pi(0.5) #> [1] 0.9588511 # Hyperbolic sinus cardinal function sinhc_pi(0.5) #> [1] 1.042191"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"inverse-hyperbolic-functions","dir":"Articles","previous_headings":"Special Math Functions","what":"Inverse Hyperbolic Functions","title":"Boost Math - Special Functions","text":"","code":"# Inverse Hyperbolic Cosine acosh_boost(2) #> [1] 1.316958 # Inverse Hyperbolic Sine asinh_boost(1) #> [1] 0.8813736 # Inverse Hyperbolic Tangent atanh_boost(0.5) #> [1] 0.5493061"},{"path":"https://andrjohns.github.io/boostmath/articles/special-functions.html","id":"owens-t-function","dir":"Articles","previous_headings":"Special Math Functions","what":"Owen’s T Function","title":"Boost Math - Special Functions","text":"","code":"# Owens T Function owens_t(1, 0.5) #> [1] 0.04306469"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"statistics","dir":"Articles","previous_headings":"","what":"Statistics","title":"Boost Math - Statistical Distributions","text":"Statistical Distributions section Boost Math library cover broad range areas","code":""},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"arcsine-distribution","dir":"Articles","previous_headings":"Statistics","what":"Arcsine Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Arcsine distribution with default parameters dist <- arcsine_distribution() # Apply generic functions cdf(dist, 0.5) #> [1] 0.5 logcdf(dist, 0.5) #> [1] -0.6931472 pdf(dist, 0.5) #> [1] 0.6366198 logpdf(dist, 0.5) #> [1] -0.4515827 hazard(dist, 0.5) #> [1] 1.27324 chf(dist, 0.5) #> [1] 0.6931472 mean(dist) #> [1] 0.5 median(dist) #> [1] 0.5 range(dist) #> [1] 0 1 quantile(dist, 0.2) #> [1] 0.0954915 standard_deviation(dist) #> [1] 0.3535534 support(dist) #> [1] 0 1 variance(dist) #> [1] 0.125 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 1.5 kurtosis_excess(dist) #> [1] -1.5  # Convenience functions arcsine_pdf(0.5) #> [1] 0.6366198 arcsine_lpdf(0.5) #> [1] -0.4515827 arcsine_cdf(0.5) #> [1] 0.5 arcsine_lcdf(0.5) #> [1] -0.6931472 arcsine_quantile(0.5) #> [1] 0.5"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"bernoulli-distribution","dir":"Articles","previous_headings":"Statistics","what":"Bernoulli Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Bernoulli distribution with p_success = 0.5 dist <- bernoulli_distribution(0.5) # Apply generic functions cdf(dist, 0.5) #> [1] 0.8183099 logcdf(dist, 0.5) #> [1] -0.2005142 pdf(dist, 0.5) #> [1] 0.6366198 logpdf(dist, 0.5) #> [1] -0.4515827 hazard(dist, 0.5) #> [1] 3.503877 chf(dist, 0.5) #> [1] 1.705453 mean(dist) #> [1] 0.5 median(dist) #> [1] 0 mode(dist) #> [1] 1 range(dist) #> [1] 0 1 quantile(dist, 0.2) #> [1] 0 standard_deviation(dist) #> [1] 0.5 support(dist) #> [1] 0 1 variance(dist) #> [1] 0.25 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 1 kurtosis_excess(dist) #> [1] -2  # Convenience functions bernoulli_pdf(1, 0.5) #> [1] 0.5 bernoulli_lpdf(1, 0.5) #> [1] -0.6931472 bernoulli_cdf(1, 0.5) #> [1] 1 bernoulli_lcdf(1, 0.5) #> [1] 0 bernoulli_quantile(0.5, 0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"beta-distribution","dir":"Articles","previous_headings":"Statistics","what":"Beta Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Beta distribution with shape parameters alpha = 2, beta = 5 dist <- beta_distribution(2, 5) # Apply generic functions cdf(dist, 0.5) #> [1] 0.890625 logcdf(dist, 0.5) #> [1] -0.1158318 pdf(dist, 0.5) #> [1] 0.9375 logpdf(dist, 0.5) #> [1] -0.06453852 hazard(dist, 0.5) #> [1] 8.571429 chf(dist, 0.5) #> [1] 2.212973 mean(dist) #> [1] 0.2857143 median(dist) #> [1] 0.26445 mode(dist) #> [1] 0.2 range(dist) #> [1] 0 1 quantile(dist, 0.2) #> [1] 0.1398807 standard_deviation(dist) #> [1] 0.1597191 support(dist) #> [1] 0 1 variance(dist) #> [1] 0.0255102 skewness(dist) #> [1] 0.5962848 kurtosis(dist) #> [1] 2.88 kurtosis_excess(dist) #> [1] -0.12  # Convenience functions beta_pdf(0.5, 2, 5) #> [1] 0.9375 beta_lpdf(0.5, 2, 5) #> [1] -0.06453852 beta_cdf(0.5, 2, 5) #> [1] 0.890625 beta_lcdf(0.5, 2, 5) #> [1] -0.1158318 beta_quantile(0.5, 2, 5) #> [1] 0.26445"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"binomial-distribution","dir":"Articles","previous_headings":"Statistics","what":"Binomial Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Binomial dist ribution with n = 10, prob = 0.5 dist <- binomial_distribution(10, 0.5) # Apply generic functions cdf(dist, 2) #> [1] 0.0546875 logcdf(dist, 2) #> [1] -2.90612 pdf(dist, 2) #> [1] 0.04394531 logpdf(dist, 2) #> [1] -3.124809 hazard(dist, 2) #> [1] 0.0464876 chf(dist, 2) #> [1] 0.05623972 mean(dist) #> [1] 5 median(dist) #> [1] 5 mode(dist) #> [1] 5 range(dist) #> [1]  0 10 quantile(dist, 0.2) #> [1] 3 standard_deviation(dist) #> [1] 1.581139 support(dist) #> [1]  0 10 variance(dist) #> [1] 2.5 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 2.8 kurtosis_excess(dist) #> [1] -0.2  # Convenience functions binomial_pdf(3, 10, 0.5) #> [1] 0.1171875 binomial_lpdf(3, 10, 0.5) #> [1] -2.14398 binomial_cdf(3, 10, 0.5) #> [1] 0.171875 binomial_lcdf(3, 10, 0.5) #> [1] -1.760988 binomial_quantile(0.5, 10, 0.5) #> [1] 5"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"cauchy-distribution","dir":"Articles","previous_headings":"Statistics","what":"Cauchy Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Cauchy distribution with location = 0, scale = 1 dist <- cauchy_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6475836 logcdf(dist, 0.5) #> [1] -0.4345074 pdf(dist, 0.5) #> [1] 0.2546479 logpdf(dist, 0.5) #> [1] -1.367873 hazard(dist, 0.5) #> [1] 0.7225768 chf(dist, 0.5) #> [1] 1.042942 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -1.376382 support(dist) #> [1] -Inf  Inf  # Convenience functions cauchy_pdf(0) #> [1] 0.3183099 cauchy_lpdf(0) #> [1] -1.14473 cauchy_cdf(0) #> [1] 0.5 cauchy_lcdf(0) #> [1] -0.6931472 cauchy_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"chi-squared-distribution","dir":"Articles","previous_headings":"Statistics","what":"Chi-Squared Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Chi-Squared distribution with 3 degrees of freedom dist <- chi_squared_distribution(3) # Apply generic functions cdf(dist, 0.5) #> [1] 0.08110859 logcdf(dist, 0.5) #> [1] -2.511966 pdf(dist, 0.5) #> [1] 0.2196956 logpdf(dist, 0.5) #> [1] -1.515512 hazard(dist, 0.5) #> [1] 0.2390877 chf(dist, 0.5) #> [1] 0.08458732 mean(dist) #> [1] 3 median(dist) #> [1] 2.365974 mode(dist) #> [1] 1 range(dist) #> [1]   0 Inf quantile(dist, 0.2) #> [1] 1.005174 standard_deviation(dist) #> [1] 2.44949 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 6 skewness(dist) #> [1] 1.632993 kurtosis(dist) #> [1] 7 kurtosis_excess(dist) #> [1] 4  # Convenience functions chi_squared_pdf(2, 3) #> [1] 0.2075537 chi_squared_lpdf(2, 3) #> [1] -1.572365 chi_squared_cdf(2, 3) #> [1] 0.4275933 chi_squared_lcdf(2, 3) #> [1] -0.8495828 chi_squared_quantile(0.5, 3) #> [1] 2.365974"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"exponential-distribution","dir":"Articles","previous_headings":"Statistics","what":"Exponential Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Exponential distribution with rate parameter lambda = 2 dist <- exponential_distribution(2) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6321206 logcdf(dist, 0.5) #> [1] -0.4586751 pdf(dist, 0.5) #> [1] 0.7357589 logpdf(dist, 0.5) #> [1] -0.3068528 hazard(dist, 0.5) #> [1] 2 chf(dist, 0.5) #> [1] 1 mean(dist) #> [1] 0.5 median(dist) #> [1] 0.3465736 mode(dist) #> [1] 0 range(dist) #> [1]   0 Inf quantile(dist, 0.2) #> [1] 0.1115718 standard_deviation(dist) #> [1] 0.5 support(dist) #> [1] 2.225074e-308 1.797693e+308 variance(dist) #> [1] 0.25 skewness(dist) #> [1] 2 kurtosis(dist) #> [1] 9 kurtosis_excess(dist) #> [1] 6  # Convenience functions exponential_pdf(1, 2) #> [1] 0.2706706 exponential_lpdf(1, 2) #> [1] -1.306853 exponential_cdf(1, 2) #> [1] 0.8646647 exponential_lcdf(1, 2) #> [1] -0.1454135 exponential_quantile(0.5, 2) #> [1] 0.3465736"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"extreme-value-distribution","dir":"Articles","previous_headings":"Statistics","what":"Extreme Value Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Extreme Value distribution with location = 0, scale = 1 dist <- extreme_value_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.5452392 logcdf(dist, 0.5) #> [1] -0.6065307 pdf(dist, 0.5) #> [1] 0.3307043 logpdf(dist, 0.5) #> [1] -1.106531 hazard(dist, 0.5) #> [1] 0.727205 chf(dist, 0.5) #> [1] 0.7879837 mean(dist) #> [1] 0.5772157 median(dist) #> [1] 0.3665129 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.475885 standard_deviation(dist) #> [1] 1.28255 support(dist) #> [1] -1.797693e+308  1.797693e+308 variance(dist) #> [1] 1.644934 skewness(dist) #> [1] 1.139547 kurtosis(dist) #> [1] 5.4 kurtosis_excess(dist) #> [1] 2.4  # Convenience functions extreme_value_pdf(0) #> [1] 0.3678794 extreme_value_lpdf(0) #> [1] -1 extreme_value_cdf(0) #> [1] 0.3678794 extreme_value_lcdf(0) #> [1] -1 extreme_value_quantile(0.5) #> [1] 0.3665129"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"f-distribution","dir":"Articles","previous_headings":"Statistics","what":"F Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Fisher F distribution with df1 = 5, df2 = 10 dist <- fisher_f_distribution(5, 10) # Apply generic functions cdf(dist, 0.5) #> [1] 0.2299751 logcdf(dist, 0.5) #> [1] -1.469784 pdf(dist, 0.5) #> [1] 0.687607 logpdf(dist, 0.5) #> [1] -0.3745378 hazard(dist, 0.5) #> [1] 0.8929673 chf(dist, 0.5) #> [1] 0.2613325 mean(dist) #> [1] 1.25 median(dist) #> [1] 0.9319332 mode(dist) #> [1] 0.5 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.4563364 standard_deviation(dist) #> [1] 1.163687 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 1.354167 skewness(dist) #> [1] 3.86702 kurtosis(dist) #> [1] 53.86154 kurtosis_excess(dist) #> [1] 50.86154  # Convenience functions fisher_f_pdf(1, 5, 10) #> [1] 0.4954798 fisher_f_lpdf(1, 5, 10) #> [1] -0.7022287 fisher_f_cdf(1, 5, 10) #> [1] 0.5348806 fisher_f_lcdf(1, 5, 10) #> [1] -0.6257118 fisher_f_quantile(0.5, 5, 10) #> [1] 0.9319332"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"gamma-distribution","dir":"Articles","previous_headings":"Statistics","what":"Gamma Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Gamma distribution with shape = 3, scale = 4 dist <- gamma_distribution(3, 4) # Apply generic functions cdf(dist, 0.5) #> [1] 0.0002964775 logcdf(dist, 0.5) #> [1] -8.123539 pdf(dist, 0.5) #> [1] 0.001723627 logpdf(dist, 0.5) #> [1] -6.363325 hazard(dist, 0.5) #> [1] 0.001724138 chf(dist, 0.5) #> [1] 0.0002965215 mean(dist) #> [1] 12 median(dist) #> [1] 10.69624 mode(dist) #> [1] 8 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 6.140177 standard_deviation(dist) #> [1] 6.928203 support(dist) #> [1] 2.225074e-308 1.797693e+308 variance(dist) #> [1] 48 skewness(dist) #> [1] 1.154701 kurtosis(dist) #> [1] 5 kurtosis_excess(dist) #> [1] 2  # Convenience functions gamma_pdf(2, 3, 4) #> [1] 0.01895408 gamma_lpdf(2, 3, 4) #> [1] -3.965736 gamma_cdf(2, 3, 4) #> [1] 0.01438768 gamma_lcdf(2, 3, 4) #> [1] -4.241383 gamma_quantile(0.5, 3, 4) #> [1] 10.69624"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"geometric-distribution","dir":"Articles","previous_headings":"Statistics","what":"Geometric Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Geometric distribution with probability of success prob = 0.5 dist <- geometric_distribution(0.5) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6464466 logcdf(dist, 0.5) #> [1] -0.4362647 pdf(dist, 0.5) #> [1] 0.3535534 logpdf(dist, 0.5) #> [1] -1.039721 hazard(dist, 0.5) #> [1] 1 chf(dist, 0.5) #> [1] 1.039721 mean(dist) #> [1] 1 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0 standard_deviation(dist) #> [1] 1.414214 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 2 skewness(dist) #> [1] 2.12132 kurtosis(dist) #> [1] 9.5 kurtosis_excess(dist) #> [1] 6.5  # Convenience functions geometric_pdf(3, 0.5) #> [1] 0.0625 geometric_lpdf(3, 0.5) #> [1] -2.772589 geometric_cdf(3, 0.5) #> [1] 0.9375 geometric_lcdf(3, 0.5) #> [1] -0.06453852 geometric_quantile(0.5, 0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"holtsmark-distribution","dir":"Articles","previous_headings":"Statistics","what":"Holtsmark Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Holtsmark distribution with location 0 and scale 1 dist <- holtsmark_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6394042 logcdf(dist, 0.5) #> [1] -0.4472184 pdf(dist, 0.5) #> [1] 0.2622968 logpdf(dist, 0.5) #> [1] -1.338278 hazard(dist, 0.5) #> [1] 0.7273985 chf(dist, 0.5) #> [1] 1.019998 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -1.234616 standard_deviation(dist) #> [1] Inf support(dist) #> [1] -Inf  Inf variance(dist) #> [1] Inf  # Convenience functions holtsmark_pdf(3) #> [1] 0.03150942 holtsmark_lpdf(3) #> [1] -3.457469 holtsmark_cdf(3) #> [1] 0.9484022 holtsmark_lcdf(3) #> [1] -0.05297661 holtsmark_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"hyperexponential-distribution","dir":"Articles","previous_headings":"Statistics","what":"Hyperexponential Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Hyperexponential distribution with probabilities = c(0.5, 0.5) and rates = c(1, 2) dist <- hyperexponential_distribution(c(0.5, 0.5), c(1, 2)) # Apply generic functions cdf(dist, 0.5) #> [1] 0.5127949 logcdf(dist, 0.5) #> [1] -0.6678792 pdf(dist, 0.5) #> [1] 0.6711448 logpdf(dist, 0.5) #> [1] -0.3987704 hazard(dist, 0.5) #> [1] 1.377541 chf(dist, 0.5) #> [1] 0.7190702 mean(dist) #> [1] 0.75 median(dist) #> [1] 0.4812118 mode(dist) #> [1] 0 range(dist) #> [1]   0 Inf quantile(dist, 0.2) #> [1] 0.1506519 standard_deviation(dist) #> [1] 0.8291562 support(dist) #> [1] 2.225074e-308 1.797693e+308 variance(dist) #> [1] 0.6875 skewness(dist) #> [1] 2.466911 kurtosis(dist) #> [1] 12.47107 kurtosis_excess(dist) #> [1] 9.471074  # Convenience functions hyperexponential_pdf(2, c(0.5, 0.5), c(1, 2)) #> [1] 0.08598328 hyperexponential_lpdf(2, c(0.5, 0.5), c(1, 2)) #> [1] -2.453602 hyperexponential_cdf(2, c(0.5, 0.5), c(1, 2)) #> [1] 0.9231745 hyperexponential_lcdf(2, c(0.5, 0.5), c(1, 2)) #> [1] -0.07993696 hyperexponential_quantile(0.5, c(0.5, 0.5), c(1, 2)) #> [1] 0.4812118"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"hypergeometric-distribution","dir":"Articles","previous_headings":"Statistics","what":"Hypergeometric Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Hypergeometric distribution with r = 5, n = 10, N = 20 dist <- hypergeometric_distribution(5, 10, 20) # Apply generic functions cdf(dist, 4) #> [1] 0.9837461 logcdf(dist, 4) #> [1] -0.01638741 pdf(dist, 4) #> [1] 0.1354489 logpdf(dist, 4) #> [1] -1.999161 hazard(dist, 4) #> [1] 8.333333 chf(dist, 4) #> [1] 4.119424 mean(dist) #> [1] 2.5 median(dist) #> [1] 3 mode(dist) #> [1] 3 range(dist) #> [1] 0 5 quantile(dist, 0.2) #> [1] 1 standard_deviation(dist) #> [1] 0.9933993 support(dist) #> [1] 0 5 variance(dist) #> [1] 0.9868421 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 5.756863 kurtosis_excess(dist) #> [1] 2.756863  # Convenience functions hypergeometric_pdf(3, 5, 10, 20) #> [1] 0.3482972 hypergeometric_lpdf(3, 5, 10, 20) #> [1] -1.054699 hypergeometric_cdf(3, 5, 10, 20) #> [1] 0.8482972 hypergeometric_lcdf(3, 5, 10, 20) #> [1] -0.1645242 hypergeometric_quantile(0.5, 5, 10, 20) #> [1] 3"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"inverse-chi-squared-distribution","dir":"Articles","previous_headings":"Statistics","what":"Inverse Chi-Squared Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Inverse Chi-Squared distribution with 10 degrees of freedom, scale = 1 dist <- inverse_chi_squared_distribution(10, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.02925269 logcdf(dist, 0.5) #> [1] -3.531784 pdf(dist, 0.5) #> [1] 0.3783327 logpdf(dist, 0.5) #> [1] -0.9719812 hazard(dist, 0.5) #> [1] 0.3897335 chf(dist, 0.5) #> [1] 0.02968908 mean(dist) #> [1] 1.25 median(dist) #> [1] 1.070455 mode(dist) #> [1] 0.8333333 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.7439393 standard_deviation(dist) #> [1] 0.7216878 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 0.5208333 skewness(dist) #> [1] 3.464102 kurtosis(dist) #> [1] 45 kurtosis_excess(dist) #> [1] 42  # Convenience functions inverse_chi_squared_pdf(2, 10, 1) #> [1] 0.1670024 inverse_chi_squared_lpdf(2, 10, 1) #> [1] -1.789747 inverse_chi_squared_cdf(2, 10, 1) #> [1] 0.891178 inverse_chi_squared_lcdf(2, 10, 1) #> [1] -0.1152111 inverse_chi_squared_quantile(0.5, 10, 1) #> [1] 1.070455"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"inverse-gamma-distribution","dir":"Articles","previous_headings":"Statistics","what":"Inverse Gamma Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Inverse Gamma distribution with shape = 5, scale = 4 dist <- inverse_gamma_distribution(5, 4) # Apply generic functions cdf(dist, 0.5) #> [1] 0.0996324 logcdf(dist, 0.5) #> [1] -2.306268 pdf(dist, 0.5) #> [1] 0.9160366 logpdf(dist, 0.5) #> [1] -0.08769894 hazard(dist, 0.5) #> [1] 1.017403 chf(dist, 0.5) #> [1] 0.1049522 mean(dist) #> [1] 1 median(dist) #> [1] 0.8563644 mode(dist) #> [1] 0.6666667 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.5951514 standard_deviation(dist) #> [1] 0.5773503 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 0.3333333 skewness(dist) #> [1] 3.464102 kurtosis(dist) #> [1] 45 kurtosis_excess(dist) #> [1] 42  # Convenience functions inverse_gamma_pdf(2, 5, 4) #> [1] 0.09022352 inverse_gamma_lpdf(2, 5, 4) #> [1] -2.405465 inverse_gamma_cdf(2, 5, 4) #> [1] 0.947347 inverse_gamma_lcdf(2, 5, 4) #> [1] -0.05408985 inverse_gamma_quantile(0.5, 5, 4) #> [1] 0.8563644"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"inverse-gaussian-distribution","dir":"Articles","previous_headings":"Statistics","what":"Inverse Gaussian Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Inverse Gaussian distribution with mu = 3, lambda = 4 dist <- inverse_gaussian_distribution(3, 4) # Apply generic functions cdf(dist, 0.5) #> [1] 0.01617264 logcdf(dist, 0.5) #> [1] -4.124435 pdf(dist, 0.5) #> [1] 0.1403174 logpdf(dist, 0.5) #> [1] -1.963848 hazard(dist, 0.5) #> [1] 0.142624 chf(dist, 0.5) #> [1] 0.01630484 mean(dist) #> [1] 3 median(dist) #> [1] 2.202698 mode(dist) #> [1] 1.140598 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 1.161488 standard_deviation(dist) #> [1] 2.598076 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 6.75 skewness(dist) #> [1] 2.598076 kurtosis(dist) #> [1] 8.25 kurtosis_excess(dist) #> [1] 11.25  # Convenience functions inverse_gaussian_pdf(2, 3, 4) #> [1] 0.2524295 inverse_gaussian_lpdf(2, 3, 4) #> [1] -1.376623 inverse_gaussian_cdf(2, 3, 4) #> [1] 0.4512408 inverse_gaussian_lcdf(2, 3, 4) #> [1] -0.7957542 inverse_gaussian_quantile(0.5, 3, 4) #> [1] 2.202698"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"kolmogorov-smirnov-distribution","dir":"Articles","previous_headings":"Statistics","what":"Kolmogorov-Smirnov Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Kolmogorov-Smirnov distribution with sample size n = 10 dist <- kolmogorov_smirnov_distribution(10) # Apply generic functions cdf(dist, 2) #> [1] 1 logcdf(dist, 2) #> [1] 0 pdf(dist, 2) #> [1] 2.887762e-33 logpdf(dist, 2) #> [1] -74.92483 hazard(dist, 2) #> [1] 80 chf(dist, 2) #> [1] 79.30685 mean(dist) #> [1] 0.2747169 median(dist) #> [1] 0.2617017 mode(dist) #> [1] 0.2325754 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.2039076 standard_deviation(dist) #> [1] 0.08232448 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 0.00677732 skewness(dist) #> [1] 0.8604261 kurtosis(dist) #> [1] 3.881619 kurtosis_excess(dist) #> [1] 0.881619  # Convenience functions kolmogorov_smirnov_pdf(0.5, 10) #> [1] 0.2695176 kolmogorov_smirnov_lpdf(0.5, 10) #> [1] -1.311122 kolmogorov_smirnov_cdf(0.5, 10) #> [1] 0.9865241 kolmogorov_smirnov_lcdf(0.5, 10) #> [1] -0.01356751 kolmogorov_smirnov_quantile(0.5, 10) #> [1] 0.2617017"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"landau-distribution","dir":"Articles","previous_headings":"Statistics","what":"Landau Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Landau distribution with location 0 and scale 1 dist <- landau_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.4842393 logcdf(dist, 0.5) #> [1] -0.7251762 pdf(dist, 0.5) #> [1] 0.2123185 logpdf(dist, 0.5) #> [1] -1.549668 hazard(dist, 0.5) #> [1] 0.4116608 chf(dist, 0.5) #> [1] 0.6621123 median(dist) #> [1] 0.5756301 mode(dist) #> [1] -0.4293145 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.5948319 support(dist) #> [1] -Inf  Inf  # Convenience functions landau_pdf(3) #> [1] 0.05863949 landau_lpdf(3) #> [1] -2.836347 landau_cdf(3) #> [1] 0.7792967 landau_lcdf(3) #> [1] -0.2493635 landau_quantile(0.5) #> [1] 0.5756301"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"laplace-distribution","dir":"Articles","previous_headings":"Statistics","what":"Laplace Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Laplace distribution with location = 0, scale = 1 dist <- laplace_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6967347 logcdf(dist, 0.5) #> [1] -0.3613506 pdf(dist, 0.5) #> [1] 0.3032653 logpdf(dist, 0.5) #> [1] -1.193147 hazard(dist, 0.5) #> [1] 1 chf(dist, 0.5) #> [1] 1.193147 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.9162907 standard_deviation(dist) #> [1] 1.414214 support(dist) #> [1] -Inf  Inf variance(dist) #> [1] 2 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 6 kurtosis_excess(dist) #> [1] 3  # Convenience functions laplace_pdf(0) #> [1] 0.5 laplace_lpdf(0) #> [1] -0.6931472 laplace_cdf(0) #> [1] 0.5 laplace_lcdf(0) #> [1] -0.6931472 laplace_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"logistic-distribution","dir":"Articles","previous_headings":"Statistics","what":"Logistic Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Logistic distribution with location = 0, scale = 1 dist <- logistic_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6224593 logcdf(dist, 0.5) #> [1] -0.474077 pdf(dist, 0.5) #> [1] 0.2350037 logpdf(dist, 0.5) #> [1] -1.448154 hazard(dist, 0.5) #> [1] 0.6224593 chf(dist, 0.5) #> [1] 0.974077 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -1.386294 standard_deviation(dist) #> [1] 1.813799 support(dist) #> [1] -1.797693e+308  1.797693e+308 variance(dist) #> [1] 3.289868 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 4.2 kurtosis_excess(dist) #> [1] 1.2  # Convenience functions logistic_pdf(0) #> [1] 0.25 logistic_lpdf(0) #> [1] -1.386294 logistic_cdf(0) #> [1] 0.5 logistic_lcdf(0) #> [1] -0.6931472 logistic_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"log-normal-distribution","dir":"Articles","previous_headings":"Statistics","what":"Log Normal Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Log Normal distribution with location = 0, scale = 1 dist <- lognormal_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.2441086 logcdf(dist, 0.5) #> [1] -1.410142 pdf(dist, 0.5) #> [1] 0.6274961 logpdf(dist, 0.5) #> [1] -0.4660179 hazard(dist, 0.5) #> [1] 0.8301405 chf(dist, 0.5) #> [1] 0.2798576 mean(dist) #> [1] 1.648721 median(dist) #> [1] 1 mode(dist) #> [1] 0.3678794 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.4310112 standard_deviation(dist) #> [1] 2.161197 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 4.670774 skewness(dist) #> [1] 6.184877 kurtosis(dist) #> [1] 113.9364 kurtosis_excess(dist) #> [1] 110.9364  # Convenience functions lognormal_pdf(0) #> [1] 0 lognormal_lpdf(0) #> [1] -Inf lognormal_cdf(0) #> [1] 0 lognormal_lcdf(0) #> [1] -Inf lognormal_quantile(0.5) #> [1] 1"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"map-airy-distribution","dir":"Articles","previous_headings":"Statistics","what":"Map-Airy Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Map-Airy distribution with location 0 and scale 1 dist <- mapairy_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.7527466 logcdf(dist, 0.5) #> [1] -0.2840266 pdf(dist, 0.5) #> [1] 0.1477024 logpdf(dist, 0.5) #> [1] -1.912556 hazard(dist, 0.5) #> [1] 0.5973726 chf(dist, 0.5) #> [1] 1.397342 mean(dist) #> [1] 0 median(dist) #> [1] -0.7167107 mode(dist) #> [1] -1.161587 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -1.834427 standard_deviation(dist) #> [1] Inf support(dist) #> [1] -Inf  Inf variance(dist) #> [1] Inf  # Convenience functions mapairy_pdf(3) #> [1] 0.02799732 mapairy_lpdf(3) #> [1] -3.575647 mapairy_cdf(3) #> [1] 0.9316961 mapairy_lcdf(3) #> [1] -0.07074859 mapairy_quantile(0.5) #> [1] -0.7167107"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"negative-binomial-distribution","dir":"Articles","previous_headings":"Statistics","what":"Negative Binomial Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Negative Binomial distribution with successes = 5, success_fraction = 0.5 dist <- negative_binomial_distribution(5, 0.5) # Apply generic functions cdf(dist, 0.5) #> [1] 0.06449911 logcdf(dist, 0.5) #> [1] -2.741104 pdf(dist, 0.5) #> [1] 0.05437955 logpdf(dist, 0.5) #> [1] -2.911767 hazard(dist, 0.5) #> [1] 0.05812881 chf(dist, 0.5) #> [1] 0.06667318 mean(dist) #> [1] 5 median(dist) #> [1] 4 mode(dist) #> [1] 4 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 1 standard_deviation(dist) #> [1] 3.162278 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 10 skewness(dist) #> [1] 0.9486833 kurtosis(dist) #> [1] 4.3 kurtosis_excess(dist) #> [1] 1.3  # Convenience functions negative_binomial_pdf(3, 5, 0.5) #> [1] 0.1367188 negative_binomial_lpdf(3, 5, 0.5) #> [1] -1.989829 negative_binomial_cdf(3, 5, 0.5) #> [1] 0.3632812 negative_binomial_lcdf(3, 5, 0.5) #> [1] -1.012578 negative_binomial_quantile(0.5, 5, 0.5) #> [1] 4"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"noncentral-beta-distribution","dir":"Articles","previous_headings":"Statistics","what":"Noncentral Beta Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Noncentral Beta distribution with shape parameters alpha = 2, beta = 3 # and noncentrality parameter lambda = 1 dist <- non_central_beta_distribution(2, 3, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.5977904 logcdf(dist, 0.5) #> [1] -0.514515 pdf(dist, 0.5) #> [1] 1.643543 logpdf(dist, 0.5) #> [1] 0.4968546 hazard(dist, 0.5) #> [1] 4.086286 chf(dist, 0.5) #> [1] 0.910782 mean(dist) #> [1] 0.44664 median(dist) #> [1] 0.4416064 mode(dist) #> [1] 0.4262677 range(dist) #> [1] 0 1 quantile(dist, 0.2) #> [1] 0.2549084 standard_deviation(dist) #> [1] 0.2040433 support(dist) #> [1] 0 1 variance(dist) #> [1] 0.04163366  # Convenience functions non_central_beta_pdf(0.5, 2, 3, 1) #> [1] 1.643543 non_central_beta_lpdf(0.5, 2, 3, 1) #> [1] 0.4968546 non_central_beta_cdf(0.5, 2, 3, 1) #> [1] 0.5977904 non_central_beta_lcdf(0.5, 2, 3, 1) #> [1] -0.514515 non_central_beta_quantile(0.5, 2, 3, 1) #> [1] 0.4416064"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"noncentral-chi-squared-distribution","dir":"Articles","previous_headings":"Statistics","what":"Noncentral Chi-Squared Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Noncentral Chi-Squared distribution with 3 degrees of freedom and noncentrality # parameter 1 dist <- non_central_chi_squared_distribution(3, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.05162593 logcdf(dist, 0.5) #> [1] -2.963731 pdf(dist, 0.5) #> [1] 0.1446374 logpdf(dist, 0.5) #> [1] -1.933525 hazard(dist, 0.5) #> [1] 0.1525109 chf(dist, 0.5) #> [1] 0.05300627 mean(dist) #> [1] 4 median(dist) #> [1] 3.213009 mode(dist) #> [1] 1.439229 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 1.384937 standard_deviation(dist) #> [1] 3.162278 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 10 skewness(dist) #> [1] 1.517893 kurtosis(dist) #> [1] 6.36 kurtosis_excess(dist) #> [1] 3.36  # Convenience functions non_central_chi_squared_pdf(2, 3, 1) #> [1] 0.172252 non_central_chi_squared_lpdf(2, 3, 1) #> [1] -1.758797 non_central_chi_squared_cdf(2, 3, 1) #> [1] 0.3082525 non_central_chi_squared_lcdf(2, 3, 1) #> [1] -1.176836 non_central_chi_squared_quantile(0.5, 3, 1) #> [1] 3.213009"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"noncentral-f-distribution","dir":"Articles","previous_headings":"Statistics","what":"Noncentral F Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Noncentral F distribution with df1 = 10, df2 = 10 and noncentrality # parameter 1 dist <- non_central_f_distribution(10, 10, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.1142528 logcdf(dist, 0.5) #> [1] -2.169342 pdf(dist, 0.5) #> [1] 0.5754471 logpdf(dist, 0.5) #> [1] -0.552608 hazard(dist, 0.5) #> [1] 0.6496742 chf(dist, 0.5) #> [1] 0.1213237 mean(dist) #> [1] 1.375 median(dist) #> [1] 1.10075 mode(dist) #> [1] 0.7349843 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.6363179 standard_deviation(dist) #> [1] 1.063113 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 1.130208 skewness(dist) #> [1] 3.609738 kurtosis(dist) #> [1] 51.0825 kurtosis_excess(dist) #> [1] 48.0825  # Convenience functions non_central_f_pdf(1, 5, 2, 1) #> [1] 0.3051418 non_central_f_lpdf(1, 5, 2, 1) #> [1] -1.186979 non_central_f_cdf(1, 5, 2, 1) #> [1] 0.3737987 non_central_f_lcdf(1, 5, 2, 1) #> [1] -0.9840377 non_central_f_quantile(0.5, 5, 2, 1) #> [1] 1.507635"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"noncentral-t-distribution","dir":"Articles","previous_headings":"Statistics","what":"Noncentral T Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Noncentral T distribution with 5 degrees of freedom and noncentrality parameter 1 dist <- non_central_t_distribution(5, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.3021259 logcdf(dist, 0.5) #> [1] -1.196912 pdf(dist, 0.5) #> [1] 0.3360046 logpdf(dist, 0.5) #> [1] -1.090631 hazard(dist, 0.5) #> [1] 0.4814687 chf(dist, 0.5) #> [1] 0.3597165 mean(dist) #> [1] 1.189416 median(dist) #> [1] 1.052851 mode(dist) #> [1] 0.8781834 range(dist) #> [1] -1.797693e+308  1.797693e+308 quantile(dist, 0.2) #> [1] 0.165306 standard_deviation(dist) #> [1] 1.385144 support(dist) #> [1] -1.797693e+308  1.797693e+308 variance(dist) #> [1] 1.918623 skewness(dist) #> [1] 1.26633 kurtosis(dist) #> [1] 13.32067 kurtosis_excess(dist) #> [1] 10.32067  # Convenience functions non_central_t_pdf(0, 5, 1) #> [1] 0.2302431 non_central_t_lpdf(0, 5, 1) #> [1] -1.46862 non_central_t_cdf(0, 5, 1) #> [1] 0.1586553 non_central_t_lcdf(0, 5, 1) #> [1] -1.841022 non_central_t_quantile(0.5, 5, 1) #> [1] 1.052851"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"normal-distribution","dir":"Articles","previous_headings":"Statistics","what":"Normal Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Normal distribution with mean = 0, sd = 1 dist <- normal_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6914625 logcdf(dist, 0.5) #> [1] -0.3689464 pdf(dist, 0.5) #> [1] 0.3520653 logpdf(dist, 0.5) #> [1] -1.043939 hazard(dist, 0.5) #> [1] 1.141078 chf(dist, 0.5) #> [1] 1.175912 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.8416212 standard_deviation(dist) #> [1] 1 support(dist) #> [1] -Inf  Inf variance(dist) #> [1] 1 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 3 kurtosis_excess(dist) #> [1] 0  # Convenience functions normal_pdf(0) #> [1] 0.3989423 normal_lpdf(0) #> [1] -0.9189385 normal_cdf(0) #> [1] 0.5 normal_lcdf(0) #> [1] -0.6931472 normal_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"pareto-distribution","dir":"Articles","previous_headings":"Statistics","what":"Pareto Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Pareto distribution with scale = 10, shape = 5 dist <- pareto_distribution(10, 5) # Apply generic functions cdf(dist, 0.5) #> [1] 0 logcdf(dist, 0.5) #> [1] -Inf pdf(dist, 0.5) #> [1] 0 logpdf(dist, 0.5) #> [1] -Inf hazard(dist, 0.5) #> [1] 0 chf(dist, 0.5) #> [1] 0 mean(dist) #> [1] 12.5 median(dist) #> [1] 11.48698 mode(dist) #> [1] 10 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 10.4564 standard_deviation(dist) #> [1] 3.227486 support(dist) #> [1]  1.000000e+01 1.797693e+308 variance(dist) #> [1] 10.41667 skewness(dist) #> [1] 4.64758 kurtosis(dist) #> [1] 73.8 kurtosis_excess(dist) #> [1] 70.8  # Convenience functions pareto_pdf(1) #> [1] 1 pareto_lpdf(1) #> [1] 0 pareto_cdf(1) #> [1] 0 pareto_lcdf(1) #> [1] -Inf pareto_quantile(0.5) #> [1] 2"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"poisson-distribution","dir":"Articles","previous_headings":"Statistics","what":"Poisson Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Poisson distribution with lambda = 1 dist <- poisson_distribution(1) # Apply generic functions cdf(dist, 5) #> [1] 0.9994058 logcdf(dist, 5) #> [1] -0.0005943614 pdf(dist, 5) #> [1] 0.003065662 logpdf(dist, 5) #> [1] -5.787492 hazard(dist, 5) #> [1] 5.159442 chf(dist, 5) #> [1] 7.42832 mean(dist) #> [1] 1 median(dist) #> [1] 1 mode(dist) #> [1] 1 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0 standard_deviation(dist) #> [1] 1 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 1 skewness(dist) #> [1] 1 kurtosis(dist) #> [1] 4 kurtosis_excess(dist) #> [1] 1  # Convenience functions poisson_pdf(0, 1) #> [1] 0.3678794 poisson_lpdf(0, 1) #> [1] -1 poisson_cdf(0, 1) #> [1] 0.3678794 poisson_lcdf(0, 1) #> [1] -1 poisson_quantile(0.5, 1) #> [1] 1"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"rayleigh-distribution","dir":"Articles","previous_headings":"Statistics","what":"Rayleigh Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Rayleigh distribution with sigma = 1 dist <- rayleigh_distribution(1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.1175031 logcdf(dist, 0.5) #> [1] -2.141291 pdf(dist, 0.5) #> [1] 0.4412485 logpdf(dist, 0.5) #> [1] -0.8181472 hazard(dist, 0.5) #> [1] 0.5 chf(dist, 0.5) #> [1] 0.125 mean(dist) #> [1] 1.253314 median(dist) #> [1] 1.17741 mode(dist) #> [1] 1 range(dist) #> [1]   0 Inf quantile(dist, 0.2) #> [1] 0.6680472 standard_deviation(dist) #> [1] 0.6551364 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 0.4292037 skewness(dist) #> [1] 0.6311107 kurtosis(dist) #> [1] 3.245089 kurtosis_excess(dist) #> [1] 0.2450893  # Convenience functions rayleigh_pdf(1) #> [1] 0.6065307 rayleigh_lpdf(1) #> [1] -0.5 rayleigh_cdf(1) #> [1] 0.3934693 rayleigh_lcdf(1) #> [1] -0.9327521 rayleigh_quantile(0.5) #> [1] 1.17741"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"sas-point5-distribution","dir":"Articles","previous_headings":"Statistics","what":"SaS Point5 Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# SaS Point5 distribution with location 0 and scale 1 dist <- saspoint5_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6686904 logcdf(dist, 0.5) #> [1] -0.402434 pdf(dist, 0.5) #> [1] 0.1707624 logpdf(dist, 0.5) #> [1] -1.767482 hazard(dist, 0.5) #> [1] 0.5154165 chf(dist, 0.5) #> [1] 1.104702 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -2.397479 support(dist) #> [1] -Inf  Inf  # Convenience functions saspoint5_pdf(3) #> [1] 0.02379919 saspoint5_lpdf(3) #> [1] -3.738104 saspoint5_cdf(3) #> [1] 0.8164545 saspoint5_lcdf(3) #> [1] -0.2027841 saspoint5_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"skew-normal-distribution","dir":"Articles","previous_headings":"Statistics","what":"Skew Normal Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Skew Normal distribution with location = 0, scale = 1, shape = 0 dist <- skew_normal_distribution(0, 1, 0) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6914625 logcdf(dist, 0.5) #> [1] -0.3689464 pdf(dist, 0.5) #> [1] 0.3520653 logpdf(dist, 0.5) #> [1] -1.043939 hazard(dist, 0.5) #> [1] 1.141078 chf(dist, 0.5) #> [1] 1.175912 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.8416212 standard_deviation(dist) #> [1] 1 support(dist) #> [1] -1.797693e+308  1.797693e+308 variance(dist) #> [1] 1 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 3 kurtosis_excess(dist) #> [1] 0  # Convenience functions skew_normal_pdf(0) #> [1] 0.3989423 skew_normal_lpdf(0) #> [1] -0.9189385 skew_normal_cdf(0) #> [1] 0.5 skew_normal_lcdf(0) #> [1] -0.6931472 skew_normal_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"students-t-distribution","dir":"Articles","previous_headings":"Statistics","what":"Student’s T Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Student's t distribution with 5 degrees of freedom dist <- students_t_distribution(5) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6808506 logcdf(dist, 0.5) #> [1] -0.3844124 pdf(dist, 0.5) #> [1] 0.3279185 logpdf(dist, 0.5) #> [1] -1.11499 hazard(dist, 0.5) #> [1] 1.027476 chf(dist, 0.5) #> [1] 1.142096 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.9195438 standard_deviation(dist) #> [1] 1.290994 support(dist) #> [1] -Inf  Inf variance(dist) #> [1] 1.666667 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 9 kurtosis_excess(dist) #> [1] 6  # Convenience functions students_t_pdf(0, 5) #> [1] 0.3796067 students_t_lpdf(0, 5) #> [1] -0.9686196 students_t_cdf(0, 5) #> [1] 0.5 students_t_lcdf(0, 5) #> [1] -0.6931472 students_t_quantile(0.5, 5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"triangular-distribution","dir":"Articles","previous_headings":"Statistics","what":"Triangular Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Triangular distribution with lower = -1, mode = 0, upper = 1 dist <- triangular_distribution(-1, 0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.875 logcdf(dist, 0.5) #> [1] -0.1335314 pdf(dist, 0.5) #> [1] 0.5 logpdf(dist, 0.5) #> [1] -0.6931472 hazard(dist, 0.5) #> [1] 4 chf(dist, 0.5) #> [1] 2.079442 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -1.797693e+308  1.797693e+308 quantile(dist, 0.2) #> [1] -0.3675445 standard_deviation(dist) #> [1] 0.4082483 support(dist) #> [1] -1  1 variance(dist) #> [1] 0.1666667 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 2.4 kurtosis_excess(dist) #> [1] -0.6  # Convenience functions triangular_pdf(1) #> [1] 0 triangular_lpdf(1) #> [1] -Inf triangular_cdf(1) #> [1] 1 triangular_lcdf(1) #> [1] 0 triangular_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"uniform-distribution","dir":"Articles","previous_headings":"Statistics","what":"Uniform Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Uniform distribution with lower = 0, upper = 1 dist <- uniform_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.5 logcdf(dist, 0.5) #> [1] -0.6931472 pdf(dist, 0.5) #> [1] 1 logpdf(dist, 0.5) #> [1] 0 hazard(dist, 0.5) #> [1] 2 chf(dist, 0.5) #> [1] 0.6931472 mean(dist) #> [1] 0.5 median(dist) #> [1] 0.5 mode(dist) #> [1] 0 range(dist) #> [1] -1.797693e+308  1.797693e+308 quantile(dist, 0.2) #> [1] 0.2 standard_deviation(dist) #> [1] 0.2886751 support(dist) #> [1] 0 1 variance(dist) #> [1] 0.08333333 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 1.8 kurtosis_excess(dist) #> [1] -1.2  # Convenience functions uniform_pdf(0.5) #> [1] 1 uniform_lpdf(0.5) #> [1] 0 uniform_cdf(0.5) #> [1] 0.5 uniform_lcdf(0.5) #> [1] -0.6931472 uniform_quantile(0.5) #> [1] 0.5"},{"path":"https://andrjohns.github.io/boostmath/articles/statistical-distributions.html","id":"weibull-distribution","dir":"Articles","previous_headings":"Statistics","what":"Weibull Distribution","title":"Boost Math - Statistical Distributions","text":"","code":"# Weibull distribution with shape = 1, scale = 1 dist <- weibull_distribution(1, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.3934693 logcdf(dist, 0.5) #> [1] -0.9327521 pdf(dist, 0.5) #> [1] 0.6065307 logpdf(dist, 0.5) #> [1] -0.5 hazard(dist, 0.5) #> [1] 1 chf(dist, 0.5) #> [1] 0.5 mean(dist) #> [1] 1 median(dist) #> [1] 0.6931472 mode(dist) #> [1] 0 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.2231436 standard_deviation(dist) #> [1] 1 support(dist) #> [1] 2.225074e-308 1.797693e+308 variance(dist) #> [1] 1 skewness(dist) #> [1] 2 kurtosis(dist) #> [1] 9 kurtosis_excess(dist) #> [1] 6  # Convenience functions weibull_pdf(1, shape = 1, scale = 1) #> [1] 0.3678794 weibull_lpdf(1, shape = 1, scale = 1) #> [1] -1 weibull_cdf(1, shape = 1, scale = 1) #> [1] 0.6321206 weibull_lcdf(1, shape = 1, scale = 1) #> [1] -0.4586751 weibull_quantile(0.5, shape = 1, scale = 1) #> [1] 0.6931472"},{"path":"https://andrjohns.github.io/boostmath/articles/statistics.html","id":"statistics","dir":"Articles","previous_headings":"","what":"Statistics","title":"Boost Math - Statistics","text":"Statistics section Boost Math library cover broad range areas","code":""},{"path":"https://andrjohns.github.io/boostmath/articles/statistics.html","id":"univariate-statistics","dir":"Articles","previous_headings":"Statistics","what":"Univariate Statistics","title":"Boost Math - Statistics","text":"","code":"# Mean mean_boost(c(1, 2, 3, 4, 5)) #> [1] 3 # Variance variance(c(1, 2, 3, 4, 5)) #> [1] 2 # Sample Variance sample_variance(c(1, 2, 3, 4, 5)) #> [1] 2.5 # Mean and Sample Variance mean_and_sample_variance(c(1, 2, 3, 4, 5)) #> [1] 3.0 2.5 # Skewness skewness(c(1, 2, 3, 4, 5)) #> [1] 0 # Kurtosis kurtosis(c(1, 2, 3, 4, 5)) #> [1] 1.7 # Excess Kurtosis excess_kurtosis(c(1, 2, 3, 4, 5)) #> [1] -1.3 # First Four Moments first_four_moments(c(1, 2, 3, 4, 5)) #> [1] 3.0 2.0 0.0 6.8 # Median median_boost(c(1, 2, 3, 4, 5)) #> [1] 3 # Median Absolute Deviation median_absolute_deviation(c(1, 2, 3, 4, 5)) #> [1] 1 # Interquartile Range interquartile_range(c(1, 2, 3, 4, 5)) #> [1] 3 # Gini Coefficient gini_coefficient(c(1, 2, 3, 4, 5)) #> [1] 0.2666667 # Sample Gini Coefficient sample_gini_coefficient(c(1, 2, 3, 4, 5)) #> [1] 0.3333333 # Mode mode(c(1, 2, 2, 3, 4)) #> [1] 2"},{"path":"https://andrjohns.github.io/boostmath/articles/statistics.html","id":"bivariate-statistics","dir":"Articles","previous_headings":"Statistics","what":"Bivariate Statistics","title":"Boost Math - Statistics","text":"","code":"# Covariance covariance(c(1, 2, 3), c(4, 5, 6)) #> [1] 0.6666667 # Means and Covariance means_and_covariance(c(1, 2, 3), c(4, 5, 6)) #> [1] 2.0000000 5.0000000 0.6666667 # Correlation Coefficient correlation_coefficient(c(1, 2, 3), c(4, 5, 6)) #> [1] 1"},{"path":"https://andrjohns.github.io/boostmath/articles/statistics.html","id":"signal-statistics","dir":"Articles","previous_headings":"Statistics","what":"Signal Statistics","title":"Boost Math - Statistics","text":"","code":"# Absolute Gini Coefficient absolute_gini_coefficient(c(1, 2, 3, 4, 5)) #> [1] 0.2666667 # Sample Absolute Gini Coefficient sample_absolute_gini_coefficient(c(1, 2, 3, 4, 5)) #> [1] 0.3333333 # Hoyer Sparsity hoyer_sparsity(c(1, 0, 0, 2, 3)) #> [1] 0.5117037  noisy_signal <- c(1.1, 2.1, 3.1) # Oracle SNR oracle_snr(c(1, 2, 3), c(1.1, 2.1, 3.1)) #> [1] 466.6667 # Oracle SNR in dB oracle_snr_db(c(1, 2, 3), c(1.1, 2.1, 3.1)) #> [1] 26.69007 # M2M4 SNR Estimator in dB m2m4_snr_estimator(c(1.1, 2.1, 3.1), 3, 2) #> [1] NaN # M2M4 SNR Estimator in dB m2m4_snr_estimator_db(c(1.1, 2.1, 3.1), 3, 2) #> [1] NaN"},{"path":"https://andrjohns.github.io/boostmath/articles/statistics.html","id":"anderson-darling-test","dir":"Articles","previous_headings":"Statistics","what":"Anderson-Darling Test","title":"Boost Math - Statistics","text":"","code":"# Anderson-Darling test for normality anderson_darling_normality_statistic(c(1, 2, 3, 4, 5), 0, 1) #> [1] 19.49684"},{"path":"https://andrjohns.github.io/boostmath/articles/statistics.html","id":"t-tests","dir":"Articles","previous_headings":"Statistics","what":"T-Tests","title":"Boost Math - Statistics","text":"","code":"# One Sample T-Test with parameters one_sample_t_test_params(sample_mean = 2, sample_variance = 1, num_samples = 30, assumed_mean = 0) #> [1] 1.095445e+01 8.021287e-12 # One Sample T-Test one_sample_t_test(c(1, 2, 3, 4, 5), assumed_mean = 0) #> [1] 4.2426407 0.0132356 # Two Sample T-Test two_sample_t_test(c(1, 2, 3), c(4, 5, 6)) #> [1] -3.67423461  0.02131164 # Paired Samples T-Test paired_samples_t_test(c(1, 2, 3), c(4, 5, 6)) #> [1] -Inf    0"},{"path":"https://andrjohns.github.io/boostmath/articles/statistics.html","id":"z-tests","dir":"Articles","previous_headings":"Statistics","what":"Z-Tests","title":"Boost Math - Statistics","text":"","code":"# One Sample Z-Test with parameters one_sample_z_test_params(sample_mean = 2, sample_variance = 1, num_samples = 30, assumed_mean = 0) #> [1] 1.095445e+01 8.021287e-12 # One Sample Z-Test one_sample_z_test(c(1, 2, 3, 4, 5), assumed_mean = 0) #> [1] 4.2426407 0.0132356 # Two Sample ZTest two_sample_z_test(c(1, 2, 3), c(4, 5, 6)) #> [1] -3.67423461  0.02131164"},{"path":"https://andrjohns.github.io/boostmath/articles/statistics.html","id":"runs-tests","dir":"Articles","previous_headings":"Statistics","what":"Runs Tests","title":"Boost Math - Statistics","text":"","code":"# Runs Above and Below Threshold runs_above_and_below_threshold(c(1, 2, 3, 4, 5), threshold = 3) #> [1] -1.2247449  0.2206714 #' # Runs Above and Below Median runs_above_and_below_median(c(1, 2, 3, 4, 5)) #> [1] -1.2247449  0.2206714"},{"path":"https://andrjohns.github.io/boostmath/articles/statistics.html","id":"ljung-box-tests","dir":"Articles","previous_headings":"Statistics","what":"Ljung-Box Tests","title":"Boost Math - Statistics","text":"","code":"# Ljung-Box test for autocorrelation ljung_box(c(1, 2, 3, 4, 5), lags = 2, fit_dof = 0) #> [1] 1.5166667 0.4684465"},{"path":"https://andrjohns.github.io/boostmath/articles/statistics.html","id":"linear-regression","dir":"Articles","previous_headings":"Statistics","what":"Linear Regression","title":"Boost Math - Statistics","text":"","code":"x <- c(1, 2, 3, 4, 5) y <- c(2, 3, 5, 7, 11) # Simple Ordinary Least Squares simple_ordinary_least_squares(x, y) #> [1] -1.0  2.2 # Simple Ordinary Least Squares with R-squared simple_ordinary_least_squares_with_R_squared(x, y) #> [1] -1.0000000  2.2000000  0.9453125"},{"path":"https://andrjohns.github.io/boostmath/articles/vector-functionals.html","id":"vector-functionals---norms","dir":"Articles","previous_headings":"","what":"Vector Functionals - Norms","title":"Boost Math - Vector Functionals","text":"","code":"# L0 Pseudo Norm l0_pseudo_norm(c(1, 0, 2, 0, 3)) #> [1] 3 # Hamming Distance hamming_distance(c(1, 0, 1), c(0, 1, 1)) #> [1] 2 # L1 Norm l1_norm(c(1, -2, 3)) #> [1] 6 # L1 Distance l1_distance(c(1, -2, 3), c(4, -5, 6)) #> [1] 9 # L2 Norm l2_norm(c(3, 4)) #> [1] 5 # L2 Distance l2_distance(c(3, 4), c(0, 0)) #> [1] 5 # Supremum Norm sup_norm(c(1, -2, 3)) #> [1] 3 # Supremum Distance sup_distance(c(1, -2, 3), c(4, -5, 6)) #> [1] 3 # Lp Norm lp_norm(c(1, -2, 3), 3) #> [1] 3.301927 # Lp Distance lp_distance(c(1, -2, 3), c(4, -5, 6), 3) #> [1] 4.326749 # Total Variation total_variation(c(1, 2, 1, 3)) #> [1] 4"},{"path":"https://andrjohns.github.io/boostmath/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Andrew R. Johnson. Author, maintainer.","code":""},{"path":"https://andrjohns.github.io/boostmath/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Johnson AR (2026). boostmath: 'R' Bindings 'Boost' Math Functions. R package version 1.4.0.9000, https://github.com/andrjohns/boostmath.","code":"@Manual{,   title = {boostmath: 'R' Bindings for the 'Boost' Math Functions},   author = {Andrew R. Johnson},   year = {2026},   note = {R package version 1.4.0.9000},   url = {https://github.com/andrjohns/boostmath}, }"},{"path":"https://andrjohns.github.io/boostmath/index.html","id":"boostmath","dir":"","previous_headings":"","what":"R Bindings for the Boost Math Functions","title":"R Bindings for the Boost Math Functions","text":"Providing simple access Boost’s Math functions R, compilation required.","code":""},{"path":"https://andrjohns.github.io/boostmath/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"R Bindings for the Boost Math Functions","text":"can install development version boostmath GitHub : can install pre-built binaries R-Universe:","code":"# install.packages(\"remotes\") remotes::install_github(\"andrjohns/boostmath\") install.packages(\"boostmath\", repos = c(\"https://andrjohns.r-universe.dev\",                                         \"https://cran.r-project.org\"))"},{"path":"https://andrjohns.github.io/boostmath/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"R Bindings for the Boost Math Functions","text":"Functions can used directly loading package: Boost Math functions share name R functions sufffixed _boost avoid conflicts:","code":"library(boostmath) #>  #> Attaching package: 'boostmath' #> The following object is masked from 'package:grDevices': #>  #>     pdf #> The following object is masked from 'package:base': #>  #>     mode  hypergeometric_pFq(c(1, 2.5), c(0.5, 2), 1) #> [1] 6.675991 ibeta_inv(2.1, 5.2, 0.7) #> [1] 0.361431 owens_t(2.1, 4.2) #> [1] 0.00893221 beta_boost(3, 2) #> [1] 0.08333333 lgamma_boost(5) #> [1] 3.178054"},{"path":"https://andrjohns.github.io/boostmath/index.html","id":"quadrature-and-differentiation","dir":"","previous_headings":"","what":"Quadrature and Differentiation","title":"R Bindings for the Boost Math Functions","text":"Boost’s integration routines also available use R functions: well numerical differentiation finite-differencing complex-step method:","code":"trapezoidal(function(x) { 1/(5 - 4*cos(x)) }, a = 0, b = 2*pi) #> [1] 2.094395  gauss_legendre(function(x) { x * x * atan(x) }, a = 0, b = 1, points = 20) #> [1] 0.2106573  gauss_kronrod(function(x) { exp(-x * x / 2) }, a = 0, b = Inf, points = 15) #> [1] 1.253314 finite_difference_derivative(exp, 1.7) #> [1] 5.473947  complex_step_derivative(exp, 1.7) #> [1] 5.473947"},{"path":"https://andrjohns.github.io/boostmath/index.html","id":"distribution-functions","dir":"","previous_headings":"","what":"Distribution Functions","title":"R Bindings for the Boost Math Functions","text":"boostmath implements Boost’s approach creating distribution ‘object’ various distribution functions (e.g., pdf, quantile) can applied: Alternatively, PDF, CDF, log-PDF, log-CDF, quantile functions statistical distributions can just called directly:","code":"# Normal distribution with mean = 0, sd = 1 dist <- normal_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6914625 logcdf(dist, 0.5) #> [1] -0.3689464 pdf(dist, 0.5) #> [1] 0.3520653 logpdf(dist, 0.5) #> [1] -1.043939 hazard(dist, 0.5) #> [1] 1.141078 chf(dist, 0.5) #> [1] 1.175912 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.8416212 standard_deviation(dist) #> [1] 1 support(dist) #> [1] -Inf  Inf variance(dist) #> [1] 1 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 3 kurtosis_excess(dist) #> [1] 0 beta_pdf(0.1, 1.2, 2.1) #> [1] 1.569287  beta_lpdf(0.1, 1.2, 2.1) #> [1] 0.4506213  beta_cdf(0.1, 1.2, 2.1) #> [1] 0.1380638  beta_lcdf(0.1, 1.2, 2.1) #> [1] -1.98004  beta_quantile(0.5, 1.2, 2.1) #> [1] 0.3335097"},{"path":"https://andrjohns.github.io/boostmath/reference/airy_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Airy Functions — airy_functions","title":"Airy Functions — airy_functions","text":"Functions compute Airy functions \\(Ai\\) \\(Bi\\), derivatives, zeros. Airy functions two linearly independent solutions differential equation: $$y'' - xy = 0$$ Airy \\(Ai\\) Function: first solution Airy differential equation. negative \\(x\\) values, \\(Ai(x)\\) exhibits oscillatory behavior. positive \\(x\\) values, \\(Ai(x)\\) monotonically decreases toward zero. Airy \\(Bi\\) Function: second solution Airy differential equation. negative \\(x\\) values, \\(Bi(x)\\) exhibits cyclic oscillation. positive \\(x\\) values, \\(Bi(x)\\) tends toward infinity. Airy \\(Ai'\\) Function: derivative first solution Airy differential equation. negative \\(x\\) values, \\(Ai'(x)\\) displays cyclic oscillation. positive \\(x\\) values, \\(Ai'(x)\\) approaches zero asymptotically. Airy \\(Bi'\\) Function: derivative second solution Airy differential equation. negative \\(x\\) values, \\(Bi'(x)\\) oscillates cyclically. positive \\(x\\) values, \\(Bi'(x)\\) increases toward infinity. Zeros Airy Functions: zeros values \\(Ai(x) = 0\\) \\(Bi(x) = 0\\). zeros indexed starting 1. first zeros approximately: \\(Ai\\): -2.33811, -4.08795, -5.52056, ... \\(Bi\\): -1.17371, -3.27109, -4.83074, ... functions implemented using relationships Bessel functions numerical accuracy.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/airy_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Airy Functions — airy_functions","text":"","code":"airy_ai(x)  airy_bi(x)  airy_ai_prime(x)  airy_bi_prime(x)  airy_ai_zero(m = NULL, start_index = NULL, number_of_zeros = NULL)  airy_bi_zero(m = NULL, start_index = NULL, number_of_zeros = NULL)"},{"path":"https://andrjohns.github.io/boostmath/reference/airy_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Airy Functions — airy_functions","text":"x Input numeric value m index zero find (1-based indexing, m=1 returns first zero). start_index starting index zeros (1-based). number_of_zeros number zeros find.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/airy_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Airy Functions — airy_functions","text":"Single numeric value Airy functions derivatives, vector length number_of_zeros multiple zero functions.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/airy_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Airy Functions — airy_functions","text":"","code":"airy_ai(2) #> [1] 0.03492413 airy_bi(2) #> [1] 3.298095 airy_ai_prime(2) #> [1] -0.05309038 airy_bi_prime(2) #> [1] 4.100682 airy_ai_zero(1) #> [1] -2.338107 airy_bi_zero(1) #> [1] -1.173713 airy_ai_zero(start_index = 1, number_of_zeros = 5) #> [1] -2.338107 -4.087949 -5.520560 -6.786708 -7.944134 airy_bi_zero(start_index = 1, number_of_zeros = 5) #> [1] -1.173713 -3.271093 -4.830738 -6.169852 -7.376762"},{"path":"https://andrjohns.github.io/boostmath/reference/anderson_darling_test.html","id":null,"dir":"Reference","previous_headings":"","what":"Anderson-Darling Test for Normality — anderson_darling_test","title":"Anderson-Darling Test for Normality — anderson_darling_test","text":"Performs Anderson-Darling test normality computing \\(^2\\) test statistic: $$^2 = n\\int_{-\\infty}^{\\infty}\\frac{(F_n(x)-F(x))^2F'(x)}{F(x)(1-F(x))}dx$$ Anderson-Darling test evaluates whether sample comes normal distribution computing integral empirical cumulative distribution function (ECDF) comparing normal distribution's CDF. Interpretation: \\(^2/n\\) approaches zero sample size increases, normality hypothesis supported \\(^2/n\\) converges positive finite value, normality hypothesis lacks support Important: input data vector x must sorted ascending order. Unsorted data trigger error.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/anderson_darling_test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Anderson-Darling Test for Normality — anderson_darling_test","text":"","code":"anderson_darling_normality_statistic(x, mu = 0, sd = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/anderson_darling_test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Anderson-Darling Test for Normality — anderson_darling_test","text":"x numeric vector sample data (must sorted ascending order). mu mean normal distribution test . Default 0. sd standard deviation normal distribution test . Default 1.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/anderson_darling_test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Anderson-Darling Test for Normality — anderson_darling_test","text":"Anderson-Darling \\(^2\\) test statistic.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/anderson_darling_test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Anderson-Darling Test for Normality — anderson_darling_test","text":"","code":"# Anderson-Darling test for normality with sorted data x <- sort(rnorm(100)) anderson_darling_normality_statistic(x, 0, 1) #> [1] 1.071972"},{"path":"https://andrjohns.github.io/boostmath/reference/arcsine_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Arcsine Distribution Functions — arcsine_distribution","title":"Arcsine Distribution Functions — arcsine_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function arcsine distribution interval \\([x_{min}, x_{max}]\\). arcsine distribution U-shaped distribution infinite density endpoints. \\(x_{min} < x < x_{max}\\): PDF : $$f(x; x_{min}, x_{max}) = \\frac{1}{\\pi\\sqrt{(x - x_{min})(x_{max} - x)}}$$ CDF : $$F(x; x_{min}, x_{max}) = \\frac{2}{\\pi}\\arcsin\\left(\\sqrt{\\frac{x - x_{min}}{x_{max} - x_{min}}}\\right)$$ quantile \\(0 < p < 1\\) $$F^{-1}(p; x_{min}, x_{max}) = x_{min} + (x_{max} - x_{min})\\sin^2\\left(\\frac{\\pi p}{2}\\right)$$ standard distribution \\([0, 1]\\), reduce $$f(x) = 1/(\\pi\\sqrt{x(1-x)})$$ $$F(x) = \\frac{2}{\\pi}\\arcsin(\\sqrt{x})$$","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/arcsine_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arcsine Distribution Functions — arcsine_distribution","text":"","code":"arcsine_distribution(x_min = 0, x_max = 1)  arcsine_pdf(x, x_min = 0, x_max = 1)  arcsine_lpdf(x, x_min = 0, x_max = 1)  arcsine_cdf(x, x_min = 0, x_max = 1)  arcsine_lcdf(x, x_min = 0, x_max = 1)  arcsine_quantile(p, x_min = 0, x_max = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/arcsine_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arcsine Distribution Functions — arcsine_distribution","text":"x_min Minimum value distribution (default 0). x_max Maximum value distribution (default 1). x Quantile value \\([x_{min}, x_{max}]\\). p Probability \\([0, 1]\\).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/arcsine_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arcsine Distribution Functions — arcsine_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/arcsine_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arcsine Distribution Functions — arcsine_distribution","text":"","code":"# Arcsine distribution with default parameters dist <- arcsine_distribution() # Apply generic functions cdf(dist, 0.5) #> [1] 0.5 logcdf(dist, 0.5) #> [1] -0.6931472 pdf(dist, 0.5) #> [1] 0.6366198 logpdf(dist, 0.5) #> [1] -0.4515827 hazard(dist, 0.5) #> [1] 1.27324 chf(dist, 0.5) #> [1] 0.6931472 mean(dist) #> [1] 0.5 median(dist) #> [1] 0.5 range(dist) #> [1] 0 1 quantile(dist, 0.2) #> [1] 0.0954915 standard_deviation(dist) #> [1] 0.3535534 support(dist) #> [1] 0 1 variance(dist) #> [1] 0.125 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 1.5 kurtosis_excess(dist) #> [1] -1.5  # Convenience functions arcsine_pdf(0.5) #> [1] 0.6366198 arcsine_lpdf(0.5) #> [1] -0.4515827 arcsine_cdf(0.5) #> [1] 0.5 arcsine_lcdf(0.5) #> [1] -0.6931472 arcsine_quantile(0.5) #> [1] 0.5"},{"path":"https://andrjohns.github.io/boostmath/reference/barycentric_rational.html","id":null,"dir":"Reference","previous_headings":"","what":"Barycentric Rational Interpolation — barycentric_rational","title":"Barycentric Rational Interpolation — barycentric_rational","text":"Barycentric rational interpolation high-accuracy interpolation method non-uniformly spaced samples. Performance Accuracy: requires O(N) time construction O(N) time evaluation. approximation order d, error O(h^(d+1)). Caveats: method robust can behave unexpectedly sample spacing endpoints much larger center.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/barycentric_rational.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Barycentric Rational Interpolation — barycentric_rational","text":"","code":"barycentric_rational(x, y, order = 3)"},{"path":"https://andrjohns.github.io/boostmath/reference/barycentric_rational.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Barycentric Rational Interpolation — barycentric_rational","text":"x Numeric vector data points (abscissas). y Numeric vector data values (ordinates). order Integer representing approximation order interpolator, defaults 3.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/barycentric_rational.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Barycentric Rational Interpolation — barycentric_rational","text":"object class barycentric_rational_interpolator methods: interpolate(xi): Evaluate interpolator point xi. prime(xi): Evaluate derivative interpolator point xi.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/barycentric_rational.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Barycentric Rational Interpolation — barycentric_rational","text":"","code":"x <- c(0, 1, 2, 3) y <- c(1, 2, 0, 2) order <- 3 interpolator <- barycentric_rational(x, y, order) xi <- 1.5 interpolator$interpolate(xi) #> [1] 0.9375 interpolator$prime(xi) #> [1] -2.291667"},{"path":"https://andrjohns.github.io/boostmath/reference/basic_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic Mathematical Functions — basic_functions","title":"Basic Mathematical Functions — basic_functions","text":"High-precision implementations basic mathematical functions enhanced numerical stability special cases. functions provide numerically stable alternatives standard operations, particularly useful working values near zero high precision required. Trigonometric Functions \\(\\pi\\): sin_pi(x): Computes \\(\\sin(\\pi x)\\) cos_pi(x): Computes \\(\\cos(\\pi x)\\) Logarithmic Exponential Functions: log1p_boost(x): Computes \\(\\log(1 + x)\\) accurately small \\(|x|\\) expm1_boost(x): Computes \\(\\exp(x) - 1\\) accurately small \\(|x|\\) Root Functions: cbrt(x): Computes cube root \\(x^{1/3}\\) sqrt1pm1(x): Computes \\(\\sqrt{1 + x} - 1\\) accurately small \\(|x|\\) rsqrt(x): Computes reciprocal square root \\(\\tfrac{1}{\\sqrt{x}}\\) Power Functions: powm1(x, y): Computes \\(x^y - 1\\) accurately Geometric Functions: hypot(x, y): Computes \\(\\sqrt{x^2 + y^2}\\) without overflow/underflow","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/basic_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic Mathematical Functions — basic_functions","text":"","code":"sin_pi(x)  cos_pi(x)  log1p_boost(x)  expm1_boost(x)  cbrt(x)  sqrt1pm1(x)  powm1(x, y)  hypot(x, y)  rsqrt(x)"},{"path":"https://andrjohns.github.io/boostmath/reference/basic_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic Mathematical Functions — basic_functions","text":"x Input numeric value y Second input numeric value (power hypotenuse functions)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/basic_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic Mathematical Functions — basic_functions","text":"single numeric value computed result function.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/basic_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic Mathematical Functions — basic_functions","text":"","code":"# sin(pi/2) = 1 (exact) sin_pi(0.5) #> [1] 1 # cos(pi/2) = 0 (exact) cos_pi(0.5) #> [1] 0 # log(1 + x) for small x log1p_boost(0.001) #> [1] 0.0009995003 # exp(x) - 1 for small x expm1_boost(0.001) #> [1] 0.0010005 # Cube root cbrt(8)  # Returns 2 #> [1] 2 # sqrt(1 + x) - 1 for small x sqrt1pm1(0.001) #> [1] 0.0004998751 # x^y - 1 accurately powm1(2, 3)  # Returns 7 (2^3 - 1) #> [1] 7 # Euclidean distance hypot(3, 4)  # Returns 5 #> [1] 5 # Reciprocal square root rsqrt(4)  # Returns 0.5 #> [1] 0.5"},{"path":"https://andrjohns.github.io/boostmath/reference/bernoulli_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Bernoulli Distribution Functions — bernoulli_distribution","title":"Bernoulli Distribution Functions — bernoulli_distribution","text":"Functions compute probability mass function (pmf), cumulative distribution function, quantile function Bernoulli distribution. Bernoulli distribution models single trial outcomes \\(k \\\\{0, 1\\}\\) success probability \\(p\\): $$P(X = 0) = 1 - p, \\quad P(X = 1) = p$$ $$F(0)=1-p, \\quad F(1)=1$$","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/bernoulli_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bernoulli Distribution Functions — bernoulli_distribution","text":"","code":"bernoulli_distribution(p_success)  bernoulli_pdf(x, p_success)  bernoulli_lpdf(x, p_success)  bernoulli_cdf(x, p_success)  bernoulli_lcdf(x, p_success)  bernoulli_quantile(p, p_success)"},{"path":"https://andrjohns.github.io/boostmath/reference/bernoulli_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bernoulli Distribution Functions — bernoulli_distribution","text":"p_success Probability success (0 <= p_success <= 1). x Quantile value (must 0 1). p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/bernoulli_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bernoulli Distribution Functions — bernoulli_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/bernoulli_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bernoulli Distribution Functions — bernoulli_distribution","text":"","code":"# Bernoulli distribution with p_success = 0.5 dist <- bernoulli_distribution(0.5) # Apply generic functions cdf(dist, 0.5) #> [1] 0.8183099 logcdf(dist, 0.5) #> [1] -0.2005142 pdf(dist, 0.5) #> [1] 0.6366198 logpdf(dist, 0.5) #> [1] -0.4515827 hazard(dist, 0.5) #> [1] 3.503877 chf(dist, 0.5) #> [1] 1.705453 mean(dist) #> [1] 0.5 median(dist) #> [1] 0 mode(dist) #> [1] 1 range(dist) #> [1] 0 1 quantile(dist, 0.2) #> [1] 0 standard_deviation(dist) #> [1] 0.5 support(dist) #> [1] 0 1 variance(dist) #> [1] 0.25 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 1 kurtosis_excess(dist) #> [1] -2  # Convenience functions bernoulli_pdf(1, 0.5) #> [1] 0.5 bernoulli_lpdf(1, 0.5) #> [1] -0.6931472 bernoulli_cdf(1, 0.5) #> [1] 1 bernoulli_lcdf(1, 0.5) #> [1] 0 bernoulli_quantile(0.5, 0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/reference/bessel_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Bessel Functions, Their Derivatives, and Zeros — bessel_functions","title":"Bessel Functions, Their Derivatives, and Zeros — bessel_functions","text":"Functions compute Bessel functions first second kind, modified versions, spherical Bessel functions, derivatives zeros. Bessel functions solutions Bessel's ordinary differential equation appear many problems cylindrical spherical symmetry, wave propagation, heat conduction, quantum mechanics. Bessel Functions First Second Kinds cyl_bessel_j(v, x): Computes Bessel function first kind \\(J_v(x)\\): $$J_v(x) = \\left(\\frac{1}{2}x\\right)^v\\sum_{k=0}^\\infty{\\frac{\\left(-\\frac{1}{4}x^2\\right)^k}{k!\\Gamma(v+k+1)}}$$ cyl_neumann(v, x): Computes Bessel function second kind \\(Y_v(x) = N_v(x)\\): $$Y_v(x) = \\frac{J_v(x)\\cos(v\\pi) - J_{-v}(x)}{\\sin(v\\pi)}$$ Modified Bessel Functions First Second Kinds cyl_bessel_i(v, x): Computes modified Bessel function first kind \\(I_v(x)\\): $$I_v(x) = \\left(\\frac{1}{2}x\\right)^v\\sum_{k=0}^\\infty{\\frac{\\left(\\frac{1}{4}x^2\\right)^k}{k!\\Gamma(v+k+1)}}$$ cyl_bessel_k(v, x): Computes modified Bessel function second kind \\(K_v(x)\\): $$K_v(x) = \\frac{\\pi}{2} \\frac{I_{-v}(x) - I_{v}(x)}{\\sin(v\\pi)}$$ Spherical Bessel Functions First Second Kinds sph_bessel(v, x): Computes Spherical Bessel function first kind \\(j_v(x)\\): $$j_v(x) = \\sqrt{\\frac{\\pi}{2x}}J_{v+\\frac{1}{2}}(x)$$ sph_neumann(v, x): Computes Spherical Bessel function second kind \\(y_v(x) = n_v(x)\\): $$y_v(x) = \\sqrt{\\frac{\\pi}{2x}}Y_{v+\\frac{1}{2}}(x)$$ Derivatives: _prime functions compute derivatives respect x corresponding Bessel functions: $$J'_v(x) = \\frac{J_{v-1}(x)-J_{v+1}(x)}{2}$$ $$Y'_v(x) = \\frac{Y_{v-1}(x)-Y_{v+1}(x)}{2}$$ $$'_v(x) = \\frac{I_{v-1}(x)-I_{v+1}(x)}{2}$$ $$K'_v(x) = \\frac{K_{v-1}(x)-K_{v+1}(x)}{-2}$$ $$j'_v(x) = \\left(\\frac{v}{x}\\right)j_v(x)-j_{v+1}(x)$$ $$y'_v(x) = \\left(\\frac{v}{x}\\right)y_v(x)-y_{v+1}(x)$$ Zeros: zero functions find zeros J_v Y_v (function equals zero), indexed starting 1.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/bessel_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bessel Functions, Their Derivatives, and Zeros — bessel_functions","text":"","code":"cyl_bessel_j(v, x)  cyl_neumann(v, x)  cyl_bessel_j_zero(v, m = NULL, start_index = NULL, number_of_zeros = NULL)  cyl_neumann_zero(v, m = NULL, start_index = NULL, number_of_zeros = NULL)  cyl_bessel_i(v, x)  cyl_bessel_k(v, x)  sph_bessel(v, x)  sph_neumann(v, x)  cyl_bessel_j_prime(v, x)  cyl_neumann_prime(v, x)  cyl_bessel_i_prime(v, x)  cyl_bessel_k_prime(v, x)  sph_bessel_prime(v, x)  sph_neumann_prime(v, x)"},{"path":"https://andrjohns.github.io/boostmath/reference/bessel_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bessel Functions, Their Derivatives, and Zeros — bessel_functions","text":"v Order Bessel function (can real number) x Argument Bessel function m index zero find (1-based). start_index starting index zeros (1-based). number_of_zeros number zeros find.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/bessel_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bessel Functions, Their Derivatives, and Zeros — bessel_functions","text":"Single numeric value Bessel functions derivatives, vector length number_of_zeros multiple zero functions.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/bessel_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bessel Functions, Their Derivatives, and Zeros — bessel_functions","text":"","code":"# Bessel function of the first kind J_0(1) cyl_bessel_j(0, 1) #> [1] 0.7651977 # Bessel function of the second kind Y_0(1) cyl_neumann(0, 1) #> [1] 0.08825696 # Modified Bessel function of the first kind I_0(1) cyl_bessel_i(0, 1) #> [1] 1.266066 # Modified Bessel function of the second kind K_0(1) cyl_bessel_k(0, 1) #> [1] 0.4210244 # Spherical Bessel function of the first kind j_0(1) sph_bessel(0, 1) #> [1] 0.841471 # Spherical Bessel function of the second kind y_0(1) sph_neumann(0, 1) #> [1] -0.5403023 # Derivative of the Bessel function of the first kind J_0(1) cyl_bessel_j_prime(0, 1) #> [1] -0.4400506 # Derivative of the Bessel function of the second kind Y_0(1) cyl_neumann_prime(0, 1) #> [1] 0.7812128 # Derivative of the modified Bessel function of the first kind I_0(1) cyl_bessel_i_prime(0, 1) #> [1] 0.5651591 # Derivative of the modified Bessel function of the second kind K_0(1) cyl_bessel_k_prime(0, 1) #> [1] -0.6019072 # Derivative of the spherical Bessel function of the first kind j_0(1) sph_bessel_prime(0, 1) #> [1] -0.3011687 # Derivative of the spherical Bessel function of the second kind y_0(1) sph_neumann_prime(0, 1) #> [1] 1.381773 # Finding the first zero of the Bessel function of the first kind J_0 cyl_bessel_j_zero(0, 1) #> [1] 2.404826 # Finding the first zero of the Bessel function of the second kind Y_0 cyl_neumann_zero(0, 1) #> [1] 0.893577 # Finding multiple zeros of the Bessel function of the first kind J_0 starting from index 1 cyl_bessel_j_zero(0, start_index = 1, number_of_zeros = 5) #> [1]  2.404826  5.520078  8.653728 11.791534 14.930918 # Finding multiple zeros of the Bessel function of the second kind Y_0 starting from index 1 cyl_neumann_zero(0, start_index = 1, number_of_zeros = 5) #> [1]  0.893577  3.957678  7.086051 10.222345 13.361097"},{"path":"https://andrjohns.github.io/boostmath/reference/beta_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Beta Distribution Functions — beta_distribution","title":"Beta Distribution Functions — beta_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function, parameter estimators Beta distribution. Beta distribution defined \\(x \\[0, 1]\\) shape parameters \\(\\alpha > 0\\) \\(\\beta > 0\\). PDF : $$f(x;\\alpha, \\beta) = \\frac{x^{\\alpha - 1}(1-x)^{\\beta - 1}}{B(\\alpha, \\beta)}$$ \\(B(\\alpha, \\beta)\\) beta function. CDF : $$F(x; \\alpha, \\beta) = I_x(\\alpha, \\beta)$$ \\(I_x\\) regularised incomplete beta function. quantile : $$F^{-1}(p; \\alpha, \\beta) = I_{p}^{-1}(\\alpha, \\beta)$$ \\(I_{p}^{-1}\\) inverse regularised incomplete beta function.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/beta_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Beta Distribution Functions — beta_distribution","text":"","code":"beta_distribution(alpha, beta)  beta_pdf(x, alpha, beta)  beta_lpdf(x, alpha, beta)  beta_cdf(x, alpha, beta)  beta_lcdf(x, alpha, beta)  beta_quantile(p, alpha, beta)  beta_find_alpha(mean = NULL, variance = NULL, beta = NULL, x = NULL, p = NULL)  beta_find_beta(mean = NULL, variance = NULL, alpha = NULL, x = NULL, p = NULL)"},{"path":"https://andrjohns.github.io/boostmath/reference/beta_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Beta Distribution Functions — beta_distribution","text":"alpha Shape parameter (alpha > 0). beta Shape parameter (beta > 0). x Quantile value (0 <= x <= 1). p Probability (0 <= p <= 1). mean Mean Beta distribution. variance Variance Beta distribution.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/beta_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Beta Distribution Functions — beta_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/beta_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Beta Distribution Functions — beta_distribution","text":"","code":"# Beta distribution with shape parameters alpha = 2, beta = 5 dist <- beta_distribution(2, 5) # Apply generic functions cdf(dist, 0.5) #> [1] 0.890625 logcdf(dist, 0.5) #> [1] -0.1158318 pdf(dist, 0.5) #> [1] 0.9375 logpdf(dist, 0.5) #> [1] -0.06453852 hazard(dist, 0.5) #> [1] 8.571429 chf(dist, 0.5) #> [1] 2.212973 mean(dist) #> [1] 0.2857143 median(dist) #> [1] 0.26445 mode(dist) #> [1] 0.2 range(dist) #> [1] 0 1 quantile(dist, 0.2) #> [1] 0.1398807 standard_deviation(dist) #> [1] 0.1597191 support(dist) #> [1] 0 1 variance(dist) #> [1] 0.0255102 skewness(dist) #> [1] 0.5962848 kurtosis(dist) #> [1] 2.88 kurtosis_excess(dist) #> [1] -0.12  # Convenience functions beta_pdf(0.5, 2, 5) #> [1] 0.9375 beta_lpdf(0.5, 2, 5) #> [1] -0.06453852 beta_cdf(0.5, 2, 5) #> [1] 0.890625 beta_lcdf(0.5, 2, 5) #> [1] -0.1158318 beta_quantile(0.5, 2, 5) #> [1] 0.26445  if (FALSE) { # \\dontrun{ # Find alpha given mean and variance beta_find_alpha(mean = 0.3, variance = 0.02) # Find alpha given beta, x, and probability beta_find_alpha(beta = 5, x = 0.4, p = 0.6) # Find beta given mean and variance beta_find_beta(mean = 0.3, variance = 0.02) # Find beta given alpha, x, and probability beta_find_beta(alpha = 2, x = 0.4, p = 0.6) } # }"},{"path":"https://andrjohns.github.io/boostmath/reference/beta_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Beta Functions — beta_functions","title":"Beta Functions — beta_functions","text":"Functions compute Beta function, normalised incomplete beta function, complements, well inverses derivatives. Beta Function \\(B(, b)\\): beta_boost(, b) $$B(, b) = \\frac{\\Gamma()\\Gamma(b)}{\\Gamma(+b)}$$ Incomplete Beta Functions: Normalised (Regularised) Functions: ibeta(, b, x): Normalised incomplete beta function \\(I_x(, b)\\) $$I_x(,b) = \\frac{1}{B(, b)}\\int_{0}^{x}t^{-1}(1-t)^{b-1}dt$$ ibetac(, b, x): Normalised complement, \\(1 - I_x(, b) = I_{1-x}(b, )\\) Non-normalised Functions: beta_boost(, b, x): Full incomplete beta function \\(B_x(, b)\\) $$\\int_{0}^{x}t^{-1}(1-t)^{b-1}dt$$ betac(, b, x): Full complement , \\(1 - B_x(, b) = B_{1-x}(b, )\\) Inverse Functions: Primary inverses (solving x): ibeta_inv(, b, p): Returns \\(x\\) \\(p = I_x(, b)\\) ibetac_inv(, b, q): Returns \\(x\\) \\(q = 1 - I_x(, b)\\) Parameter inverses (solving b): ibeta_inva(b, x, p): Returns \\(p = I_x(, b)\\) ibetac_inva(b, x, q): Returns \\(q = 1 - I_x(, b)\\) ibeta_invb(, x, p): Returns b \\(p = I_x(, b)\\) ibetac_invb(, x, q): Returns b \\(q = 1 - I_x(, b)\\)s Derivatives: ibeta_derivative(, b, x): Computes partial derivative respect x incomplete beta function $$\\frac{\\partial}{\\partial x}I_x(,b) = \\frac{(1-x)^{b-1}x^{-1}}{B(,b)}$$","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/beta_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Beta Functions — beta_functions","text":"","code":"beta_boost(a, b, x = NULL)  ibeta(a, b, x)  ibetac(a, b, x)  betac(a, b, x)  ibeta_inv(a, b, p)  ibetac_inv(a, b, q)  ibeta_inva(b, x, p)  ibetac_inva(b, x, q)  ibeta_invb(a, x, p)  ibetac_invb(a, x, q)  ibeta_derivative(a, b, x)"},{"path":"https://andrjohns.github.io/boostmath/reference/beta_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Beta Functions — beta_functions","text":"First parameter beta function (must positive) b Second parameter beta function (must positive) x Upper limit integration (0 <= x <= 1) p Probability value (0 <= p <= 1) q Probability value (0 <= q <= 1), q = 1 - p","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/beta_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Beta Functions — beta_functions","text":"single numeric value computed beta function, normalised incomplete beta function, complements, depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/beta_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Beta Functions — beta_functions","text":"","code":"if (FALSE) { # \\dontrun{ # Euler beta function B(2, 3) beta_boost(2, 3) # Normalised incomplete beta function I_x(2, 3) for x = 0.5 ibeta(2, 3, 0.5) # Normalised complement of the incomplete beta function 1 - I_x(2, 3) for x = 0.5 ibetac(2, 3, 0.5) # Full incomplete beta function B_x(2, 3) for x = 0.5 beta_boost(2, 3, 0.5) # Full complement of the incomplete beta function 1 - B_x(2, 3) for x = 0.5 betac(2, 3, 0.5) # Inverse of the normalised incomplete beta function I_x(2, 3) = 0.5 ibeta_inv(2, 3, 0.5) # Inverse of the normalised complement of the incomplete beta function I_x(2, 3) = 0.5 ibetac_inv(2, 3, 0.5) # Inverse of the normalised complement of the incomplete beta function I_x(a, b) # with respect to a for x = 0.5 and q = 0.5 ibetac_inva(3, 0.5, 0.5) # Inverse of the normalised incomplete beta function I_x(a, b) # with respect to b for x = 0.5 and p = 0.5 ibeta_invb(0.8, 0.5, 0.5) # Inverse of the normalised complement of the incomplete beta function I_x(a, b) # with respect to b for x = 0.5 and q = 0.5 ibetac_invb(2, 0.5, 0.5) # Derivative of the incomplete beta function with respect to x for a = 2, b = 3, x = 0.5 ibeta_derivative(2, 3, 0.5) } # }"},{"path":"https://andrjohns.github.io/boostmath/reference/bezier_polynomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Bezier Polynomial Interpolator — bezier_polynomial","title":"Bezier Polynomial Interpolator — bezier_polynomial","text":"Bezier polynomials smooth curves approximate set control points. commonly used computer-aided geometric design. Properties: curve approximating, meaning necessarily pass control points. Passing n control points creates polynomial degree n-1. Evaluation O(N^2) via de Casteljau's algorithm.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/bezier_polynomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bezier Polynomial Interpolator — bezier_polynomial","text":"","code":"bezier_polynomial(control_points)"},{"path":"https://andrjohns.github.io/boostmath/reference/bezier_polynomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bezier Polynomial Interpolator — bezier_polynomial","text":"control_points List control points, element numeric vector length 3.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/bezier_polynomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bezier Polynomial Interpolator — bezier_polynomial","text":"object class bezier_polynomial methods: interpolate(xi): Evaluate interpolator point xi. prime(xi): Evaluate derivative interpolator point xi. edit_control_point(new_control_point, index): Insert new control point specified index.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/bezier_polynomial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bezier Polynomial Interpolator — bezier_polynomial","text":"","code":"control_points <- list(c(0, 0, 0), c(1, 2, 0), c(2, 0, 0), c(3, 3, 0)) interpolator <- bezier_polynomial(control_points) xi <- 1.5 interpolator$interpolate(xi) #> [1] NaN NaN NaN interpolator$prime(xi) #> [1]  3.00 30.75  0.00 new_control_point <- c(1.5, 1, 0) interpolator$edit_control_point(new_control_point, 2)"},{"path":"https://andrjohns.github.io/boostmath/reference/bilinear_uniform.html","id":null,"dir":"Reference","previous_headings":"","what":"Bilinear Uniform Interpolator — bilinear_uniform","title":"Bilinear Uniform Interpolator — bilinear_uniform","text":"bilinear uniform interpolator takes grid data points specified linear index interpolates segment using bilinear function. Details: \"Bilinear\" means product two linear functions. interpolant continuous evaluation constant time. interpolator point-centered.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/bilinear_uniform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bilinear Uniform Interpolator — bilinear_uniform","text":"","code":"bilinear_uniform(x, rows, cols, dx = 1, dy = 1, x0 = 0, y0 = 0)"},{"path":"https://andrjohns.github.io/boostmath/reference/bilinear_uniform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bilinear Uniform Interpolator — bilinear_uniform","text":"x Numeric vector grid elements rows Integer representing number rows grid cols Integer representing number columns grid dx Numeric value representing spacing grid points x-direction, defaults 1 dy Numeric value representing spacing grid points y-direction, defaults 1 x0 Numeric value representing x-coordinate origin, defaults 0 y0 Numeric value representing y-coordinate origin, defaults 0","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/bilinear_uniform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bilinear Uniform Interpolator — bilinear_uniform","text":"object class bilinear_uniform methods: interpolate(xi, yi): Evaluate interpolator point (xi, yi).","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/bilinear_uniform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bilinear Uniform Interpolator — bilinear_uniform","text":"","code":"x <- seq(0, 1, length.out = 10) interpolator <- bilinear_uniform(x, rows = 2, cols = 5) xi <- 0.5 yi <- 0.5 interpolator$interpolate(xi, yi) #> [1] 0.3333333"},{"path":"https://andrjohns.github.io/boostmath/reference/binomial_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Binomial Distribution Functions — binomial_distribution","title":"Binomial Distribution Functions — binomial_distribution","text":"Functions compute probability mass function (pmf), cumulative distribution function, quantile function, confidence bounds Binomial distribution. Binomial distribution models number successes $k$ $n$ independent trials success probability p. pmf $$P(X = k) = \\binom{n}{k} p^k (1 - p)^{n-k}$$ Accuracy Implementation Notes: CDF related functions implemented using incomplete beta functions (ibeta, ibetac). pmf evaluated via ibeta_derivative stability. Quantiles obtained numerically (TOMS 748), since closed-form inverse exists discrete $k$. discrete distribution, quantiles rounded outward ensure least requested coverage; use complements improved tail accuracy. Confidence Bounds: binomial_find_lower_bound_on_p binomial_find_upper_bound_on_p implement Clopper-Pearson exact intervals (default) Jeffreys prior intervals, described Boost documentation.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/binomial_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binomial Distribution Functions — binomial_distribution","text":"","code":"binomial_distribution(n, prob)  binomial_pdf(k, n, prob)  binomial_lpdf(k, n, prob)  binomial_cdf(k, n, prob)  binomial_lcdf(k, n, prob)  binomial_quantile(p, n, prob)  binomial_find_lower_bound_on_p(n, k, alpha, method = \"clopper_pearson_exact\")  binomial_find_upper_bound_on_p(n, k, alpha, method = \"clopper_pearson_exact\")  binomial_find_minimum_number_of_trials(k, prob, alpha)  binomial_find_maximum_number_of_trials(k, prob, alpha)"},{"path":"https://andrjohns.github.io/boostmath/reference/binomial_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binomial Distribution Functions — binomial_distribution","text":"n Number trials (n >= 0). prob Probability success trial (0 <= prob <= 1). k Number successes (0 <= k <= n). p Probability (0 <= p <= 1). alpha Largest acceptable probability true value success fraction less value returned (binomial_find_lower_bound_on_p) greater value returned (binomial_find_upper_bound_on_p). method Method use calculating confidence bounds. Options \"clopper_pearson_exact\" (default) \"jeffreys_prior\".","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/binomial_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binomial Distribution Functions — binomial_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/binomial_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Binomial Distribution Functions — binomial_distribution","text":"","code":"# Binomial distribution with n = 10, prob = 0.5 dist <- binomial_distribution(10, 0.5) # Apply generic functions cdf(dist, 2) #> [1] 0.0546875 logcdf(dist, 2) #> [1] -2.90612 pdf(dist, 2) #> [1] 0.04394531 logpdf(dist, 2) #> [1] -3.124809 hazard(dist, 2) #> [1] 0.0464876 chf(dist, 2) #> [1] 0.05623972 mean(dist) #> [1] 5 median(dist) #> [1] 5 mode(dist) #> [1] 5 range(dist) #> [1]  0 10 quantile(dist, 0.2) #> [1] 3 standard_deviation(dist) #> [1] 1.581139 support(dist) #> [1]  0 10 variance(dist) #> [1] 2.5 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 2.8 kurtosis_excess(dist) #> [1] -0.2  # Convenience functions binomial_pdf(3, 10, 0.5) #> [1] 0.1171875 binomial_lpdf(3, 10, 0.5) #> [1] -2.14398 binomial_cdf(3, 10, 0.5) #> [1] 0.171875 binomial_lcdf(3, 10, 0.5) #> [1] -1.760988 binomial_quantile(0.5, 10, 0.5) #> [1] 5  if (FALSE) { # \\dontrun{ # Find lower bound on p given k = 3 successes in n = 10 trials with 95% confidence binomial_find_lower_bound_on_p(10, 3, 0.05) # Find upper bound on p given k = 3 successes in n = 10 trials with 95% confidence binomial_find_upper_bound_on_p(10, 3, 0.05) # Find minimum number of trials n to observe k = 3 successes with p = 0.5 at 95% confidence binomial_find_minimum_number_of_trials(3, 0.5, 0.05) # Find maximum number of trials n to observe k = 3 successes with p = 0.5 at 95% confidence binomial_find_maximum_number_of_trials(3, 0.5, 0.05) } # }"},{"path":"https://andrjohns.github.io/boostmath/reference/bivariate_statistics.html","id":null,"dir":"Reference","previous_headings":"","what":"Bivariate Statistics Functions — bivariate_statistics","title":"Bivariate Statistics Functions — bivariate_statistics","text":"Functions compute bivariate statistics including covariance Pearson correlation coefficient. Covariance: population covariance $$\\operatorname{cov}(x, y) = \\frac{1}{n}\\sum_{=1}^n (x_i - \\bar{x})(y_i - \\bar{y})$$ Correlation Coefficient: Pearson correlation coefficient $$\\rho_{x,y} = \\frac{\\operatorname{cov}(x, y)}{\\sigma_x \\sigma_y}$$","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/bivariate_statistics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bivariate Statistics Functions — bivariate_statistics","text":"","code":"covariance(x, y)  means_and_covariance(x, y)  correlation_coefficient(x, y)"},{"path":"https://andrjohns.github.io/boostmath/reference/bivariate_statistics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bivariate Statistics Functions — bivariate_statistics","text":"x numeric vector. y numeric vector.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/bivariate_statistics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bivariate Statistics Functions — bivariate_statistics","text":"numeric value (tuple means_and_covariance) computed statistic.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/bivariate_statistics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bivariate Statistics Functions — bivariate_statistics","text":"","code":"# Covariance covariance(c(1, 2, 3), c(4, 5, 6)) #> [1] 0.6666667 # Means and Covariance means_and_covariance(c(1, 2, 3), c(4, 5, 6)) #> [1] 2.0000000 5.0000000 0.6666667 # Correlation Coefficient correlation_coefficient(c(1, 2, 3), c(4, 5, 6)) #> [1] 1"},{"path":"https://andrjohns.github.io/boostmath/reference/boostmath-package.html","id":null,"dir":"Reference","previous_headings":"","what":"boostmath: 'R' Bindings for the 'Boost' Math Functions — boostmath-package","title":"boostmath: 'R' Bindings for the 'Boost' Math Functions — boostmath-package","text":"'R' bindings various functions statistical distributions provided 'Boost' Math library https://www.boost.org/doc/libs/latest/libs/math/doc/html/index.html.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/boostmath-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"boostmath: 'R' Bindings for the 'Boost' Math Functions — boostmath-package","text":"Maintainer: Andrew R. Johnson andrew.johnson@arjohnsonau.com (ORCID)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_cubic_b_spline.html","id":null,"dir":"Reference","previous_headings":"","what":"Cardinal Cubic B-Spline Interpolator — cardinal_cubic_b_spline","title":"Cardinal Cubic B-Spline Interpolator — cardinal_cubic_b_spline","text":"cardinal cubic B-spline interpolator allows fast accurate interpolation function known equally spaced points. Mathematical Properties: uses compactly supported basis functions constructed via iterative convolution, ensuring numerical stability. interpolant O(h^4) accurate values O(h^3) accurate derivatives, h step size. Conditions: Ideally, function interpolated four-times continuously differentiable. derivatives endpoints provided, estimated using one-sided finite-difference formulas.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_cubic_b_spline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cardinal Cubic B-Spline Interpolator — cardinal_cubic_b_spline","text":"","code":"cardinal_cubic_b_spline(   y,   t0,   h,   left_endpoint_derivative = NULL,   right_endpoint_derivative = NULL )"},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_cubic_b_spline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cardinal Cubic B-Spline Interpolator — cardinal_cubic_b_spline","text":"y Numeric vector data points interpolate. t0 Numeric scalar representing starting point data. h Numeric scalar representing spacing data points. left_endpoint_derivative Optional numeric scalar derivative left endpoint. right_endpoint_derivative Optional numeric scalar derivative right endpoint.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_cubic_b_spline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cardinal Cubic B-Spline Interpolator — cardinal_cubic_b_spline","text":"object class cardinal_cubic_b_spline methods: interpolate(x): Evaluate spline point x. prime(x): Evaluate first derivative spline point x. double_prime(x): Evaluate second derivative spline point x.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_cubic_b_spline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cardinal Cubic B-Spline Interpolator — cardinal_cubic_b_spline","text":"","code":"y <- c(1, 2, 0, 2, 1) t0 <- 0 h <- 1 spline_obj <- cardinal_cubic_b_spline(y, t0, h) x <- 0.5 spline_obj$interpolate(x) #> [1] 2.895833 spline_obj$prime(x) #> [1] 0.125 spline_obj$double_prime(x) #> [1] -11.16667"},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_cubic_hermite.html","id":null,"dir":"Reference","previous_headings":"","what":"Cardinal Cubic Hermite Interpolator — cardinal_cubic_hermite","title":"Cardinal Cubic Hermite Interpolator — cardinal_cubic_hermite","text":"cardinal cubic Hermite interpolator similar cubic Hermite interpolator optimised equispaced data. Performance: allows constant-time evaluation.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_cubic_hermite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cardinal Cubic Hermite Interpolator — cardinal_cubic_hermite","text":"","code":"cardinal_cubic_hermite(y, dydx, x0, dx)"},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_cubic_hermite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cardinal Cubic Hermite Interpolator — cardinal_cubic_hermite","text":"y Numeric vector ordinates (y-coordinates). dydx Numeric vector derivatives (slopes) point. x0 Numeric value first abscissa (x-coordinate). dx Numeric value spacing abscissas.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_cubic_hermite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cardinal Cubic Hermite Interpolator — cardinal_cubic_hermite","text":"object class cardinal_cubic_hermite methods: interpolate(xi): Evaluate interpolator point xi. prime(xi): Evaluate derivative interpolator point xi. domain(): Get domain interpolator.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_cubic_hermite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cardinal Cubic Hermite Interpolator — cardinal_cubic_hermite","text":"","code":"y <- c(0, 1, 0) dydx <- c(1, 0, -1) interpolator <- cardinal_cubic_hermite(y, dydx, 0, 1) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.625 interpolator$prime(xi) #> [1] 1.25 interpolator$domain() #> [1] 0 2"},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quadratic_b_spline.html","id":null,"dir":"Reference","previous_headings":"","what":"Cardinal Quadratic B-Spline Interpolator — cardinal_quadratic_b_spline","title":"Cardinal Quadratic B-Spline Interpolator — cardinal_quadratic_b_spline","text":"cardinal quadratic B-spline interpolator nearly cubic B-spline interpolator, uses quadratic basis functions. Use Cases: Basis functions constructed convolving box function twice. Since basis functions less smooth cubic B-spline, primarily useful approximating functions reduced smoothness. appropriate functions two three times continuously differentiable.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quadratic_b_spline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cardinal Quadratic B-Spline Interpolator — cardinal_quadratic_b_spline","text":"","code":"cardinal_quadratic_b_spline(   y,   t0,   h,   left_endpoint_derivative = NULL,   right_endpoint_derivative = NULL )"},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quadratic_b_spline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cardinal Quadratic B-Spline Interpolator — cardinal_quadratic_b_spline","text":"y Numeric vector data points interpolate. t0 Numeric scalar representing starting point data. h Numeric scalar representing spacing data points. left_endpoint_derivative Optional numeric scalar derivative left endpoint. right_endpoint_derivative Optional numeric scalar derivative right endpoint.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quadratic_b_spline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cardinal Quadratic B-Spline Interpolator — cardinal_quadratic_b_spline","text":"object class cardinal_quadratic_b_spline methods: interpolate(xi): Evaluate interpolator point xi. prime(xi): Evaluate derivative interpolator point xi.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quadratic_b_spline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cardinal Quadratic B-Spline Interpolator — cardinal_quadratic_b_spline","text":"","code":"y <- c(0, 1, 0, 1) t0 <- 0 h <- 1 interpolator <- cardinal_quadratic_b_spline(y, t0, h) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.7857143 interpolator$prime(xi) #> [1] 1.142857"},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quintic_b_spline.html","id":null,"dir":"Reference","previous_headings":"","what":"Cardinal Quintic B-Spline Interpolator — cardinal_quintic_b_spline","title":"Cardinal Quintic B-Spline Interpolator — cardinal_quintic_b_spline","text":"cardinal quintic B-spline interpolator similar cubic B-spline uses basis functions constructed convolving box function five times. Properties: basis functions smooth (C4) cubic B-spline (C2), making useful computing second derivatives. second derivative quintic B-spline cubic spline.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quintic_b_spline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cardinal Quintic B-Spline Interpolator — cardinal_quintic_b_spline","text":"","code":"cardinal_quintic_b_spline(   y,   t0,   h,   left_endpoint_derivatives = NULL,   right_endpoint_derivatives = NULL )"},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quintic_b_spline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cardinal Quintic B-Spline Interpolator — cardinal_quintic_b_spline","text":"y Numeric vector data points interpolate. t0 Numeric scalar representing starting point data. h Numeric scalar representing spacing data points. left_endpoint_derivatives Optional two-element numeric vector derivative left endpoint. right_endpoint_derivatives Optional two-element numeric vector derivative right endpoint.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quintic_b_spline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cardinal Quintic B-Spline Interpolator — cardinal_quintic_b_spline","text":"object class cardinal_quintic_b_spline methods: interpolate(xi): Evaluate interpolator point xi. prime(xi): Evaluate derivative interpolator point xi. double_prime(xi): Evaluate second derivative interpolator point xi.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quintic_b_spline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cardinal Quintic B-Spline Interpolator — cardinal_quintic_b_spline","text":"","code":"y <- seq(0, 1, length.out = 20) t0 <- 0 h <- 1 interpolator <- cardinal_quintic_b_spline(y, t0, h) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.02631579 interpolator$prime(xi) #> [1] 0.05263158 interpolator$double_prime(xi) #> [1] 8.84709e-17"},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quintic_hermite.html","id":null,"dir":"Reference","previous_headings":"","what":"Cardinal Quintic Hermite Interpolator — cardinal_quintic_hermite","title":"Cardinal Quintic Hermite Interpolator — cardinal_quintic_hermite","text":"cardinal quintic Hermite interpolator similar quintic Hermite interpolator optimised equispaced data. Performance: allows constant-time evaluation.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quintic_hermite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cardinal Quintic Hermite Interpolator — cardinal_quintic_hermite","text":"","code":"cardinal_quintic_hermite(y, dydx, d2ydx2, x0, dx)"},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quintic_hermite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cardinal Quintic Hermite Interpolator — cardinal_quintic_hermite","text":"y Numeric vector ordinates (y-coordinates). dydx Numeric vector first derivatives (slopes) point. d2ydx2 Numeric vector second derivatives point. x0 Numeric value first abscissa (x-coordinate). dx Numeric value spacing abscissas.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quintic_hermite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cardinal Quintic Hermite Interpolator — cardinal_quintic_hermite","text":"object class cardinal_quintic_hermite methods: interpolate(xi): Evaluate interpolator point xi. prime(xi): Evaluate derivative interpolator point xi. double_prime(xi): Evaluate second derivative interpolator point xi. domain(): Get domain interpolator.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/cardinal_quintic_hermite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cardinal Quintic Hermite Interpolator — cardinal_quintic_hermite","text":"","code":"y <- c(0, 1, 0) dydx <- c(1, 0, -1) d2ydx2 <- c(0, -1, 0) x0 <- 0 dx <- 1 interpolator <- cardinal_quintic_hermite(y, dydx, d2ydx2, x0, dx) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.640625 interpolator$prime(xi) #> [1] 1.40625 interpolator$double_prime(xi) #> [1] -1.25 interpolator$domain() #> [1] 0 2"},{"path":"https://andrjohns.github.io/boostmath/reference/catmull_rom.html","id":null,"dir":"Reference","previous_headings":"","what":"Catmull-Rom Interpolation — catmull_rom","title":"Catmull-Rom Interpolation — catmull_rom","text":"Catmull-Rom splines family interpolating curves commonly used computer graphics animation. Properties: enjoy affine invariance, local support, C2-smoothness, interpolation control points. curve internally closed, however user specifies treated open closed via parameters. Evaluation O(log N).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/catmull_rom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Catmull-Rom Interpolation — catmull_rom","text":"","code":"catmull_rom(control_points, closed = FALSE, alpha = 0.5)"},{"path":"https://andrjohns.github.io/boostmath/reference/catmull_rom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Catmull-Rom Interpolation — catmull_rom","text":"control_points List control points, element numeric vector length 3. closed Logical indicating whether spline closed (.e., first last control points connected), defaults false alpha Numeric scalar tension parameter, defaults 0.5","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/catmull_rom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Catmull-Rom Interpolation — catmull_rom","text":"object class catmull_rom methods: interpolate(xi): Evaluate interpolator point xi. prime(xi): Evaluate derivative interpolator point xi. max_parameter(): Get maximum parameter value spline. parameter_at_point(): Get parameter value index .","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/catmull_rom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Catmull-Rom Interpolation — catmull_rom","text":"","code":"control_points <- list(c(0, 0, 0), c(1, 1, 0), c(2, 0, 0), c(3, 1, 0)) interpolator <- catmull_rom(control_points) xi <- 1.5 interpolator$interpolate(xi) #> [1] 1.2613446 0.8307972 0.0000000 interpolator$prime(xi) #> [1]  0.8408964 -1.1363078  0.0000000 interpolator$max_parameter() #> [1] 3.567621 interpolator$parameter_at_point(2) #> [1] 2.378414"},{"path":"https://andrjohns.github.io/boostmath/reference/cauchy_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Cauchy Distribution Functions — cauchy_distribution","title":"Cauchy Distribution Functions — cauchy_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Cauchy distribution. PDF : $$f(x; x_0, \\gamma) = \\frac{1}{\\pi}\\left(\\frac{\\gamma}{(x-x_0)^2 + \\gamma^2}\\right)$$ CDF: $$F(x; x_0, \\gamma) = \\frac{1}{\\pi}\\text{arctan}\\left(\\frac{x-x_0}{\\gamma}\\right)+\\frac{1}{2}$$","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cauchy_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cauchy Distribution Functions — cauchy_distribution","text":"","code":"cauchy_distribution(location = 0, scale = 1)  cauchy_pdf(x, location = 0, scale = 1)  cauchy_lpdf(x, location = 0, scale = 1)  cauchy_cdf(x, location = 0, scale = 1)  cauchy_lcdf(x, location = 0, scale = 1)  cauchy_quantile(p, location = 0, scale = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/cauchy_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cauchy Distribution Functions — cauchy_distribution","text":"location location parameter (default 0) scale scale parameter (default 1) x quantile p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cauchy_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cauchy Distribution Functions — cauchy_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/cauchy_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cauchy Distribution Functions — cauchy_distribution","text":"","code":"# Cauchy distribution with location = 0, scale = 1 dist <- cauchy_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6475836 logcdf(dist, 0.5) #> [1] -0.4345074 pdf(dist, 0.5) #> [1] 0.2546479 logpdf(dist, 0.5) #> [1] -1.367873 hazard(dist, 0.5) #> [1] 0.7225768 chf(dist, 0.5) #> [1] 1.042942 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -1.376382 support(dist) #> [1] -Inf  Inf  # Convenience functions cauchy_pdf(0) #> [1] 0.3183099 cauchy_lpdf(0) #> [1] -1.14473 cauchy_cdf(0) #> [1] 0.5 cauchy_lcdf(0) #> [1] -0.6931472 cauchy_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/reference/chatterjee_correlation.html","id":null,"dir":"Reference","previous_headings":"","what":"Chatterjee Correlation — chatterjee_correlation","title":"Chatterjee Correlation — chatterjee_correlation","text":"Computes Chatterjee correlation coefficient, robust measure dependence. Unlike classical correlation coefficients (Pearson, Spearman), Chatterjee's coefficient measures degree y function x (functional dependence), capturing non-linear relationships. Characteristics: Functional Dependence: Value 1 y measurable function x. Independence: Value 0 x y independent. Range: coefficient theoretically \\([0, 1]\\). Asymmetry: measure asymmetric; \\(C(X, Y) \\neq C(Y, X)\\). specifically tests $Y = f(X)$.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/chatterjee_correlation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chatterjee Correlation — chatterjee_correlation","text":"","code":"chatterjee_correlation(x, y)"},{"path":"https://andrjohns.github.io/boostmath/reference/chatterjee_correlation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chatterjee Correlation — chatterjee_correlation","text":"x numeric vector (predictor/independent variable). y numeric vector (response/dependent variable).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/chatterjee_correlation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chatterjee Correlation — chatterjee_correlation","text":"numeric value representing Chatterjee correlation coefficient. numeric vector containing: Correlation Coefficient: Chatterjee correlation estimate.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/chatterjee_correlation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chatterjee Correlation — chatterjee_correlation","text":"coefficient calculated using ranks y sorted x. implementation computes sample version coefficient described Chatterjee (2021). Formula: Given pairs \\((X_i, Y_i)\\), sort \\(X_{(1)} \\le \\dots \\le X_{(n)}\\). Let \\(r_i\\) rank \\(Y_{()}\\). coefficient : $$ \\xi_n(X, Y) = 1 - \\frac{3 \\sum_{=1}^{n-1} |r_{+1} - r_i|}{n^2 - 1} $$","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/chatterjee_correlation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Chatterjee Correlation — chatterjee_correlation","text":"Chatterjee, S. (2021). new coefficient correlation. Journal American Statistical Association, 116(536), 2009-2022.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/chatterjee_correlation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chatterjee Correlation — chatterjee_correlation","text":"","code":"# Functional dependence (Y = X^2) x <- runif(50, -1, 1) y <- x^2 chatterjee_correlation(x, y) # Should be high (near 1) #> [1] 0.03601441  # Independence x <- runif(50) y <- runif(50) chatterjee_correlation(x, y) # Should be low (near 0) #> [1] -0.05402161  # Asymmetry check chatterjee_correlation(x, y) #> [1] -0.05402161 chatterjee_correlation(y, x) #> [1] -0.03721489"},{"path":"https://andrjohns.github.io/boostmath/reference/chebyshev_polynomials.html","id":null,"dir":"Reference","previous_headings":"","what":"Chebyshev Polynomials and Related Functions — chebyshev_polynomials","title":"Chebyshev Polynomials and Related Functions — chebyshev_polynomials","text":"Functions compute Chebyshev polynomials first second kind, efficiently evaluate Chebyshev series using Clenshaw's recurrence algorithm. Chebyshev polynomials orthogonal polynomials used extensively approximation theory, numerical analysis, spectral methods. minimize Runge phenomenon polynomial interpolation. Chebyshev Polynomials First Kind T_n(x): chebyshev_t(n, x): Evaluates \\(T_n(x)\\) Recurrence relation: \\(T_{n+1}(x) = 2xT_n(x) - T_{n-1}(x)\\) n > 0 Initial conditions: T_0(x) = 1, T_1(x) = x chebyshev_t_prime(n, x): Derivative T_n(x) Stable evaluation x   \\([-1, 1]\\) (mixed forward-backward stable) Chebyshev Polynomials Second Kind U_n(x): chebyshev_u(n, x): Evaluates U_n(x) Related T_n differentiation Recurrence Relation: chebyshev_next(x, Tn, Tn_1): Computes \\(T_{n+1}(x)\\) T_n \\(T_{n-1}\\) Clenshaw's Recurrence Algorithm: Efficient O(n) evaluation Chebyshev series (alternative O(n^2) direct computation): chebyshev_clenshaw_recurrence(c, x): Evaluates Chebyshev series coefficients c point x standard interval \\([-1, 1]\\) chebyshev_clenshaw_recurrence_ab(c, , b, x): Evaluates Chebyshev series arbitrary interval \\([, b]\\) using Reinsch's modification Stability: Evaluation three-term recurrence known mixed forward-backward stable x   \\([-1, 1]\\). Stability outside interval established.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/chebyshev_polynomials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chebyshev Polynomials and Related Functions — chebyshev_polynomials","text":"","code":"chebyshev_next(x, Tn, Tn_1)  chebyshev_t(n, x)  chebyshev_u(n, x)  chebyshev_t_prime(n, x)  chebyshev_clenshaw_recurrence(c, x)  chebyshev_clenshaw_recurrence_ab(c, a, b, x)"},{"path":"https://andrjohns.github.io/boostmath/reference/chebyshev_polynomials.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chebyshev Polynomials and Related Functions — chebyshev_polynomials","text":"x Argument polynomial (typically \\([-1, 1]\\) stability) Tn Value Chebyshev polynomial T_n(x) Tn_1 Value Chebyshev polynomial \\(T_{n-1}(x)\\) n Degree polynomial c Vector coefficients Chebyshev series Lower bound interval (interval transformation) b Upper bound interval (interval transformation)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/chebyshev_polynomials.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chebyshev Polynomials and Related Functions — chebyshev_polynomials","text":"single numeric value computed Chebyshev polynomial series evaluation.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/chebyshev_polynomials.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chebyshev Polynomials and Related Functions — chebyshev_polynomials","text":"","code":"# Chebyshev polynomial of the first kind T_2(0.5) chebyshev_t(2, 0.5) #> [1] -0.5 # Chebyshev polynomial of the second kind U_2(0.5) chebyshev_u(2, 0.5) #> [1] 0 # Derivative of the Chebyshev polynomial of the first kind T_2'(0.5) chebyshev_t_prime(2, 0.5) #> [1] 2 # Next Chebyshev polynomial of the first kind T_3(0.5) using T_2(0.5) and T_1(0.5) chebyshev_next(0.5, chebyshev_t(2, 0.5), chebyshev_t(1, 0.5)) #> [1] -1 # Evaluate Chebyshev series with Clenshaw's algorithm chebyshev_clenshaw_recurrence(c(1, 0, -1), 0.5) #> [1] 1 # Evaluate Chebyshev series on interval [0, 1] chebyshev_clenshaw_recurrence_ab(c(1, 0, -1), 0, 1, 0.5) #> [1] 1.5"},{"path":"https://andrjohns.github.io/boostmath/reference/chi_squared_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Chi-Squared Distribution Functions — chi_squared_distribution","title":"Chi-Squared Distribution Functions — chi_squared_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function, sample-size estimation Chi-Squared distribution. degrees freedom deqn > 0, PDF : $$f(x; \\nu) = \\frac{1}{2^{\\nu/2}\\Gamma(\\nu/2)} x^{\\nu/2 - 1} e^{-x/2}, \\quad x \\ge 0$$ CDF given regularised incomplete gamma function $$F(x;\\nu) = P(\\nu/2, x/2)$$ Accuracy Implementation Notes: CDF quantiles implemented via incomplete gamma functions. Specifically, PDF uses gamma_p_derivative(\\nu/2, x/2)/2, CDF uses gamma_p, complement uses gamma_q, quantiles use gamma_p_inv/gamma_q_inv. Accuracy therefore follows incomplete gamma functions. Sample Size Estimation: chi_squared_find_degrees_of_freedom estimates sample size required detect difference nominal variance. sign difference_from_variance determines whether test higher lower variance.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/chi_squared_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chi-Squared Distribution Functions — chi_squared_distribution","text":"","code":"chi_squared_distribution(df)  chi_squared_pdf(x, df)  chi_squared_lpdf(x, df)  chi_squared_cdf(x, df)  chi_squared_lcdf(x, df)  chi_squared_quantile(p, df)  chi_squared_find_degrees_of_freedom(   difference_from_variance,   alpha,   beta,   variance,   hint = 100 )"},{"path":"https://andrjohns.github.io/boostmath/reference/chi_squared_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chi-Squared Distribution Functions — chi_squared_distribution","text":"df Degrees freedom (df > 0). x Quantile value (x >= 0). p Probability (0 <= p <= 1). difference_from_variance difference assumed nominal variance detected. alpha acceptable probability Type error (false positive). beta acceptable probability Type II error (false negative). variance assumed nominal variance. hint initial guess degrees freedom start search (current sample size good start).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/chi_squared_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chi-Squared Distribution Functions — chi_squared_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/chi_squared_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chi-Squared Distribution Functions — chi_squared_distribution","text":"","code":"# Chi-Squared distribution with 3 degrees of freedom dist <- chi_squared_distribution(3) # Apply generic functions cdf(dist, 0.5) #> [1] 0.08110859 logcdf(dist, 0.5) #> [1] -2.511966 pdf(dist, 0.5) #> [1] 0.2196956 logpdf(dist, 0.5) #> [1] -1.515512 hazard(dist, 0.5) #> [1] 0.2390877 chf(dist, 0.5) #> [1] 0.08458732 mean(dist) #> [1] 3 median(dist) #> [1] 2.365974 mode(dist) #> [1] 1 range(dist) #> [1]   0 Inf quantile(dist, 0.2) #> [1] 1.005174 standard_deviation(dist) #> [1] 2.44949 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 6 skewness(dist) #> [1] 1.632993 kurtosis(dist) #> [1] 7 kurtosis_excess(dist) #> [1] 4  # Convenience functions chi_squared_pdf(2, 3) #> [1] 0.2075537 chi_squared_lpdf(2, 3) #> [1] -1.572365 chi_squared_cdf(2, 3) #> [1] 0.4275933 chi_squared_lcdf(2, 3) #> [1] -0.8495828 chi_squared_quantile(0.5, 3) #> [1] 2.365974  # Find degrees of freedom needed to detect a difference from variance of 2.0 # with alpha = 0.05 and beta = 0.2 when the nominal variance is 5.0 chi_squared_find_degrees_of_freedom(2.0, 0.05, 0.2, 5.0) #> [1] 106.0113"},{"path":"https://andrjohns.github.io/boostmath/reference/condition_numbers.html","id":null,"dir":"Reference","previous_headings":"","what":"Condition Numbers — condition_numbers","title":"Condition Numbers — condition_numbers","text":"Functions compute condition numbers summation operations.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/condition_numbers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Condition Numbers — condition_numbers","text":"","code":"summation_condition_number(x = 0, kahan = TRUE)  evaluation_condition_number(f, x)"},{"path":"https://andrjohns.github.io/boostmath/reference/condition_numbers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Condition Numbers — condition_numbers","text":"x numeric value. kahan logical value indicating whether use Kahan summation. f function compute condition number.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/condition_numbers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Condition Numbers — condition_numbers","text":"summation_condition_number, object methods compute condition number, sum, L1 norm, add subtract values. evaluation_condition_number, numeric value representing condition number function evaluation x.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/condition_numbers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Condition Numbers — condition_numbers","text":"","code":"# Create a summation condition number object scn <- summation_condition_number(kahan = TRUE) # Add some values scn$add(1.0) scn$add(2.0) scn$add(3.0) # Compute sum, condition number, and L1 norm print(scn$sum()) #> [1] 6 print(scn$condition_number()) #> [1] 1 print(scn$l1_norm()) #> [1] 6 # Compute evaluation condition number for a function f <- function(x) { x^2 + 3*x + 2 } print(evaluation_condition_number(f, 1.0)) #> [1] 0.8333333"},{"path":"https://andrjohns.github.io/boostmath/reference/constants.html","id":null,"dir":"Reference","previous_headings":"","what":"Boost Math Constants — constants","title":"Boost Math Constants — constants","text":"Provides access mathematical constants used Boost Math library. available constants include rational fractions, $$\\pi$$-related values, $$e$$-related values, assorted special constants (e.g., Euler-Mascheroni, Catalan). Integer values intentionally omitted since can constructed exactly literals. Accuracy Implementation Notes: constants provided high precision Boost.Math; refer Boost constants table names values.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/constants.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Boost Math Constants — constants","text":"","code":"constants(constant = NULL)"},{"path":"https://andrjohns.github.io/boostmath/reference/constants.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Boost Math Constants — constants","text":"constant string specifying name constant retrieve. NULL, returns list constants (see documentation full list).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/constants.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Boost Math Constants — constants","text":"Requested constant value constant specified, otherwise list available constants.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/constants.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Boost Math Constants — constants","text":"","code":"constants() #> $half #> [1] 0.5 #>  #> $third #> [1] 0.3333333 #>  #> $twothirds #> [1] 0.6666667 #>  #> $two_thirds #> [1] 0.6666667 #>  #> $sixth #> [1] 0.1666667 #>  #> $three_quarters #> [1] 0.75 #>  #> $root_two #> [1] 1.414214 #>  #> $root_three #> [1] 1.732051 #>  #> $half_root_two #> [1] 0.7071068 #>  #> $ln_two #> [1] 0.6931472 #>  #> $ln_ln_two #> [1] -0.3665129 #>  #> $root_ln_four #> [1] 1.17741 #>  #> $one_div_root_two #> [1] 0.7071068 #>  #> $pi #> [1] 3.141593 #>  #> $half_pi #> [1] 1.570796 #>  #> $third_pi #> [1] 1.047198 #>  #> $sixth_pi #> [1] 0.5235988 #>  #> $two_pi #> [1] 6.283185 #>  #> $two_thirds_pi #> [1] 2.094395 #>  #> $three_quarters_pi #> [1] 2.356194 #>  #> $four_thirds_pi #> [1] 4.18879 #>  #> $one_div_two_pi #> [1] 0.1591549 #>  #> $one_div_root_two_pi #> [1] 0.3989423 #>  #> $log_pi #> [1] 1.14473 #>  #> $root_pi #> [1] 1.772454 #>  #> $root_half_pi #> [1] 1.253314 #>  #> $root_two_pi #> [1] 2.506628 #>  #> $log_root_two_pi #> [1] 0.9189385 #>  #> $one_div_root_pi #> [1] 0.5641896 #>  #> $root_one_div_pi #> [1] 0.5641896 #>  #> $pi_minus_three #> [1] 0.1415927 #>  #> $four_minus_pi #> [1] 0.8584073 #>  #> $pi_pow_e #> [1] 22.45916 #>  #> $pi_sqr #> [1] 9.869604 #>  #> $pi_sqr_div_six #> [1] 1.644934 #>  #> $pi_cubed #> [1] 31.00628 #>  #> $cbrt_pi #> [1] 1.464592 #>  #> $one_div_cbrt_pi #> [1] 0.6827841 #>  #> $log2_e #> [1] 1.442695 #>  #> $e #> [1] 2.718282 #>  #> $exp_minus_half #> [1] 0.6065307 #>  #> $exp_minus_one #> [1] 0.3678794 #>  #> $e_pow_pi #> [1] 23.14069 #>  #> $root_e #> [1] 1.648721 #>  #> $log10_e #> [1] 0.4342945 #>  #> $one_div_log10_e #> [1] 2.302585 #>  #> $ln_ten #> [1] 2.302585 #>  #> $degree #> [1] 0.01745329 #>  #> $radian #> [1] 57.29578 #>  #> $sin_one #> [1] 0.841471 #>  #> $cos_one #> [1] 0.5403023 #>  #> $sinh_one #> [1] 1.175201 #>  #> $cosh_one #> [1] 1.543081 #>  #> $phi #> [1] 1.618034 #>  #> $ln_phi #> [1] 0.4812118 #>  #> $one_div_ln_phi #> [1] 2.078087 #>  #> $euler #> [1] 0.5772157 #>  #> $one_div_euler #> [1] 1.732455 #>  #> $euler_sqr #> [1] 0.3331779 #>  #> $zeta_two #> [1] 1.644934 #>  #> $zeta_three #> [1] 1.202057 #>  #> $catalan #> [1] 0.9159656 #>  #> $glaisher #> [1] 1.282427 #>  #> $khinchin #> [1] 2.685452 #>  #> $extreme_value_skewness #> [1] 1.139547 #>  #> $rayleigh_skewness #> [1] 0.6311107 #>  #> $rayleigh_kurtosis #> [1] 3.245089 #>  #> $rayleigh_kurtosis_excess #> [1] 0.2450893 #>  #> $two_div_pi #> [1] 0.6366198 #>  #> $root_two_div_pi #> [1] 0.7978846 #>  #> $quarter_pi #> [1] 0.7853982 #>  #> $one_div_pi #> [1] 0.3183099 #>  #> $two_div_root_pi #> [1] 1.128379 #>  #> $first_feigenbaum #> [1] 4.669202 #>  #> $plastic #> [1] 1.324718 #>  #> $gauss #> [1] 0.8346268 #>  #> $dottie #> [1] 0.7390851 #>  #> $reciprocal_fibonacci #> [1] 3.359886 #>  #> $laplace_limit #> [1] 0.6627434 #>"},{"path":"https://andrjohns.github.io/boostmath/reference/cubic_hermite.html","id":null,"dir":"Reference","previous_headings":"","what":"Cubic Hermite Interpolator — cubic_hermite","title":"Cubic Hermite Interpolator — cubic_hermite","text":"cubic Hermite interpolant takes non-equispaced data interpolates via cubic Hermite polynomials whose slopes must provided. Applications: interpolant C1 evaluation O(log N) complexity. interpolator useful solution skeletons ODE steppers.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cubic_hermite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cubic Hermite Interpolator — cubic_hermite","text":"","code":"cubic_hermite(x, y, dydx)"},{"path":"https://andrjohns.github.io/boostmath/reference/cubic_hermite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cubic Hermite Interpolator — cubic_hermite","text":"x Numeric vector abscissas (x-coordinates). y Numeric vector ordinates (y-coordinates). dydx Numeric vector derivatives (slopes) point.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/cubic_hermite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cubic Hermite Interpolator — cubic_hermite","text":"object class cubic_hermite methods: interpolate(xi): Evaluate interpolator point xi. prime(xi): Evaluate derivative interpolator point xi. push_back(x, y, dydx): Add new control point interpolator. domain(): Get domain interpolator.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/cubic_hermite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cubic Hermite Interpolator — cubic_hermite","text":"","code":"x <- c(0, 1, 2) y <- c(0, 1, 0) dydx <- c(1, 0, -1) interpolator <- cubic_hermite(x, y, dydx) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.625 interpolator$prime(xi) #> [1] 1.25 interpolator$push_back(3, 0, 1) interpolator$domain() #> [1] 0 3"},{"path":"https://andrjohns.github.io/boostmath/reference/double_exponential_quadrature.html","id":null,"dir":"Reference","previous_headings":"","what":"Double Exponential Quadrature — double_exponential_quadrature","title":"Double Exponential Quadrature — double_exponential_quadrature","text":"Numerical integration using double exponential quadrature methods (Tanh-Sinh, Sinh-Sinh, Exp-Sinh). methods use variable transformations achieve high-order convergence, often optimal functions Hardy space (holomorphic unit disk). Tanh-Sinh Quadrature: Best integration finite interval \\((, b)\\). Can handle singularities endpoints integration domain. Converges rapidly holomorphic integrands. Sinh-Sinh Quadrature: Designed integration entire real line \\((-\\infty, \\infty)\\). Handles integrands large features decay properties. Exp-Sinh Quadrature: Designed integration semi-infinite interval, typically \\((0, \\infty)\\), ranges like \\((, \\infty)\\) \\((-\\infty, b)\\). Supports endpoint singularities.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/double_exponential_quadrature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Double Exponential Quadrature — double_exponential_quadrature","text":"","code":"tanh_sinh(f, a, b, tol = sqrt(.Machine$double.eps), max_refinements = 15)  sinh_sinh(f, tol = sqrt(.Machine$double.eps), max_refinements = 9)  exp_sinh(f, a, b, tol = sqrt(.Machine$double.eps), max_refinements = 9)"},{"path":"https://andrjohns.github.io/boostmath/reference/double_exponential_quadrature.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Double Exponential Quadrature — double_exponential_quadrature","text":"f function integrate. accept single numeric value return single numeric value. lower limit integration. b upper limit integration. tol tolerance approximation. Default sqrt(.Machine$double.eps). max_refinements maximum number refinements apply. Default 15 tanh-sinh 9 sinh-sinh exp-sinh.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/double_exponential_quadrature.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Double Exponential Quadrature — double_exponential_quadrature","text":"single numeric value computed integral.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/double_exponential_quadrature.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Double Exponential Quadrature — double_exponential_quadrature","text":"","code":"# Tanh-sinh quadrature of log(x) from 0 to 1 (Endpoint singularity) tanh_sinh(function(x) { log(x) * log1p(-x) }, a = 0, b = 1) #> [1] 0.3550659  # Sinh-sinh quadrature of exp(-x^2) over (-Inf, Inf) sinh_sinh(function(x) { exp(-x * x) }) #> [1] 1.772454  # Exp-sinh quadrature of exp(-3*x) from 0 to Inf exp_sinh(function(x) { exp(-3 * x) }, a = 0, b = Inf) #> [1] 0.3333333"},{"path":"https://andrjohns.github.io/boostmath/reference/elliptic_integrals.html","id":null,"dir":"Reference","previous_headings":"","what":"Elliptic Integrals — elliptic_integrals","title":"Elliptic Integrals — elliptic_integrals","text":"Functions compute various elliptic integrals, including Carlson's elliptic integrals incomplete elliptic integrals. Elliptic Integrals - Carlson Form ellint_rf(x, y, z): Carlson's Elliptic Integral \\(R_F\\) $$R_F(x, y, z) = \\frac{1}{2}\\int_{0}^\\infty[(t+x)(t+y)(t+z)]^{-\\frac{1}{2}}dt$$ ellint_rd(x, y, z): Carlson's Elliptic Integral \\(R_D\\) $$R_D(x, y, z) = \\frac{3}{2}\\int_{0}^\\infty[(t+x)(t+y)]^{-\\frac{1}{2}}(t+z)^{-\\frac{3}{2}}dt$$ ellint_rj(x, y, z, p): Carlson's Elliptic Integral \\(R_J\\) $$R_J(x, y, z) = \\frac{3}{2}\\int_{0}^\\infty(t+p)^{-1}[(t+x)(t+y)(t+z)]^{-\\frac{1}{2}}dt$$ ellint_rc(x, y): Carlson's Elliptic Integral \\(R_C\\) $$R_C(x, y) = \\frac{1}{2}\\int_{0}^\\infty(t+x)^{-\\frac{1}{2}}(t+y)^{-1}dt$$ ellint_rg(x, y, z): Carlson's Elliptic Integral \\(R_G\\) $$R_G(x, y, z) = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\pi}\\sqrt{\\left(x\\sin^2\\theta\\cos^2\\phi+y\\sin^2\\theta\\sin^2\\phi + z\\cos^2\\theta\\right)}\\sin\\theta d\\theta \\phi$$ Elliptic Integrals First Kind - Legendre Form ellint_1(k, phi): Incomplete elliptic integral first kind: \\(F(\\phi, k)\\): $$F(\\phi, k) = \\int_0^{\\phi}\\frac{d\\theta}{\\sqrt{1-k^2\\sin^2\\theta}}d\\theta$$ Elliptic Integrals Second Kind - Legendre Form ellint_2(k, phi): Incomplete elliptic integral second kind: \\(E(\\phi, k)\\): $$E(\\phi, k) = \\int_0^{\\phi}\\sqrt{1-k^2\\sin^2\\theta}d\\theta$$ Elliptic Integrals Third Kind - Legendre Form ellint_3(k, n, phi): Incomplete elliptic integral third kind: \\(\\Pi(n, \\phi, k)\\): $$\\Pi(n, \\phi, k) = \\int_0^{\\phi}\\frac{d\\theta}{\\left(1-n\\sin^2\\theta\\right)\\sqrt{1-k^2\\sin^2\\theta}}d\\theta$$ Elliptic Integral D - Legendre Form ellint_d(k, phi): Incomplete elliptic integral \\(D(\\phi, k)\\): $$D(\\phi, k) = \\frac{(F(\\phi, k) - E(\\phi, k))}{k^2}$$ Jacobi Zeta Function jacobi_zeta(k, phi): Jacobi Zeta function \\(Z(\\phi, k)\\): $$Z(\\phi, k) = E(\\phi, k) - \\frac{E(\\frac{\\pi}{2},k)F(\\phi,k)}{F(\\frac{\\pi}{2}, k)}$$ Heuman Lambda Function heuman_lambda(k, phi): Heuman Lambda function \\(\\Lambda_0(\\phi, k)\\): $$\\Lambda_0(\\phi, k) = \\frac{F(\\phi,\\sqrt{1-k^2})}{F(\\frac{\\pi}{2}, \\sqrt{1-k^2})} + \\frac{2}{\\pi}F(\\frac{\\pi}{2},k)Z(\\phi, \\sqrt{1-k^2})$$","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/elliptic_integrals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Elliptic Integrals — elliptic_integrals","text":"","code":"ellint_rf(x, y, z)  ellint_rd(x, y, z)  ellint_rj(x, y, z, p)  ellint_rc(x, y)  ellint_rg(x, y, z)  ellint_1(k, phi = NULL)  ellint_2(k, phi = NULL)  ellint_3(k, n, phi = NULL)  ellint_d(k, phi = NULL)  jacobi_zeta(k, phi)  heuman_lambda(k, phi)"},{"path":"https://andrjohns.github.io/boostmath/reference/elliptic_integrals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Elliptic Integrals — elliptic_integrals","text":"x First parameter Carlson's integral (must non-negative) y Second parameter Carlson's integral z Third parameter Carlson's integral p Fourth parameter integral (Rj, must non-zero) k Elliptic modulus Legendre-form integrals phi Amplitude (angle) incomplete elliptic integrals n Characteristic elliptic integrals third kind","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/elliptic_integrals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Elliptic Integrals — elliptic_integrals","text":"single numeric value computed elliptic integral.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/elliptic_integrals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Elliptic Integrals — elliptic_integrals","text":"","code":"# Carlson's elliptic integral Rf with parameters x = 1, y = 2, z = 3 ellint_rf(1, 2, 3) #> [1] 0.7269459 # Carlson's elliptic integral Rd with parameters x = 1, y = 2, z = 3 ellint_rd(1, 2, 3) #> [1] 0.2904603 # Carlson's elliptic integral Rj with parameters x = 1, y = 2, z = 3, p = 4 ellint_rj(1, 2, 3, 4) #> [1] 0.2398481 # Carlson's elliptic integral Rc with parameters x = 1, y = 2 ellint_rc(1, 2) #> [1] 0.7853982 # Carlson's elliptic integral Rg with parameters x = 1, y = 2, z = 3 ellint_rg(1, 2, 3) #> [1] 1.401847 # Incomplete elliptic integral of the first kind with k = 0.5, phi = pi/4 ellint_1(0.5, pi / 4) #> [1] 0.8043661 # Complete elliptic integral of the first kind ellint_1(0.5) #> [1] 1.68575 # Incomplete elliptic integral of the second kind with k = 0.5, phi = pi/4 ellint_2(0.5, pi / 4) #> [1] 0.767196 # Complete elliptic integral of the second kind ellint_2(0.5) #> [1] 1.467462 # Incomplete elliptic integral of the third kind with k = 0.5, n = 0.5, phi = pi/4 ellint_3(0.5, 0.5, pi / 4) #> [1] 0.8930657 # Complete elliptic integral of the third kind with k = 0.5, n = 0.5 ellint_3(0.5, 0.5) #> [1] 2.413672 # Incomplete elliptic integral D with k = 0.5, phi = pi/4 ellint_d(0.5, pi / 4) #> [1] 0.1486805 # Complete elliptic integral D ellint_d(0.5) #> [1] 0.8731526 # Jacobi zeta function with k = 0.5, phi = pi/4 jacobi_zeta(0.5, pi / 4) #> [1] 0.06698741 # Heuman's lambda function with k = 0.5, phi = pi/4 heuman_lambda(0.5, pi / 4) #> [1] 0.6632254"},{"path":"https://andrjohns.github.io/boostmath/reference/empirical_cumulative_distribution_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical Cumulative Distribution Function (ECDF) — empirical_cumulative_distribution_function","title":"Empirical Cumulative Distribution Function (ECDF) — empirical_cumulative_distribution_function","text":"Create empirical cumulative distribution function (ECDF) given vector.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/empirical_cumulative_distribution_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical Cumulative Distribution Function (ECDF) — empirical_cumulative_distribution_function","text":"","code":"empirical_cumulative_distribution_function(data, sorted = FALSE)"},{"path":"https://andrjohns.github.io/boostmath/reference/empirical_cumulative_distribution_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical Cumulative Distribution Function (ECDF) — empirical_cumulative_distribution_function","text":"data numeric vector data points. sorted logical indicating whether data already sorted. Default FALSE.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/empirical_cumulative_distribution_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Empirical Cumulative Distribution Function (ECDF) — empirical_cumulative_distribution_function","text":"object representing ECDF, member function $ecdf(x) evaluate ECDF point(s) x.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/empirical_cumulative_distribution_function.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Empirical Cumulative Distribution Function (ECDF) — empirical_cumulative_distribution_function","text":"ECDF step function constructed observed data converges true CDF sample size grows. commonly used goodness--fit workflows compare empirical CDF hypothesised distribution. Implementation Notes: Data must sorted; default constructor sorts $$O(n \\log n)$$ cost. data already sorted, set sorted = TRUE avoid sort. Evaluation uses binary search (upper_bound) runs $$O(\\log n)$$ time.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/empirical_cumulative_distribution_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Empirical Cumulative Distribution Function (ECDF) — empirical_cumulative_distribution_function","text":"","code":"data <- c(1.2, 2.3, 3.1, 4.5, 5.0) ecdf_obj <- empirical_cumulative_distribution_function(data) ecdf_obj$ecdf(3.0)  # Evaluate ECDF at x = 3.0 #> [1] 0.4"},{"path":"https://andrjohns.github.io/boostmath/reference/error_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Error Functions and Inverses — error_functions","title":"Error Functions and Inverses — error_functions","text":"Functions compute error function, complementary error function, inverses. Error functions appear frequently probability, statistics, partial differential equations, particularly study normal distributions diffusion processes. Error Function: error function defined integral: $$erf(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} dt$$ error function odd function (erf(-z) = -erf(z)). Implementation uses rational approximations optimised absolute error, particularly |z| <= 0.5. Complementary Error Function: complementary error function defined : $$erfc(z) = 1 - erf(z) = \\frac{2}{\\sqrt{\\pi}} \\int_z^\\infty e^{-t^2} dt$$ Key reflection formulas: erfc(-z) = 2 - erfc(z) (preferred -z < -0.5) erfc(-z) = 1 + erf(z) (preferred -0.5 <= -z < 0) large z, uses exponential scaling maintain numerical stability. Inverse Functions: erf_inv(p): Returns x p = erf(x), -1 <= p <= 1 erfc_inv(p): Returns x p = erfc(x), 0 <= p <= 2 Inverse functions use rational approximations different formulas different ranges p, achieving accuracy less ~2 epsilon standard precision types.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/error_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Error Functions and Inverses — error_functions","text":"","code":"erf(x)  erfc(x)  erf_inv(p)  erfc_inv(p)"},{"path":"https://andrjohns.github.io/boostmath/reference/error_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Error Functions and Inverses — error_functions","text":"x Input numeric value p Probability value inverse functions","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/error_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Error Functions and Inverses — error_functions","text":"single numeric value computed error function, complementary error function, inverses.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/error_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Error Functions and Inverses — error_functions","text":"","code":"# Error function erf(0.5) #> [1] 0.5204999 # Complementary error function erfc(0.5) #> [1] 0.4795001 # Inverse error function erf_inv(0.5) #> [1] 0.4769363 # Inverse complementary error function erfc_inv(0.5) #> [1] 0.4769363"},{"path":"https://andrjohns.github.io/boostmath/reference/exponential_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential Distribution Functions — exponential_distribution","title":"Exponential Distribution Functions — exponential_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Exponential distribution. rate parameter \\(\\lambda > 0\\), PDF CDF $$f(x; \\lambda) = \\lambda e^{-\\lambda x}, \\quad x \\ge 0$$ $$F(x; \\lambda) = 1 - e^{-\\lambda x}$$ quantile $$F^{-1}(p; \\lambda) = -\\frac{\\log(1-p)}{\\lambda}$$","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/exponential_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential Distribution Functions — exponential_distribution","text":"","code":"exponential_distribution(lambda = 1)  exponential_pdf(x, lambda = 1)  exponential_lpdf(x, lambda = 1)  exponential_cdf(x, lambda = 1)  exponential_lcdf(x, lambda = 1)  exponential_quantile(p, lambda = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/exponential_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential Distribution Functions — exponential_distribution","text":"lambda Rate parameter (lambda > 0). x Quantile value (x >= 0). p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/exponential_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential Distribution Functions — exponential_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/exponential_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential Distribution Functions — exponential_distribution","text":"","code":"# Exponential distribution with rate parameter lambda = 2 dist <- exponential_distribution(2) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6321206 logcdf(dist, 0.5) #> [1] -0.4586751 pdf(dist, 0.5) #> [1] 0.7357589 logpdf(dist, 0.5) #> [1] -0.3068528 hazard(dist, 0.5) #> [1] 2 chf(dist, 0.5) #> [1] 1 mean(dist) #> [1] 0.5 median(dist) #> [1] 0.3465736 mode(dist) #> [1] 0 range(dist) #> [1]   0 Inf quantile(dist, 0.2) #> [1] 0.1115718 standard_deviation(dist) #> [1] 0.5 support(dist) #> [1] 2.225074e-308 1.797693e+308 variance(dist) #> [1] 0.25 skewness(dist) #> [1] 2 kurtosis(dist) #> [1] 9 kurtosis_excess(dist) #> [1] 6  # Convenience functions exponential_pdf(1, 2) #> [1] 0.2706706 exponential_lpdf(1, 2) #> [1] -1.306853 exponential_cdf(1, 2) #> [1] 0.8646647 exponential_lcdf(1, 2) #> [1] -0.1454135 exponential_quantile(0.5, 2) #> [1] 0.3465736"},{"path":"https://andrjohns.github.io/boostmath/reference/exponential_integrals.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential Integrals — exponential_integrals","title":"Exponential Integrals — exponential_integrals","text":"Functions compute various exponential integrals, including En Ei. Exponential Integral En: Defined integral: $$E_n(z) = \\int_1^\\infty \\frac{e^{-zt}}{t^n} dt$$ Exponential Integral Ei: Defined integral: $$Ei(z) = -\\int_{-z}^\\infty \\frac{e^{-t}}{t} dt$$","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/exponential_integrals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential Integrals — exponential_integrals","text":"","code":"expint_en(n, z)  expint_ei(z)"},{"path":"https://andrjohns.github.io/boostmath/reference/exponential_integrals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential Integrals — exponential_integrals","text":"n Order integral (En), must non-negative integer z Argument integral (En Ei)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/exponential_integrals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential Integrals — exponential_integrals","text":"single numeric value computed exponential integral.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/exponential_integrals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential Integrals — exponential_integrals","text":"","code":"# Exponential integral En with n = 1 and z = 2 expint_en(1, 2) #> [1] 0.04890051 # Exponential integral Ei with z = 2 expint_ei(2) #> [1] 4.954234"},{"path":"https://andrjohns.github.io/boostmath/reference/extreme_value_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Extreme Value Distribution Functions — extreme_value_distribution","title":"Extreme Value Distribution Functions — extreme_value_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Extreme Value (Gumbel) distribution. location \\(\\) scale \\(b > 0\\), PDF CDF $$f(x; , b) = \\frac{1}{b}\\exp\\left(\\frac{-x}{b}\\right)\\exp\\left(-\\exp\\left(\\frac{-x}{b}\\right)\\right)$$ $$F(x; , b) = \\exp\\left(-\\exp\\left(\\frac{-x}{b}\\right)\\right)$$ quantile $$F^{-1}(p; , b) = - b\\log\\left(-\\log(p)\\right)$$.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/extreme_value_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extreme Value Distribution Functions — extreme_value_distribution","text":"","code":"extreme_value_distribution(location = 0, scale = 1)  extreme_value_pdf(x, location = 0, scale = 1)  extreme_value_lpdf(x, location = 0, scale = 1)  extreme_value_cdf(x, location = 0, scale = 1)  extreme_value_lcdf(x, location = 0, scale = 1)  extreme_value_quantile(p, location = 0, scale = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/extreme_value_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extreme Value Distribution Functions — extreme_value_distribution","text":"location Location parameter (default 0). scale Scale parameter (default 1). x Quantile value. p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/extreme_value_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extreme Value Distribution Functions — extreme_value_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/extreme_value_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extreme Value Distribution Functions — extreme_value_distribution","text":"","code":"# Extreme Value distribution with location = 0, scale = 1 dist <- extreme_value_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.5452392 logcdf(dist, 0.5) #> [1] -0.6065307 pdf(dist, 0.5) #> [1] 0.3307043 logpdf(dist, 0.5) #> [1] -1.106531 hazard(dist, 0.5) #> [1] 0.727205 chf(dist, 0.5) #> [1] 0.7879837 mean(dist) #> [1] 0.5772157 median(dist) #> [1] 0.3665129 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.475885 standard_deviation(dist) #> [1] 1.28255 support(dist) #> [1] -1.797693e+308  1.797693e+308 variance(dist) #> [1] 1.644934 skewness(dist) #> [1] 1.139547 kurtosis(dist) #> [1] 5.4 kurtosis_excess(dist) #> [1] 2.4  # Convenience functions extreme_value_pdf(0) #> [1] 0.3678794 extreme_value_lpdf(0) #> [1] -1 extreme_value_cdf(0) #> [1] 0.3678794 extreme_value_lcdf(0) #> [1] -1 extreme_value_quantile(0.5) #> [1] 0.3665129"},{"path":"https://andrjohns.github.io/boostmath/reference/factorials_and_binomial_coefficients.html","id":null,"dir":"Reference","previous_headings":"","what":"Factorials and Binomial Coefficients — factorials_and_binomial_coefficients","title":"Factorials and Binomial Coefficients — factorials_and_binomial_coefficients","text":"Functions compute factorials, double factorials, rising falling factorials (Pochhammer symbols), binomial coefficients. fundamental combinatorial functions appear counting problems, probability distributions, series expansions special functions. Factorial Functions: factorial_boost(): Computes \\(! = 1*2*3*...*\\) Standard factorial overflow checking Returns error \\(\\) > max_factorial() unchecked_factorial(): Fast table lookup small factorials overflow checking, assumes \\(\\) valid Use performance critical known small max_factorial(): Returns largest \\(\\) \\(factorial_boost()\\) fits return type without overflow Double Factorial: double_factorial(): Computes \\(!! = *(-2)*(-4)*...\\) even : \\(!! = *(-2)*...*4*2\\) odd : \\(!! = *(-2)*...*3*1\\) Rising Falling Factorials (Pochhammer Symbols): rising_factorial(x, ): Computes \\(x^{()} = x(x+1)(x+2)...(x+-1)\\) Also called Pochhammer symbol ascending factorial Used hypergeometric functions series expansions integer \\(x\\), equals \\((x+-1)! / (x-1)!\\) falling_factorial(x, ): Computes \\((x)_i = x(x-1)(x-2)...(x-+1)\\) Also called descending factorial Counts permutations: number ways arrange items x items integer \\(x\\), \\(equals x! / (x-)!\\) Binomial Coefficients: binomial_coefficient(n, k): Computes \\(C(n,k) = n! / (k!(n-k)!)\\) \"n choose k\": number ways choose \\(k\\) items \\(n\\) items","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/factorials_and_binomial_coefficients.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Factorials and Binomial Coefficients — factorials_and_binomial_coefficients","text":"","code":"factorial_boost(i)  unchecked_factorial(i)  max_factorial()  double_factorial(i)  rising_factorial(x, i)  falling_factorial(x, i)  binomial_coefficient(n, k)"},{"path":"https://andrjohns.github.io/boostmath/reference/factorials_and_binomial_coefficients.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Factorials and Binomial Coefficients — factorials_and_binomial_coefficients","text":"Non-negative integer input factorials double factorials x Base value rising falling factorials (can real-valued) n Total number elements binomial coefficients k Number elements choose binomial coefficients (0 <= k <= n)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/factorials_and_binomial_coefficients.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Factorials and Binomial Coefficients — factorials_and_binomial_coefficients","text":"single numeric value computed factorial, double factorial, rising factorial, falling factorial, binomial coefficient.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/factorials_and_binomial_coefficients.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Factorials and Binomial Coefficients — factorials_and_binomial_coefficients","text":"","code":"# Factorial of 5: 5! = 120 factorial_boost(5) #> [1] 120 # Unchecked factorial of 5 (fast table lookup) unchecked_factorial(5) #> [1] 120 # Maximum factorial value that can be computed max_factorial() #> [1] 170 # Double factorial: 6!! = 6*4*2 = 48 double_factorial(6) #> [1] 48 # Rising factorial: 3^(2) = 3*4 = 12 rising_factorial(3, 2) #> [1] 12 # Falling factorial: 3^[2] = 3*2 = 6 falling_factorial(3, 2) #> [1] 6 # Binomial coefficient: C(5,2) = 10 binomial_coefficient(5, 2) #> [1] 10"},{"path":"https://andrjohns.github.io/boostmath/reference/filters.html","id":null,"dir":"Reference","previous_headings":"","what":"Filters — filters","title":"Filters — filters","text":"Functions compute Daubechies scaling wavelet filter coefficients. returned coefficients correspond compactly supported Daubechies wavelets indexed number vanishing moments $p$, returning $2p$ taps. Conventions: Boost indexes filters vanishing moments (PyWavelets Mathematica), normalizes coefficients unit \\(\\ell_2\\) norm, uses convolutional ordering shown Daubechies (1988). libraries may index number taps, use \\(\\sqrt{2}\\) scaling, reverse coefficient order.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/filters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filters — filters","text":"","code":"daubechies_scaling_filter(order)  daubechies_wavelet_filter(order)"},{"path":"https://andrjohns.github.io/boostmath/reference/filters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filters — filters","text":"order integer specifying number vanishing moments (1 19).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/filters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filters — filters","text":"numeric vector size 2*order containing filter coefficients.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/filters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filters — filters","text":"","code":"# Daubechies Scaling Filter of order 4 daubechies_scaling_filter(4) #> [1]  0.23037781  0.71484657  0.63088077 -0.02798377 -0.18703481  0.03084138 #> [7]  0.03288301 -0.01059740 # Daubechies Wavelet Filter of order 4 daubechies_wavelet_filter(4) #> [1] -0.01059740 -0.03288301  0.03084138  0.18703481 -0.02798377 -0.63088077 #> [7]  0.71484657 -0.23037781"},{"path":"https://andrjohns.github.io/boostmath/reference/fisher_f_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Fisher F Distribution Functions — fisher_f_distribution","title":"Fisher F Distribution Functions — fisher_f_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Fisher F distribution. PDF : $$f(x; \\nu_1, \\nu_2) = \\frac{\\sqrt{\\frac{(\\nu_1 x)^{\\nu_1} \\nu_2^{\\nu_2}}{(\\nu_1 x + \\nu_2)^{\\nu_1 + \\nu_2}}}}{x\\,B(\\nu_1/2, \\nu_2/2)}$$ CDF : $$F(x; \\nu_1, \\nu_2) = I_{\\nu_1 x / (\\nu_1 x + \\nu_2))(\\frac{\\nu_1}{2},\\frac{\\nu_2}{2})}$$ \\(I_{.}(.,.)\\) regularised incomplete beta function","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/fisher_f_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fisher F Distribution Functions — fisher_f_distribution","text":"","code":"fisher_f_distribution(df1, df2)  fisher_f_pdf(x, df1, df2)  fisher_f_lpdf(x, df1, df2)  fisher_f_cdf(x, df1, df2)  fisher_f_lcdf(x, df1, df2)  fisher_f_quantile(p, df1, df2)"},{"path":"https://andrjohns.github.io/boostmath/reference/fisher_f_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fisher F Distribution Functions — fisher_f_distribution","text":"df1 Degrees freedom numerator (df1 > 0). df2 Degrees freedom denominator (df2 > 0). x Quantile value (x >= 0). p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/fisher_f_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fisher F Distribution Functions — fisher_f_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/fisher_f_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fisher F Distribution Functions — fisher_f_distribution","text":"","code":"# Fisher F distribution with df1 = 5, df2 = 10 dist <- fisher_f_distribution(5, 10) # Apply generic functions cdf(dist, 0.5) #> [1] 0.2299751 logcdf(dist, 0.5) #> [1] -1.469784 pdf(dist, 0.5) #> [1] 0.687607 logpdf(dist, 0.5) #> [1] -0.3745378 hazard(dist, 0.5) #> [1] 0.8929673 chf(dist, 0.5) #> [1] 0.2613325 mean(dist) #> [1] 1.25 median(dist) #> [1] 0.9319332 mode(dist) #> [1] 0.5 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.4563364 standard_deviation(dist) #> [1] 1.163687 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 1.354167 skewness(dist) #> [1] 3.86702 kurtosis(dist) #> [1] 53.86154 kurtosis_excess(dist) #> [1] 50.86154  # Convenience functions fisher_f_pdf(1, 5, 10) #> [1] 0.4954798 fisher_f_lpdf(1, 5, 10) #> [1] -0.7022287 fisher_f_cdf(1, 5, 10) #> [1] 0.5348806 fisher_f_lcdf(1, 5, 10) #> [1] -0.6257118 fisher_f_quantile(0.5, 5, 10) #> [1] 0.9319332"},{"path":"https://andrjohns.github.io/boostmath/reference/fp_utilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Floating Point Utilities — fp_utilities","title":"Floating Point Utilities — fp_utilities","text":"Utilities floating-point number manipulation analysis, including adjacent representable values, ULP distances, condition numbers. Floating-Point Navigation: float_next(x) / float_prior(x) move next greater/smaller representable value. float_distance(x, y) returns representation distance ULPs. float_advance(x, n) advances \\(n\\) ULPs. ulp(x) returns size one unit last place x. Comparisons: relative_difference(x, y) epsilon_difference(x, y) provide scale-aware measures deviation. Condition Numbers: summation_condition_number evaluation_condition_number help quantify numerical sensitivity perturbations.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/fp_utilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Floating Point Utilities — fp_utilities","text":"","code":"float_next(x)  float_prior(x)  float_distance(x, y)  float_advance(x, distance)  ulp(x)  relative_difference(x, y)  epsilon_difference(x, y)"},{"path":"https://andrjohns.github.io/boostmath/reference/fp_utilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Floating Point Utilities — fp_utilities","text":"x numeric value. y numeric value. distance Integer number ULPs advance .","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/fp_utilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Floating Point Utilities — fp_utilities","text":"numeric value performing specified floating point operation.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/fp_utilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Floating Point Utilities — fp_utilities","text":"","code":"print(float_next(1.0), digits = 20) #> [1] 1.000000000000000222 print(float_distance(1.0, 2.0), digits = 20) #> [1] 4503599627370496 print(float_prior(1.0), digits = 20) #> [1] 0.99999999999999988898 print(float_advance(1.0, 10), digits = 20) #> [1] 1.0000000000000022204 print(ulp(1.0), digits = 20) #> [1] 2.2204460492503130808e-16 print(relative_difference(1.1, 1.1000009), digits = 20) #> [1] 8.1818181805395140825e-07 print(epsilon_difference(1.1, 1.1000009), digits = 20) #> [1] 3684763330.909090519"},{"path":"https://andrjohns.github.io/boostmath/reference/gamma_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Gamma Distribution Functions — gamma_distribution","title":"Gamma Distribution Functions — gamma_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Gamma distribution. PDF $$f(x; k, \\lambda) = \\frac{1}{\\Gamma(k)\\,\\theta^k} x^{k-1} e^{-x/\\theta}, \\quad x \\ge 0$$ CDF $$F(x; k, \\lambda) = P(k, x/\\theta)$$ \\(P(.,.)\\) regularised incomplete gamma function.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/gamma_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gamma Distribution Functions — gamma_distribution","text":"","code":"gamma_distribution(shape, scale = 1)  gamma_pdf(x, shape, scale = 1)  gamma_lpdf(x, shape, scale = 1)  gamma_cdf(x, shape, scale = 1)  gamma_lcdf(x, shape, scale = 1)  gamma_quantile(p, shape, scale = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/gamma_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gamma Distribution Functions — gamma_distribution","text":"shape Shape parameter (shape > 0). scale Scale parameter (scale > 0). x Quantile value (x >= 0). p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/gamma_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gamma Distribution Functions — gamma_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/gamma_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gamma Distribution Functions — gamma_distribution","text":"","code":"# Gamma distribution with shape = 3, scale = 4 dist <- gamma_distribution(3, 4) # Apply generic functions cdf(dist, 0.5) #> [1] 0.0002964775 logcdf(dist, 0.5) #> [1] -8.123539 pdf(dist, 0.5) #> [1] 0.001723627 logpdf(dist, 0.5) #> [1] -6.363325 hazard(dist, 0.5) #> [1] 0.001724138 chf(dist, 0.5) #> [1] 0.0002965215 mean(dist) #> [1] 12 median(dist) #> [1] 10.69624 mode(dist) #> [1] 8 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 6.140177 standard_deviation(dist) #> [1] 6.928203 support(dist) #> [1] 2.225074e-308 1.797693e+308 variance(dist) #> [1] 48 skewness(dist) #> [1] 1.154701 kurtosis(dist) #> [1] 5 kurtosis_excess(dist) #> [1] 2  # Convenience functions gamma_pdf(2, 3, 4) #> [1] 0.01895408 gamma_lpdf(2, 3, 4) #> [1] -3.965736 gamma_cdf(2, 3, 4) #> [1] 0.01438768 gamma_lcdf(2, 3, 4) #> [1] -4.241383 gamma_quantile(0.5, 3, 4) #> [1] 10.69624"},{"path":"https://andrjohns.github.io/boostmath/reference/gamma_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Gamma Functions — gamma_functions","title":"Gamma Functions — gamma_functions","text":"Functions compute gamma function, logarithm, digamma, trigamma, polygamma, various incomplete gamma functions. Gamma Function Gamma(z): tgamma(z): Computes \\(\\Gamma(z)\\), true gamma function tgamma1pm1(z): Computes \\(\\Gamma(1+z) - 1\\) enhanced numerical stability small z values, avoiding precision loss lgamma_boost(z): Returns \\(\\log(\\Gamma(z))\\), logarithm gamma function Derivative Functions: digamma_boost(z): digamma function, first derivative logarithm Gamma function \\(\\psi(z) = \\frac{d}{dz}\\log\\Gamma(z) = \\frac{\\Gamma'(z)}{\\Gamma(z)}\\), trigamma_boost(z): trigamma function, second derivative logarithm Gamma function \\(\\psi_1(z) = \\frac{d^2}{dz^2}\\log\\Gamma(z)\\) polygamma(n, z): nth derivative digamma function (n-th order polygamma) \\(\\psi^{(m)}(z) = \\frac{d^m}{dz^m}\\psi(z)\\) Ratios: tgamma_ratio(, b): Computes \\(\\Gamma()/\\Gamma(b)\\) tgamma_delta_ratio(, delta): Computes \\(\\Gamma()/\\Gamma(+ \\delta)\\) Incomplete Gamma Functions: functions require > 0 z >= 0. Normalised (Regularised) Functions (return values \\([0, 1]\\)): gamma_p(, z): Normalised lower incomplete gamma \\(P(, z) = \\frac{\\gamma(, z)}{\\Gamma(z)}\\) gamma_q(, z): Normalised upper incomplete gamma \\(Q(, z) = \\frac{\\Gamma(, z)}{\\Gamma()}\\) Non-normalised Functions (return values \\([0, Gamma()]\\)): tgamma_lower(, z): Full lower incomplete gamma function \\(\\gamma(, z) = \\int_{0}^z t^{-1}e^{-t}dt\\) tgamma_upper(, z): Full upper incomplete gamma function \\(\\Gamma(, z) = \\int_{z}^\\Infty t^{-1}e^{-t}dt\\) Inverse Functions: gamma_p_inv(, p): Returns \\(z\\) \\(p = P(, z)\\) gamma_q_inv(, q): Returns \\(z\\) \\(q = Q(, z)\\) gamma_p_inva(z, p): Returns \\(\\) \\(p = P(, z)\\) gamma_q_inva(z, q): Returns \\(\\) \\(q = Q(, z)\\) Derivative: gamma_p_derivative(, z): Computes derivative normalised lower incomplete gamma function respect z: \\(\\frac{\\partial}{\\partial z}P(, z) = \\frac{e^{-z}z^{-1}}{\\Gamma()}\\)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/gamma_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gamma Functions — gamma_functions","text":"","code":"tgamma(z)  tgamma1pm1(z)  lgamma_boost(z)  digamma_boost(z)  trigamma_boost(z)  polygamma(n, z)  tgamma_ratio(a, b)  tgamma_delta_ratio(a, delta)  gamma_p(a, z)  gamma_q(a, z)  tgamma_lower(a, z)  tgamma_upper(a, z)  gamma_q_inv(a, q)  gamma_p_inv(a, p)  gamma_q_inva(z, q)  gamma_p_inva(z, p)  gamma_p_derivative(a, z)"},{"path":"https://andrjohns.github.io/boostmath/reference/gamma_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gamma Functions — gamma_functions","text":"z Input numeric value gamma function n Order polygamma function (non-negative integer) Argument incomplete gamma functions (must positive) b Denominator argument ratio gamma functions delta Increment ratio gamma functions q Probability value incomplete gamma functions (0 <= q <= 1) p Probability value incomplete gamma functions (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/gamma_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gamma Functions — gamma_functions","text":"single numeric value computed gamma function, logarithm, digamma, trigamma, polygamma, incomplete gamma functions.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/gamma_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gamma Functions — gamma_functions","text":"","code":"if (FALSE) { # \\dontrun{ # Gamma function for z = 5 tgamma(5) # Gamma function for (1 + z) - 1, where z = 5 tgamma1pm1(5) # Logarithm of the gamma function for z = 5 lgamma_boost(5) # Digamma function for z = 5 digamma_boost(5) # Trigamma function for z = 5 trigamma_boost(5) # Polygamma function of order 1 for z = 5 polygamma(1, 5) # Ratio of gamma functions for a = 5, b = 3 tgamma_ratio(5, 3) # Ratio of gamma functions with delta for a = 5, delta = 2 tgamma_delta_ratio(5, 2) # Normalised lower incomplete gamma function P(a, z) for a = 5, z = 2 gamma_p(5, 2) # Normalised upper incomplete gamma function Q(a, z) for a = 5, z = 2 gamma_q(5, 2) # Full lower incomplete gamma function for a = 5, z = 2 tgamma_lower(5, 2) # Full upper incomplete gamma function for a = 5, z = 2 tgamma_upper(5, 2) # Inverse of the normalised upper incomplete gamma function for a = 5, q = 0.5 gamma_q_inv(5, 0.5) # Inverse of the normalised lower incomplete gamma function for a = 5, p = 0.5 gamma_p_inv(5, 0.5) # Inverse of the normalised upper incomplete gamma function with respect to a for z = 2, q = 0.5 gamma_q_inva(2, 0.5) # Inverse of the normalised lower incomplete gamma function with respect to a for z = 2, p = 0.5 gamma_p_inva(2, 0.5) # Derivative of the normalised lower incomplete gamma function for a = 5, z = 2 gamma_p_derivative(5, 2) } # }"},{"path":"https://andrjohns.github.io/boostmath/reference/gegenbauer_polynomials.html","id":null,"dir":"Reference","previous_headings":"","what":"Gegenbauer Polynomials and Related Functions — gegenbauer_polynomials","title":"Gegenbauer Polynomials and Related Functions — gegenbauer_polynomials","text":"Functions compute Gegenbauer polynomials, derivatives, related functions.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/gegenbauer_polynomials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gegenbauer Polynomials and Related Functions — gegenbauer_polynomials","text":"","code":"gegenbauer(n, lambda, x)  gegenbauer_prime(n, lambda, x)  gegenbauer_derivative(n, lambda, x, k)"},{"path":"https://andrjohns.github.io/boostmath/reference/gegenbauer_polynomials.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gegenbauer Polynomials and Related Functions — gegenbauer_polynomials","text":"n Degree polynomial lambda Parameter polynomial x Argument polynomial k Order derivative","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/gegenbauer_polynomials.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gegenbauer Polynomials and Related Functions — gegenbauer_polynomials","text":"single numeric value computed Gegenbauer polynomial, derivative, k-th derivative.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/gegenbauer_polynomials.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gegenbauer Polynomials and Related Functions — gegenbauer_polynomials","text":"","code":"# Gegenbauer polynomial C_2^(1)(0.5) gegenbauer(2, 1, 0.5) #> [1] 0 # Derivative of the Gegenbauer polynomial C_2^(1)'(0.5) gegenbauer_prime(2, 1, 0.5) #> [1] 4 # k-th derivative of the Gegenbauer polynomial C_2^(1)''(0.5) gegenbauer_derivative(2, 1, 0.5, 2) #> [1] 8"},{"path":"https://andrjohns.github.io/boostmath/reference/generic_distribution_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic Distribution Functions — generic_distribution_functions","title":"Generic Distribution Functions — generic_distribution_functions","text":"Generic functions computing various properties statistical distributions.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/generic_distribution_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic Distribution Functions — generic_distribution_functions","text":"","code":"cdf(x, ...)  logcdf(x, ...)  pdf(x, ...)  logpdf(x, ...)  hazard(x, ...)  chf(x, ...)  mode(x, ...)  standard_deviation(x, ...)  support(x, ...)  variance(x, ...)  skewness(x, ...)  kurtosis(x, ...)  kurtosis_excess(x, ...)"},{"path":"https://andrjohns.github.io/boostmath/reference/generic_distribution_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic Distribution Functions — generic_distribution_functions","text":"x distribution object created distribution constructor function. ... Additional arguments passed specific methods.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/generic_distribution_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic Distribution Functions — generic_distribution_functions","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile, mean, median, mode, range, standard deviation, support, variance, skewness, kurtosis, excess kurtosis depending function called.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/generic_distribution_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generic Distribution Functions — generic_distribution_functions","text":"","code":"# Create a Weibull distribution weibull_dist <- weibull_distribution(shape = 2, scale = 1) # Compute the CDF at a specific point cdf(weibull_dist, 1) #> [1] 0.6321206 # Check support support(weibull_dist) #> [1] 2.225074e-308 1.797693e+308"},{"path":"https://andrjohns.github.io/boostmath/reference/geometric_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Geometric Distribution Functions — geometric_distribution","title":"Geometric Distribution Functions — geometric_distribution","text":"Functions compute probability mass function (pmf), cumulative distribution function, quantile function, confidence bounds Geometric distribution. geometric distribution models number failures \\(k\\) first success Bernoulli trials success probability \\(p\\). pmf $$P(X = k) = (1-p)^k p, \\quad k \\\\{0,1,2,\\dots\\}$$ Confidence Bounds: bound trial-estimation functions implemented negative binomial distribution (successes = 1), using Clopper-Pearson style bounds numeric inversion.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/geometric_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geometric Distribution Functions — geometric_distribution","text":"","code":"geometric_distribution(prob)  geometric_pdf(x, prob)  geometric_lpdf(x, prob)  geometric_cdf(x, prob)  geometric_lcdf(x, prob)  geometric_quantile(p, prob)  geometric_find_lower_bound_on_p(trials, alpha)  geometric_find_upper_bound_on_p(trials, alpha)  geometric_find_minimum_number_of_trials(failures, prob, alpha)  geometric_find_maximum_number_of_trials(failures, prob, alpha)"},{"path":"https://andrjohns.github.io/boostmath/reference/geometric_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Geometric Distribution Functions — geometric_distribution","text":"prob Probability success (0 < prob < 1). x Quantile value (non-negative integer). p Probability (0 <= p <= 1). trials Number trials. alpha Largest acceptable probability true value success fraction less value returned (geometric_find_lower_bound_on_p) greater value returned (geometric_find_upper_bound_on_p). failures Number failures.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/geometric_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Geometric Distribution Functions — geometric_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/geometric_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Geometric Distribution Functions — geometric_distribution","text":"","code":"# Geometric distribution with probability of success prob = 0.5 dist <- geometric_distribution(0.5) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6464466 logcdf(dist, 0.5) #> [1] -0.4362647 pdf(dist, 0.5) #> [1] 0.3535534 logpdf(dist, 0.5) #> [1] -1.039721 hazard(dist, 0.5) #> [1] 1 chf(dist, 0.5) #> [1] 1.039721 mean(dist) #> [1] 1 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0 standard_deviation(dist) #> [1] 1.414214 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 2 skewness(dist) #> [1] 2.12132 kurtosis(dist) #> [1] 9.5 kurtosis_excess(dist) #> [1] 6.5  # Convenience functions geometric_pdf(3, 0.5) #> [1] 0.0625 geometric_lpdf(3, 0.5) #> [1] -2.772589 geometric_cdf(3, 0.5) #> [1] 0.9375 geometric_lcdf(3, 0.5) #> [1] -0.06453852 geometric_quantile(0.5, 0.5) #> [1] 0 if (FALSE) { # \\dontrun{ # Find lower bound on p given 5 trials with 95% confidence geometric_find_lower_bound_on_p(5, 0.05) # Find upper bound on p given 5 trials with 95% confidence geometric_find_upper_bound_on_p(5, 0.05) # Find minimum number of trials to observe 3 failures with p = 0.5 at 95% confidence geometric_find_minimum_number_of_trials(3, 0.5, 0.05) # Find maximum number of trials to observe 3 failures with p = 0.5 at 95% confidence geometric_find_maximum_number_of_trials(3, 0.5, 0.05) } # }"},{"path":"https://andrjohns.github.io/boostmath/reference/hankel_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Hankel Functions — hankel_functions","title":"Hankel Functions — hankel_functions","text":"Functions compute cylindrical spherical Hankel functions first second kinds. Hankel functions complex-valued combinations Bessel functions particularly useful solving wave equations problems involving cylindrical spherical symmetry. Cylindrical Hankel Functions: First Kind: $$H_v^{(1)}(x) = J_v(x) + Y_v(x)$$ J_v Bessel function first kind Y_v Bessel function second kind. Second Kind: $$H_v^{(2)}(x) = J_v(x) - Y_v(x)$$ functions return complex-valued results. Computing single Hankel function call efficient making separate calls Bessel J Y functions, since components calculated simultaneously. Spherical Hankel Functions: Spherical variants h_v^(1) h_v^(2) implemented terms cylindrical Hankel functions used problems spherical symmetry, electromagnetic wave propagation. functions operate across entire range v x values return complex numbers.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/hankel_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hankel Functions — hankel_functions","text":"","code":"cyl_hankel_1(v, x)  cyl_hankel_2(v, x)  sph_hankel_1(v, x)  sph_hankel_2(v, x)"},{"path":"https://andrjohns.github.io/boostmath/reference/hankel_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hankel Functions — hankel_functions","text":"v Order Hankel function (can real number) x Argument Hankel function (can real number)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/hankel_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hankel Functions — hankel_functions","text":"single complex value computed Hankel function.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/hankel_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hankel Functions — hankel_functions","text":"","code":"cyl_hankel_1(2, 0.5) #> [1] 0.03060402-5.441371i cyl_hankel_2(2, 0.5) #> [1] 0.03060402+5.441371i sph_hankel_1(2, 0.5) #> [1] 0.01637111-25.05992i sph_hankel_2(2, 0.5) #> [1] 0.01637111+25.05992i"},{"path":"https://andrjohns.github.io/boostmath/reference/hermite_polynomials.html","id":null,"dir":"Reference","previous_headings":"","what":"Hermite Polynomials and Related Functions — hermite_polynomials","title":"Hermite Polynomials and Related Functions — hermite_polynomials","text":"Functions compute Hermite polynomials using three-term recurrence relations. Hermite polynomials orthogonal polynomials appear probability theory (derivatives Gaussian function), quantum mechanics (quantum harmonic oscillator), numerical analysis. Hermite Polynomials H_n(x): hermite(n, x): Evaluates Hermite polynomial degree n point x Orthogonal respect weight function $$e^{-x^2}$$ (-Inf, Inf) Appear eigenfunctions quantum harmonic oscillator Recurrence Relation: hermite_next(n, x, Hn, Hnm1): Computes $$H_{n+1}(x)$$ H_n $$H_{n-1}$$ Uses stable three-term recurrence sequential computation Implementation Notes: Guarantees low absolute error low relative error near polynomial roots Values greater ~120 n unlikely produce sensible results Relative errors may grow arbitrarily large function close root","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/hermite_polynomials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hermite Polynomials and Related Functions — hermite_polynomials","text":"","code":"hermite(n, x)  hermite_next(n, x, Hn, Hnm1)"},{"path":"https://andrjohns.github.io/boostmath/reference/hermite_polynomials.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hermite Polynomials and Related Functions — hermite_polynomials","text":"n Degree polynomial (practical limit ~120) x Argument polynomial Hn Value Hermite polynomial H_n(x) Hnm1 Value Hermite polynomial $$H_{n-1}(x)$$","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/hermite_polynomials.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hermite Polynomials and Related Functions — hermite_polynomials","text":"single numeric value computed Hermite polynomial.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/hermite_polynomials.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hermite Polynomials and Related Functions — hermite_polynomials","text":"","code":"# Hermite polynomial H_2(0.5) hermite(2, 0.5) #> [1] -1 # Next Hermite polynomial H_3(0.5) using H_2(0.5) and H_1(0.5) hermite_next(2, 0.5, hermite(2, 0.5), hermite(1, 0.5)) #> [1] -5"},{"path":"https://andrjohns.github.io/boostmath/reference/holtsmark_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Holtsmark Distribution Functions — holtsmark_distribution","title":"Holtsmark Distribution Functions — holtsmark_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Holtsmark distribution. Holtsmark distribution stable distribution stability parameter $$\\alpha = 3/2$$ symmetry parameter $$\\beta = 0$$, commonly used astrophysics. parameterised location $$\\mu$$ scale $c$. common integral representation PDF $$f(x) = \\frac{1}{\\pi}\\int_0^\\infty \\cos\\left(t(x-\\mu)\\right)\\,\\exp\\left(-(c t)^{3/2}\\right)\\,dt.$$ Accuracy Implementation Notes: Boost reports errors within 4 epsilon PDF/CDF-complement double precision. moments (e.g., skewness kurtosis) mathematically undefined raise errors requested.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/holtsmark_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Holtsmark Distribution Functions — holtsmark_distribution","text":"","code":"holtsmark_distribution(location = 0, scale = 1)  holtsmark_pdf(x, location = 0, scale = 1)  holtsmark_lpdf(x, location = 0, scale = 1)  holtsmark_cdf(x, location = 0, scale = 1)  holtsmark_lcdf(x, location = 0, scale = 1)  holtsmark_quantile(p, location = 0, scale = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/holtsmark_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Holtsmark Distribution Functions — holtsmark_distribution","text":"location Location parameter (default 0). scale Scale parameter (default 1). x Quantile value. p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/holtsmark_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Holtsmark Distribution Functions — holtsmark_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/holtsmark_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Holtsmark Distribution Functions — holtsmark_distribution","text":"","code":"# Holtsmark distribution with location 0 and scale 1 dist <- holtsmark_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6394042 logcdf(dist, 0.5) #> [1] -0.4472184 pdf(dist, 0.5) #> [1] 0.2622968 logpdf(dist, 0.5) #> [1] -1.338278 hazard(dist, 0.5) #> [1] 0.7273985 chf(dist, 0.5) #> [1] 1.019998 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -1.234616 standard_deviation(dist) #> [1] Inf support(dist) #> [1] -Inf  Inf variance(dist) #> [1] Inf  # Convenience functions holtsmark_pdf(3) #> [1] 0.03150942 holtsmark_lpdf(3) #> [1] -3.457469 holtsmark_cdf(3) #> [1] 0.9484022 holtsmark_lcdf(3) #> [1] -0.05297661 holtsmark_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/reference/hyperexponential_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Hyperexponential Distribution Functions — hyperexponential_distribution","title":"Hyperexponential Distribution Functions — hyperexponential_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Hyperexponential distribution. $k$-phase hyperexponential distribution mixture $k$ exponential distributions phase probabilities $$\\alpha_i$$ rates $$\\lambda_i$$. PDF CDF $$f(x) = \\sum_{=1}^k \\alpha_i \\lambda_i e^{-\\lambda_i x}$$ $$F(x) = 1 - \\sum_{=1}^k \\alpha_i e^{-\\lambda_i x}, \\quad x \\ge 0$$. Accuracy Implementation Notes: Implemented terms exponential distribution, accurate within machine epsilons. Quantiles closed form computed numerically.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/hyperexponential_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hyperexponential Distribution Functions — hyperexponential_distribution","text":"","code":"hyperexponential_distribution(probabilities, rates)  hyperexponential_pdf(x, probabilities, rates)  hyperexponential_lpdf(x, probabilities, rates)  hyperexponential_cdf(x, probabilities, rates)  hyperexponential_lcdf(x, probabilities, rates)  hyperexponential_quantile(p, probabilities, rates)"},{"path":"https://andrjohns.github.io/boostmath/reference/hyperexponential_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hyperexponential Distribution Functions — hyperexponential_distribution","text":"probabilities Vector non-negative probabilities (normalised sum 1). rates Vector positive rates (rates must > 0). x Quantile value (x >= 0). p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/hyperexponential_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hyperexponential Distribution Functions — hyperexponential_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/hyperexponential_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hyperexponential Distribution Functions — hyperexponential_distribution","text":"","code":"# Hyperexponential distribution with probabilities = c(0.5, 0.5) and rates = c(1, 2) dist <- hyperexponential_distribution(c(0.5, 0.5), c(1, 2)) # Apply generic functions cdf(dist, 0.5) #> [1] 0.5127949 logcdf(dist, 0.5) #> [1] -0.6678792 pdf(dist, 0.5) #> [1] 0.6711448 logpdf(dist, 0.5) #> [1] -0.3987704 hazard(dist, 0.5) #> [1] 1.377541 chf(dist, 0.5) #> [1] 0.7190702 mean(dist) #> [1] 0.75 median(dist) #> [1] 0.4812118 mode(dist) #> [1] 0 range(dist) #> [1]   0 Inf quantile(dist, 0.2) #> [1] 0.1506519 standard_deviation(dist) #> [1] 0.8291562 support(dist) #> [1] 2.225074e-308 1.797693e+308 variance(dist) #> [1] 0.6875 skewness(dist) #> [1] 2.466911 kurtosis(dist) #> [1] 12.47107 kurtosis_excess(dist) #> [1] 9.471074  # Convenience functions hyperexponential_pdf(2, c(0.5, 0.5), c(1, 2)) #> [1] 0.08598328 hyperexponential_lpdf(2, c(0.5, 0.5), c(1, 2)) #> [1] -2.453602 hyperexponential_cdf(2, c(0.5, 0.5), c(1, 2)) #> [1] 0.9231745 hyperexponential_lcdf(2, c(0.5, 0.5), c(1, 2)) #> [1] -0.07993696 hyperexponential_quantile(0.5, c(0.5, 0.5), c(1, 2)) #> [1] 0.4812118"},{"path":"https://andrjohns.github.io/boostmath/reference/hypergeometric_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Hypergeometric Distribution Functions — hypergeometric_distribution","title":"Hypergeometric Distribution Functions — hypergeometric_distribution","text":"Functions compute probability mass function (pmf), cumulative distribution function, quantile function Hypergeometric distribution. population size $N$ $r$ successes $N-r$ failures, drawing $n$ items without replacement, probability observing $k$ successes $$P(X = k) = \\frac{\\binom{r}{k}\\binom{N-r}{n-k}}{\\binom{N}{n}}$$ support \\(k \\[\\max(0, n + r - N), \\min(n, r)]\\). Accuracy Implementation Notes: small $N$, factorial table lookup provides high accuracy. larger $N$ largest stored prime, prime-factorization method used. large $N$, accuracy degrades roughly $$\\log_{10}(N)$$ digits. CDF computed summing PDFs using recurrence relations, quantiles obtained summing tail. strictly discrete distribution, quantiles rounded outward ensure coverage.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/hypergeometric_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hypergeometric Distribution Functions — hypergeometric_distribution","text":"","code":"hypergeometric_distribution(r, n, N)  hypergeometric_pdf(x, r, n, N)  hypergeometric_lpdf(x, r, n, N)  hypergeometric_cdf(x, r, n, N)  hypergeometric_lcdf(x, r, n, N)  hypergeometric_quantile(p, r, n, N)"},{"path":"https://andrjohns.github.io/boostmath/reference/hypergeometric_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hypergeometric Distribution Functions — hypergeometric_distribution","text":"r Number successes population (r >= 0). n Number draws (n >= 0). N Population size (N >= r). x Quantile value (non-negative integer). p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/hypergeometric_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hypergeometric Distribution Functions — hypergeometric_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/hypergeometric_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hypergeometric Distribution Functions — hypergeometric_distribution","text":"","code":"# Hypergeometric distribution with r = 5, n = 10, N = 20 dist <- hypergeometric_distribution(5, 10, 20) # Apply generic functions cdf(dist, 4) #> [1] 0.9837461 logcdf(dist, 4) #> [1] -0.01638741 pdf(dist, 4) #> [1] 0.1354489 logpdf(dist, 4) #> [1] -1.999161 hazard(dist, 4) #> [1] 8.333333 chf(dist, 4) #> [1] 4.119424 mean(dist) #> [1] 2.5 median(dist) #> [1] 3 mode(dist) #> [1] 3 range(dist) #> [1] 0 5 quantile(dist, 0.2) #> [1] 1 standard_deviation(dist) #> [1] 0.9933993 support(dist) #> [1] 0 5 variance(dist) #> [1] 0.9868421 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 5.756863 kurtosis_excess(dist) #> [1] 2.756863  # Convenience functions hypergeometric_pdf(3, 5, 10, 20) #> [1] 0.3482972 hypergeometric_lpdf(3, 5, 10, 20) #> [1] -1.054699 hypergeometric_cdf(3, 5, 10, 20) #> [1] 0.8482972 hypergeometric_lcdf(3, 5, 10, 20) #> [1] -0.1645242 hypergeometric_quantile(0.5, 5, 10, 20) #> [1] 3"},{"path":"https://andrjohns.github.io/boostmath/reference/hypergeometric_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Hypergeometric Functions — hypergeometric_functions","title":"Hypergeometric Functions — hypergeometric_functions","text":"Functions compute various hypergeometric functions, solutions hypergeometric differential equations generalize many special functions. Hypergeometric functions defined series expansions ()_n denotes rising factorial (Pochhammer symbol). appear solutions many differential equations unify numerous special functions. Specific Hypergeometric Functions: 0F1(b, z): hypergeometric_0F1(b, z): Zero numerator parameters, one denominator parameter Implemented via defining series convergent, continued fractions divergent cases, Bessel function relations Domain error b integer <= 0 1F0(, z): hypergeometric_1F0(, z): One numerator parameter, zero denominator parameters 2F0(a1, a2, z): hypergeometric_2F0(a1, a2, z): Two numerator parameters, zero denominator parameters 1F1(, b, z): Confluent hypergeometric function (Kummer's function) hypergeometric_1F1(, b, z): Standard form, solves Kummer's equation Equivalent Mathematica's Hypergeometric1F1[, b, z] Maple's KummerM(, b, z) |z| < 1, convergent hypergeometric series expansion Regularised 1F1: hypergeometric_1F1_regularized(, b, z): Normalised version avoids spurious overflow/underflow Logarithmic 1F1: log_hypergeometric_1F1(, b, z): Returns log 1F1 numerical stability Generalised Hypergeometric Function pFq: hypergeometric_pFq(, b, z): General form p numerator parameters q denominator parameters : vector upper (numerator) parameters b: vector lower (denominator) parameters Uses direct summation series optimizations Example: pFq = (2,3,4) b = (5,6,7,8) computes 3F4 Implementation: 1F1 function uses multiple computational methods including direct series, Kummer's relation, asymptotic expansions, Tricomi's approximation, Luke's rational approximation, recurrence relations, selected based parameter ranges optimal accuracy efficiency.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/hypergeometric_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hypergeometric Functions — hypergeometric_functions","text":"","code":"hypergeometric_1F0(a, z)  hypergeometric_0F1(b, z)  hypergeometric_2F0(a1, a2, z)  hypergeometric_1F1(a, b, z)  hypergeometric_1F1_regularized(a, b, z)  log_hypergeometric_1F1(a, b, z)  hypergeometric_pFq(a, b, z)"},{"path":"https://andrjohns.github.io/boostmath/reference/hypergeometric_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hypergeometric Functions — hypergeometric_functions","text":"Parameter hypergeometric function (numerator parameter) z Argument hypergeometric function b Denominator parameter hypergeometric function a1 First numerator parameter (2F0) a2 Second numerator parameter (2F0)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/hypergeometric_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hypergeometric Functions — hypergeometric_functions","text":"single numeric value computed hypergeometric function.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/hypergeometric_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hypergeometric Functions — hypergeometric_functions","text":"","code":"# Hypergeometric Function 1F0 hypergeometric_1F0(2, 0.2) #> [1] 1.5625 # Hypergeometric Function 0F1 hypergeometric_0F1(1, 0.8) #> [1] 1.974957 # Hypergeometric Function 2F0 hypergeometric_2F0(0.1, -1, 0.1) #> [1] 0.99 # Hypergeometric Function 1F1 (Kummer's function) hypergeometric_1F1(2, 3, 1) #> [1] 2 # Regularised Hypergeometric Function 1F1 hypergeometric_1F1_regularized(2, 3, 1) #> [1] 1 # Logarithm of the Hypergeometric Function 1F1 log_hypergeometric_1F1(2, 3, 1) #> [1] 0.6931472 #> attr(,\"sign\") #> [1] 1 # Generalised Hypergeometric Function pFq (3F4 example) hypergeometric_pFq(c(2, 3, 4), c(5, 6, 7, 8), 0.5) #> [1] 1.007178"},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_chi_squared_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverse Chi-Squared Distribution Functions — inverse_chi_squared_distribution","title":"Inverse Chi-Squared Distribution Functions — inverse_chi_squared_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Inverse Chi-Squared distribution. degrees freedom $$\\nu$$ scale $$\\xi$$, PDF $$f(x;\\nu,\\xi) = \\frac{(\\nu\\xi/2)^{\\nu/2}}{\\Gamma(\\nu/2)} x^{-1-\\nu/2} \\exp\\left(-\\frac{\\nu\\xi}{2x}\\right)$$ CDF $$F(x)=\\Gamma(\\nu/2,\\nu\\xi/2x)/\\Gamma(\\nu/2)$$. unscaled case corresponds $$\\xi = 1/\\nu$$. Accuracy Implementation Notes: Implemented via incomplete gamma functions (gamma_p, gamma_q) inverses. Results typically accurate epsilons double precision. Moments mean/variance/skewness defined sufficiently large $$\\nu$$.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_chi_squared_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverse Chi-Squared Distribution Functions — inverse_chi_squared_distribution","text":"","code":"inverse_chi_squared_distribution(df = 1, scale = 1/df)  inverse_chi_squared_pdf(x, df = 1, scale = 1/df)  inverse_chi_squared_lpdf(x, df = 1, scale = 1/df)  inverse_chi_squared_cdf(x, df = 1, scale = 1/df)  inverse_chi_squared_lcdf(x, df = 1, scale = 1/df)  inverse_chi_squared_quantile(p, df = 1, scale = 1/df)"},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_chi_squared_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverse Chi-Squared Distribution Functions — inverse_chi_squared_distribution","text":"df Degrees freedom (df > 0; default 1). scale Scale parameter (default 1/df). x Quantile value (x >= 0). p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_chi_squared_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inverse Chi-Squared Distribution Functions — inverse_chi_squared_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_chi_squared_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inverse Chi-Squared Distribution Functions — inverse_chi_squared_distribution","text":"","code":"# Inverse Chi-Squared distribution with 10 degrees of freedom, scale = 1 dist <- inverse_chi_squared_distribution(10, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.02925269 logcdf(dist, 0.5) #> [1] -3.531784 pdf(dist, 0.5) #> [1] 0.3783327 logpdf(dist, 0.5) #> [1] -0.9719812 hazard(dist, 0.5) #> [1] 0.3897335 chf(dist, 0.5) #> [1] 0.02968908 mean(dist) #> [1] 1.25 median(dist) #> [1] 1.070455 mode(dist) #> [1] 0.8333333 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.7439393 standard_deviation(dist) #> [1] 0.7216878 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 0.5208333 skewness(dist) #> [1] 3.464102 kurtosis(dist) #> [1] 45 kurtosis_excess(dist) #> [1] 42  # Convenience functions inverse_chi_squared_pdf(2, 10, 1) #> [1] 0.1670024 inverse_chi_squared_lpdf(2, 10, 1) #> [1] -1.789747 inverse_chi_squared_cdf(2, 10, 1) #> [1] 0.891178 inverse_chi_squared_lcdf(2, 10, 1) #> [1] -0.1152111 inverse_chi_squared_quantile(0.5, 10, 1) #> [1] 1.070455"},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_gamma_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverse Gamma Distribution Functions — inverse_gamma_distribution","title":"Inverse Gamma Distribution Functions — inverse_gamma_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Inverse Gamma distribution. shape $$\\alpha$$ scale $$\\beta$$, PDF $$f(x;\\alpha,\\beta) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} x^{-\\alpha-1} \\exp\\left(-\\frac{\\beta}{x}\\right)$$ CDF $$F(x)=\\Gamma(\\alpha,\\beta/x)/\\Gamma(\\alpha)$$. Accuracy Implementation Notes: Implemented via incomplete gamma functions (gamma_p, gamma_q) inverses. logpdf specialised numerical accuracy. Results typically accurate epsilons double precision.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_gamma_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverse Gamma Distribution Functions — inverse_gamma_distribution","text":"","code":"inverse_gamma_distribution(shape, scale = 1)  inverse_gamma_pdf(x, shape, scale = 1)  inverse_gamma_lpdf(x, shape, scale = 1)  inverse_gamma_cdf(x, shape, scale = 1)  inverse_gamma_lcdf(x, shape, scale = 1)  inverse_gamma_quantile(p, shape, scale = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_gamma_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverse Gamma Distribution Functions — inverse_gamma_distribution","text":"shape Shape parameter (shape > 0). scale Scale parameter (scale > 0; default 1). x Quantile value (x >= 0). p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_gamma_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inverse Gamma Distribution Functions — inverse_gamma_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_gamma_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inverse Gamma Distribution Functions — inverse_gamma_distribution","text":"","code":"# Inverse Gamma distribution with shape = 5, scale = 4 dist <- inverse_gamma_distribution(5, 4) # Apply generic functions cdf(dist, 0.5) #> [1] 0.0996324 logcdf(dist, 0.5) #> [1] -2.306268 pdf(dist, 0.5) #> [1] 0.9160366 logpdf(dist, 0.5) #> [1] -0.08769894 hazard(dist, 0.5) #> [1] 1.017403 chf(dist, 0.5) #> [1] 0.1049522 mean(dist) #> [1] 1 median(dist) #> [1] 0.8563644 mode(dist) #> [1] 0.6666667 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.5951514 standard_deviation(dist) #> [1] 0.5773503 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 0.3333333 skewness(dist) #> [1] 3.464102 kurtosis(dist) #> [1] 45 kurtosis_excess(dist) #> [1] 42  # Convenience functions inverse_gamma_pdf(2, 5, 4) #> [1] 0.09022352 inverse_gamma_lpdf(2, 5, 4) #> [1] -2.405465 inverse_gamma_cdf(2, 5, 4) #> [1] 0.947347 inverse_gamma_lcdf(2, 5, 4) #> [1] -0.05408985 inverse_gamma_quantile(0.5, 5, 4) #> [1] 0.8563644"},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_gaussian_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverse Gaussian Distribution Functions — inverse_gaussian_distribution","title":"Inverse Gaussian Distribution Functions — inverse_gaussian_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Inverse Gaussian (Inverse Normal) distribution. mean $$\\mu$$ scale $$\\lambda$$, PDF $$f(x;\\mu,\\lambda) = \\sqrt{\\frac{\\lambda}{2\\pi x^3}}\\exp\\left(-\\frac{\\lambda(x-\\mu)^2}{2\\mu^2 x}\\right)$$ CDF $$F(x) = \\Phi\\left(\\sqrt{\\frac{\\lambda}{x}}\\left(\\frac{x}{\\mu}-1\\right)\\right) + \\exp\\left(\\frac{2\\lambda}{\\mu}\\right)\\Phi\\left(-\\sqrt{\\frac{\\lambda}{x}}\\left(\\frac{x}{\\mu}+1\\right)\\right)$$ $$\\Phi$$ standard normal CDF. Accuracy Implementation Notes: Implemented using standard normal distribution exponential function. logpdf specialised numerical accuracy. Quantiles closed form computed via Newton-Raphson refinement.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_gaussian_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverse Gaussian Distribution Functions — inverse_gaussian_distribution","text":"","code":"inverse_gaussian_distribution(mu = 1, lambda = 1)  inverse_gaussian_pdf(x, mu = 1, lambda = 1)  inverse_gaussian_lpdf(x, mu = 1, lambda = 1)  inverse_gaussian_cdf(x, mu = 1, lambda = 1)  inverse_gaussian_lcdf(x, mu = 1, lambda = 1)  inverse_gaussian_quantile(p, mu = 1, lambda = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_gaussian_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverse Gaussian Distribution Functions — inverse_gaussian_distribution","text":"mu Mean parameter (mu > 0; default 1). lambda Scale parameter (lambda > 0; default 1). x Quantile value (x >= 0). p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_gaussian_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inverse Gaussian Distribution Functions — inverse_gaussian_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_gaussian_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inverse Gaussian Distribution Functions — inverse_gaussian_distribution","text":"","code":"# Inverse Gaussian distribution with mu = 3, lambda = 4 dist <- inverse_gaussian_distribution(3, 4) # Apply generic functions cdf(dist, 0.5) #> [1] 0.01617264 logcdf(dist, 0.5) #> [1] -4.124435 pdf(dist, 0.5) #> [1] 0.1403174 logpdf(dist, 0.5) #> [1] -1.963848 hazard(dist, 0.5) #> [1] 0.142624 chf(dist, 0.5) #> [1] 0.01630484 mean(dist) #> [1] 3 median(dist) #> [1] 2.202698 mode(dist) #> [1] 1.140598 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 1.161488 standard_deviation(dist) #> [1] 2.598076 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 6.75 skewness(dist) #> [1] 2.598076 kurtosis(dist) #> [1] 8.25 kurtosis_excess(dist) #> [1] 11.25  # Convenience functions inverse_gaussian_pdf(2, 3, 4) #> [1] 0.2524295 inverse_gaussian_lpdf(2, 3, 4) #> [1] -1.376623 inverse_gaussian_cdf(2, 3, 4) #> [1] 0.4512408 inverse_gaussian_lcdf(2, 3, 4) #> [1] -0.7957542 inverse_gaussian_quantile(0.5, 3, 4) #> [1] 2.202698"},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_hyperbolic_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverse Hyperbolic Functions — inverse_hyperbolic_functions","title":"Inverse Hyperbolic Functions — inverse_hyperbolic_functions","text":"Functions compute inverse hyperbolic functions high precision proper handling edge cases. Inverse hyperbolic functions inverses hyperbolic functions appear calculus, special relativity, solutions differential equations. Inverse Hyperbolic Cosine: acosh_boost(x): Computes arccosh(x) = cosh^-^1(x) Mathematical definition: acosh(x) = log(x + sqrt(x^2 - 1)) Domain: x >= 1 Range: [0, Inf) Identity: cosh(acosh(x)) = x x >= 1 Derivative: d/dx acosh(x) = 1/sqrt(x^2 - 1) Inverse Hyperbolic Sine: asinh_boost(x): Computes arcsinh(x) = sinh^-^1(x) Mathematical definition: asinh(x) = log(x + sqrt(x^2 + 1)) Domain: (-Inf, Inf) Range: (-Inf, Inf) Odd function: asinh(-x) = -asinh(x) Identity: sinh(asinh(x)) = x x Derivative: d/dx asinh(x) = 1/sqrt(x^2 + 1) Inverse Hyperbolic Tangent: atanh_boost(x): Computes arctanh(x) = tanh^-^1(x) Mathematical definition: atanh(x) = (1/2)log((1 + x)/(1 - x)) Domain: (-1, 1) Range: (-Inf, Inf) Odd function: atanh(-x) = -atanh(x) Identity: tanh(atanh(x)) = x |x| < 1 Derivative: d/dx atanh(x) = 1/(1 - x^2) Special values: atanh(0) = 0, atanh(+/-1) = +/-Inf Applications: functions appear : Special relativity (rapidity transformations) Integration (e.g., integral  1/sqrt(x^2 + 1) dx = asinh(x) + C) Complex analysis conformal mappings Statistical distributions (e.g., Fisher's z-transformation)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_hyperbolic_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverse Hyperbolic Functions — inverse_hyperbolic_functions","text":"","code":"acosh_boost(x)  asinh_boost(x)  atanh_boost(x)"},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_hyperbolic_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverse Hyperbolic Functions — inverse_hyperbolic_functions","text":"x Input numeric value (domain depends function)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_hyperbolic_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inverse Hyperbolic Functions — inverse_hyperbolic_functions","text":"single numeric value computed inverse hyperbolic function.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/inverse_hyperbolic_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inverse Hyperbolic Functions — inverse_hyperbolic_functions","text":"","code":"# Inverse Hyperbolic Cosine (x >= 1) acosh_boost(2)  # Returns approximately 1.317 #> [1] 1.316958 # Inverse Hyperbolic Sine (all real x) asinh_boost(1)  # Returns approximately 0.881 #> [1] 0.8813736 # Inverse Hyperbolic Tangent (|x| < 1) atanh_boost(0.5)  # Returns approximately 0.549 #> [1] 0.5493061"},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_elliptic_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Jacobi Elliptic Functions — jacobi_elliptic_functions","title":"Jacobi Elliptic Functions — jacobi_elliptic_functions","text":"Functions compute Jacobi elliptic functions, doubly periodic generalizations trigonometric hyperbolic functions. Jacobi elliptic functions fundamental theory elliptic functions appear solutions nonlinear differential equations, including pendulum equation, theory elliptic curves. Three Principal Functions: three copolar Jacobi elliptic functions : sn(u, k) - Sine amplitude cn(u, k) - Cosine amplitude dn(u, k) - Delta amplitude satisfy fundamental identity: sn^2 + cn^2 = 1 dn^2 + k^2sn^2 = 1 Parameter Notation: k = elliptic modulus (used implementation) Alternative notations: m = k^2 (parameter), alpha = modular angle k = sin(alpha) Special Cases: sn(0, k) = 0; cn(0, k) = dn(0, k) = 1 k = 0: sn(u, 0) = sin(u); cn(u, 0) = cos(u); dn(u, 0) = 1 k = 1: sn(u, 1) = tanh(u); cn(u, 1) = dn(u, 1) = sech(u) Derived Functions: Twelve Jacobi elliptic functions exist, derived ratios sn, cn, dn: cd = cn/dn, cs = cn/sn, dc = dn/cn, ds = dn/sn nc = 1/cn, nd = 1/dn, ns = 1/sn sc = sn/cn, sd = sn/dn functions satisfy double periodicity various addition formulas analogous trigonometric identities. Implementation: Values calculated using arithmetic-geometric mean (AGM) method. k > 1, transformation relations apply complementary modulus. function jacobi_elliptic(k, u) returns three principal functions simultaneously efficiency.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_elliptic_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Jacobi Elliptic Functions — jacobi_elliptic_functions","text":"","code":"jacobi_elliptic(k, u)  jacobi_cd(k, u)  jacobi_cn(k, u)  jacobi_cs(k, u)  jacobi_dc(k, u)  jacobi_dn(k, u)  jacobi_ds(k, u)  jacobi_nc(k, u)  jacobi_nd(k, u)  jacobi_ns(k, u)  jacobi_sc(k, u)  jacobi_sd(k, u)  jacobi_sn(k, u)"},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_elliptic_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Jacobi Elliptic Functions — jacobi_elliptic_functions","text":"k Elliptic modulus (typically 0 <= k <= 1, k > 1 uses complementary relations) u Argument elliptic functions","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_elliptic_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Jacobi Elliptic Functions — jacobi_elliptic_functions","text":"jacobi_elliptic, list containing values Jacobi elliptic functions: sn, cn, dn. individual functions, single numeric value returned.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_elliptic_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Jacobi Elliptic Functions — jacobi_elliptic_functions","text":"","code":"# All three principal Jacobi Elliptic Functions at once k <- 0.5 u <- 2 jacobi_elliptic(k, u) #> $sn #> [1] 0.9628982 #>  #> $cn #> [1] -0.269865 #>  #> $dn #> [1] 0.8764741 #>  # Individual Jacobi Elliptic Functions jacobi_cd(k, u) #> [1] -0.3078984 jacobi_cn(k, u) #> [1] -0.269865 jacobi_cs(k, u) #> [1] -0.2802632 jacobi_dc(k, u) #> [1] -3.247825 jacobi_dn(k, u) #> [1] 0.8764741 jacobi_ds(k, u) #> [1] 0.9102458 jacobi_nc(k, u) #> [1] -3.705557 jacobi_nd(k, u) #> [1] 1.140935 jacobi_ns(k, u) #> [1] 1.038531 jacobi_sc(k, u) #> [1] -3.568074 jacobi_sd(k, u) #> [1] 1.098604 jacobi_sn(k, u) #> [1] 0.9628982"},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_polynomials.html","id":null,"dir":"Reference","previous_headings":"","what":"Jacobi Polynomials and Related Functions — jacobi_polynomials","title":"Jacobi Polynomials and Related Functions — jacobi_polynomials","text":"Functions compute Jacobi polynomials, derivatives, related functions.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_polynomials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Jacobi Polynomials and Related Functions — jacobi_polynomials","text":"","code":"jacobi(n, alpha, beta, x)  jacobi_prime(n, alpha, beta, x)  jacobi_double_prime(n, alpha, beta, x)  jacobi_derivative(n, alpha, beta, x, k)"},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_polynomials.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Jacobi Polynomials and Related Functions — jacobi_polynomials","text":"n Degree polynomial alpha First parameter polynomial beta Second parameter polynomial x Argument polynomial k Order derivative","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_polynomials.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Jacobi Polynomials and Related Functions — jacobi_polynomials","text":"single numeric value computed Jacobi polynomial, derivative, k-th derivative.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_polynomials.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Jacobi Polynomials and Related Functions — jacobi_polynomials","text":"","code":"# Jacobi polynomial P_2^(1, 2)(0.5) jacobi(2, 1, 2, 0.5) #> [1] -0.1875 # Derivative of the Jacobi polynomial P_2^(1, 2)'(0.5) jacobi_prime(2, 1, 2, 0.5) #> [1] 3.75 # Second derivative of the Jacobi polynomial P_2^(1, 2)''(0.5) jacobi_double_prime(2, 1, 2, 0.5) #> [1] 10.5 # 3rd derivative of the Jacobi polynomial P_2^(1, 2)^(k)(0.5) jacobi_derivative(2, 1, 2, 0.5, 3) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_theta_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Jacobi Theta Functions — jacobi_theta_functions","title":"Jacobi Theta Functions — jacobi_theta_functions","text":"Functions compute four Jacobi theta functions theta_1, theta_2, theta_3, theta_4, inter-related periodic functions parameterised either q (nome) tau. Jacobi theta functions fundamental theory elliptic functions, modular forms, appear number theory, string theory, solutions heat equation circle. Four Theta Functions: theta_1(x, q) - First Jacobi theta function theta_2(x, q) - Second Jacobi theta function theta_3(x, q) - Third Jacobi theta function theta_4(x, q) - Fourth Jacobi theta function periodic functions x expressed terms nome parameter q. Parametrizations: q-parameterization: Functions q parameter 0 < q < 1. equivalent Mathematica's EllipticTheta function (whose first argument function number). jacobi_theta1(x, q), jacobi_theta2(x, q), jacobi_theta3(x, q), jacobi_theta4(x, q) tau-parameterization: Alternative form q expressed tau. mathematical tau assumed purely imaginary, Boost argument real-valued implicitly multiplied . jacobi_theta1tau(x, tau), jacobi_theta2tau(x, tau), etc. Special \"Minus 1\" Variants: Similar expm1(), functions return one less evaluated function, yielding increased accuracy q small: jacobi_theta3m1(x, q) = theta_3(x, q) - 1 jacobi_theta4m1(x, q) = theta_4(x, q) - 1 Also available tau-parameterization: jacobi_theta3m1tau, jacobi_theta4m1tau Relationships: four theta functions closely related addition formulas transformations. satisfy various identities can expressed terms infinite series products.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_theta_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Jacobi Theta Functions — jacobi_theta_functions","text":"","code":"jacobi_theta1(x, q)  jacobi_theta1tau(x, tau)  jacobi_theta2(x, q)  jacobi_theta2tau(x, tau)  jacobi_theta3(x, q)  jacobi_theta3tau(x, tau)  jacobi_theta3m1(x, q)  jacobi_theta3m1tau(x, tau)  jacobi_theta4(x, q)  jacobi_theta4tau(x, tau)  jacobi_theta4m1(x, q)  jacobi_theta4m1tau(x, tau)"},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_theta_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Jacobi Theta Functions — jacobi_theta_functions","text":"x Input value (argument theta function) q nome parameter Jacobi theta function (0 < q < 1) tau nome parameter tau-form (real-valued, implicitly multiplied )","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_theta_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Jacobi Theta Functions — jacobi_theta_functions","text":"single numeric value computed Jacobi theta function.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/jacobi_theta_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Jacobi Theta Functions — jacobi_theta_functions","text":"","code":"# Jacobi Theta Functions with q parametrization x <- 0.5 q <- 0.3  # Note: q should be in (0, 1) tau <- 1.5 jacobi_theta1(x, q) #> [1] 0.577394 jacobi_theta1tau(x, tau) #> [1] 0.2951461 jacobi_theta2(x, q) #> [1] 1.307526 jacobi_theta2tau(x, tau) #> [1] 0.5403556 jacobi_theta3(x, q) #> [1] 1.317401 jacobi_theta3tau(x, tau) #> [1] 1.009707 # Special \"minus 1\" variants for improved accuracy when q is small jacobi_theta3m1(x, q) #> [1] 0.3174008 jacobi_theta3m1tau(x, tau) #> [1] 0.00970738 jacobi_theta4(x, q) #> [1] 0.669116 jacobi_theta4tau(x, tau) #> [1] 0.9902926 jacobi_theta4m1(x, q) #> [1] -0.330884 jacobi_theta4m1tau(x, tau) #> [1] -0.009707391"},{"path":"https://andrjohns.github.io/boostmath/reference/kolmogorov_smirnov_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Kolmogorov-Smirnov Distribution Functions — kolmogorov_smirnov_distribution","title":"Kolmogorov-Smirnov Distribution Functions — kolmogorov_smirnov_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Kolmogorov-Smirnov distribution. Boost implements limiting (first-order) Kolmogorov distribution. CDF expressed terms Jacobi theta function: $$F(x) = \\vartheta_4\\!\\left(0, \\frac{2x^2}{\\pi}\\right)$$ $$x \\ge 0$$. PDF obtained differentiating CDF, quantiles computed via Newton-Raphson iteration. Accuracy Implementation Notes: CDF uses Jacobi theta function inherits accuracy. PDF implemented separately. limiting distribution nonzero mass 1 finite $n$ (unlike exact KS distribution), especially $n$ small.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/kolmogorov_smirnov_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kolmogorov-Smirnov Distribution Functions — kolmogorov_smirnov_distribution","text":"","code":"kolmogorov_smirnov_distribution(n)  kolmogorov_smirnov_pdf(x, n)  kolmogorov_smirnov_lpdf(x, n)  kolmogorov_smirnov_cdf(x, n)  kolmogorov_smirnov_lcdf(x, n)  kolmogorov_smirnov_quantile(p, n)"},{"path":"https://andrjohns.github.io/boostmath/reference/kolmogorov_smirnov_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kolmogorov-Smirnov Distribution Functions — kolmogorov_smirnov_distribution","text":"n Sample size (n > 0). x Quantile value (x >= 0). p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/kolmogorov_smirnov_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kolmogorov-Smirnov Distribution Functions — kolmogorov_smirnov_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/kolmogorov_smirnov_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kolmogorov-Smirnov Distribution Functions — kolmogorov_smirnov_distribution","text":"","code":"# Kolmogorov-Smirnov distribution with sample size n = 10 dist <- kolmogorov_smirnov_distribution(10) # Apply generic functions cdf(dist, 2) #> [1] 1 logcdf(dist, 2) #> [1] 0 pdf(dist, 2) #> [1] 2.887762e-33 logpdf(dist, 2) #> [1] -74.92483 hazard(dist, 2) #> [1] 80 chf(dist, 2) #> [1] 79.30685 mean(dist) #> [1] 0.2747169 median(dist) #> [1] 0.2617017 mode(dist) #> [1] 0.2325754 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.2039076 standard_deviation(dist) #> [1] 0.08232448 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 0.00677732 skewness(dist) #> [1] 0.8604261 kurtosis(dist) #> [1] 3.881619 kurtosis_excess(dist) #> [1] 0.881619  # Convenience functions kolmogorov_smirnov_pdf(0.5, 10) #> [1] 0.2695176 kolmogorov_smirnov_lpdf(0.5, 10) #> [1] -1.311122 kolmogorov_smirnov_cdf(0.5, 10) #> [1] 0.9865241 kolmogorov_smirnov_lcdf(0.5, 10) #> [1] -0.01356751 kolmogorov_smirnov_quantile(0.5, 10) #> [1] 0.2617017"},{"path":"https://andrjohns.github.io/boostmath/reference/laguerre_polynomials.html","id":null,"dir":"Reference","previous_headings":"","what":"Laguerre Polynomials and Related Functions — laguerre_polynomials","title":"Laguerre Polynomials and Related Functions — laguerre_polynomials","text":"Functions compute Laguerre polynomials associated Laguerre polynomials. Laguerre polynomials orthogonal polynomials appear solution quantum harmonic oscillator, hydrogen atom wavefunctions, various problems mathematical physics probability theory. Standard Laguerre Polynomials L_n(x): laguerre(n, x): Evaluates Laguerre polynomial degree n point x Solutions Laguerre's differential equation Orthogonal respect weight function \\(e^{-x}\\) [0, Inf) Associated Laguerre Polynomials L_n^m(x): laguerre_m(n, m, x): Evaluates associated Laguerre polynomial degree n order m point x Generalizations standard Laguerre polynomials Recurrence Relations: Three-term recurrence relations enable efficient sequential computation: laguerre_next(n, x, Ln, Lnm1): Computes \\(L_{n+1}(x)\\) \\(L_n\\) \\(L_{n-1}\\) laguerre_next_m(n, m, x, Ln, Lnm1): Computes \\(L_{n+1}^m(x)\\) previous values Implementation Notes: Functions use stable three-term recurrence relations guarantee low absolute error guarantee low relative error near polynomial roots.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/laguerre_polynomials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Laguerre Polynomials and Related Functions — laguerre_polynomials","text":"","code":"laguerre(n, x)  laguerre_m(n, m, x)  laguerre_next(n, x, Ln, Lnm1)  laguerre_next_m(n, m, x, Ln, Lnm1)"},{"path":"https://andrjohns.github.io/boostmath/reference/laguerre_polynomials.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Laguerre Polynomials and Related Functions — laguerre_polynomials","text":"n Degree polynomial x Argument polynomial m Order polynomial (associated Laguerre polynomials) Ln Value Laguerre polynomial \\(L_n(x)\\) Lnm1 Value Laguerre polynomial \\(L_{n-1}(x)\\)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/laguerre_polynomials.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Laguerre Polynomials and Related Functions — laguerre_polynomials","text":"single numeric value computed Laguerre polynomial.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/laguerre_polynomials.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Laguerre Polynomials and Related Functions — laguerre_polynomials","text":"","code":"# Laguerre polynomial L_2(0.5) laguerre(2, 0.5) #> [1] 0.125 # Associated Laguerre polynomial L_2^1(0.5) laguerre_m(2, 1, 0.5) #> [1] 1.625 # Next Laguerre polynomial L_3(0.5) using L_2(0.5) and L_1(0.5) laguerre_next(2, 0.5, laguerre(2, 0.5), laguerre(1, 0.5)) #> [1] -0.1458333 # Next associated Laguerre polynomial L_3^1(0.5) using L_2^1(0.5) and L_1^1(0.5) laguerre_next_m(2, 1, 0.5, laguerre_m(2, 1, 0.5), laguerre_m(1, 1, 0.5)) #> [1] 1.479167"},{"path":"https://andrjohns.github.io/boostmath/reference/lambert_w_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Lambert W Function and Its Derivatives — lambert_w_function","title":"Lambert W Function and Its Derivatives — lambert_w_function","text":"Functions compute Lambert W function derivatives principal branch (W_0) branch -1 (W_-_1). Lambert W function (also known Omega function product logarithm) inverse f(W) = W*e^W. solves equation: $$W(z) \\cdot e^{W(z)} = z$$ Branches: function two real branches: W_0 (Principal Branch): Domain: [-1/e, Inf) 1/e ~= 0.367879 lambert_w0(z): Returns principal branch value lambert_w0_prime(z): Returns derivative W_0 z >= 0, single real solution W_-_1 (Secondary Branch): Domain: [-1/e, 0) lambert_wm1(z): Returns -1 branch value lambert_wm1_prime(z): Returns derivative W_-_1 Exists two real solutions occur (-1/e, 0) z approaches 0, W_-_1(z) approaches -Inf Special Values: W_0(-1/e) = -1 (exactly) W_-_1(-1/e) = -1 (exactly) W_-_1(0) = -Inf Singularity: z = -1/e ~= -0.367879, two branches meet condition number function evaluation tends infinity. implementation uses Halley's method Newton-Raphson iteration numerical refinement. Applications include solving transcendental equations, delay differential equations, enumeration problems.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/lambert_w_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lambert W Function and Its Derivatives — lambert_w_function","text":"","code":"lambert_w0(z)  lambert_wm1(z)  lambert_w0_prime(z)  lambert_wm1_prime(z)"},{"path":"https://andrjohns.github.io/boostmath/reference/lambert_w_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lambert W Function and Its Derivatives — lambert_w_function","text":"z Argument Lambert W function","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/lambert_w_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lambert W Function and Its Derivatives — lambert_w_function","text":"single numeric value computed Lambert W function derivative.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/lambert_w_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lambert W Function and Its Derivatives — lambert_w_function","text":"","code":"# Lambert W Function (Principal Branch) lambert_w0(0.3) #> [1] 0.2367553 # Lambert W Function (Branch -1) lambert_wm1(-0.3) #> [1] -1.781337 # Derivative of the Lambert W Function (Principal Branch) lambert_w0_prime(0.3) #> [1] 0.6381087 # Derivative of the Lambert W Function (Branch -1) lambert_wm1_prime(-0.3) #> [1] -7.599525"},{"path":"https://andrjohns.github.io/boostmath/reference/landau_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Landau Distribution Functions — landau_distribution","title":"Landau Distribution Functions — landau_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Landau distribution. Landau distribution stable distribution $$\\alpha=1$$ $$\\beta=1$$. standard integral representation PDF $$f(x) = \\frac{1}{\\pi}\\int_0^\\infty \\exp\\left(-t\\log t - x t\\right)\\sin(\\pi t)\\,dt.$$ location parameter $$\\mu$$ scale parameter $c$ shift scale distribution, bias term $$b = -\\frac{2}{\\pi}\\log c$$ applied Boost parameterization. Accuracy Implementation Notes: Boost reports errors within 4 epsilon except rapidly decaying left tail. moments (mean, variance, skewness, kurtosis) undefined raise errors.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/landau_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Landau Distribution Functions — landau_distribution","text":"","code":"landau_distribution(location = 0, scale = 1)  landau_pdf(x, location = 0, scale = 1)  landau_lpdf(x, location = 0, scale = 1)  landau_cdf(x, location = 0, scale = 1)  landau_lcdf(x, location = 0, scale = 1)  landau_quantile(p, location = 0, scale = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/landau_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Landau Distribution Functions — landau_distribution","text":"location Location parameter (default 0). scale Scale parameter (default 1). x Quantile value. p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/landau_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Landau Distribution Functions — landau_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/landau_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Landau Distribution Functions — landau_distribution","text":"","code":"# Landau distribution with location 0 and scale 1 dist <- landau_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.4842393 logcdf(dist, 0.5) #> [1] -0.7251762 pdf(dist, 0.5) #> [1] 0.2123185 logpdf(dist, 0.5) #> [1] -1.549668 hazard(dist, 0.5) #> [1] 0.4116608 chf(dist, 0.5) #> [1] 0.6621123 median(dist) #> [1] 0.5756301 mode(dist) #> [1] -0.4293145 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.5948319 support(dist) #> [1] -Inf  Inf  # Convenience functions landau_pdf(3) #> [1] 0.05863949 landau_lpdf(3) #> [1] -2.836347 landau_cdf(3) #> [1] 0.7792967 landau_lcdf(3) #> [1] -0.2493635 landau_quantile(0.5) #> [1] 0.5756301"},{"path":"https://andrjohns.github.io/boostmath/reference/laplace_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Laplace Distribution Functions — laplace_distribution","title":"Laplace Distribution Functions — laplace_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Laplace (double exponential) distribution. location $$\\mu$$ scale $$\\sigma > 0$$, PDF $$f(x) = \\frac{1}{2\\sigma}\\exp\\left(-\\frac{|x-\\mu|}{\\sigma}\\right)$$ CDF $$F(x) = \\begin{cases}\\frac{1}{2}\\exp\\left(\\frac{x-\\mu}{\\sigma}\\right), & x < \\mu,\\\\ 1 - \\frac{1}{2}\\exp\\left(\\frac{\\mu-x}{\\sigma}\\right), & x \\ge \\mu.\\end{cases}$$ Accuracy Implementation Notes: Implemented terms exp log; logcdf logpdf specialised improved numerical accuracy. Complements use stable log1p forms.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/laplace_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Laplace Distribution Functions — laplace_distribution","text":"","code":"laplace_distribution(location = 0, scale = 1)  laplace_pdf(x, location = 0, scale = 1)  laplace_lpdf(x, location = 0, scale = 1)  laplace_cdf(x, location = 0, scale = 1)  laplace_lcdf(x, location = 0, scale = 1)  laplace_quantile(p, location = 0, scale = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/laplace_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Laplace Distribution Functions — laplace_distribution","text":"location Location parameter (default 0). scale Scale parameter (default 1). x Quantile value. p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/laplace_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Laplace Distribution Functions — laplace_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/laplace_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Laplace Distribution Functions — laplace_distribution","text":"","code":"# Laplace distribution with location = 0, scale = 1 dist <- laplace_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6967347 logcdf(dist, 0.5) #> [1] -0.3613506 pdf(dist, 0.5) #> [1] 0.3032653 logpdf(dist, 0.5) #> [1] -1.193147 hazard(dist, 0.5) #> [1] 1 chf(dist, 0.5) #> [1] 1.193147 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.9162907 standard_deviation(dist) #> [1] 1.414214 support(dist) #> [1] -Inf  Inf variance(dist) #> [1] 2 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 6 kurtosis_excess(dist) #> [1] 3  # Convenience functions laplace_pdf(0) #> [1] 0.5 laplace_lpdf(0) #> [1] -0.6931472 laplace_cdf(0) #> [1] 0.5 laplace_lcdf(0) #> [1] -0.6931472 laplace_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/reference/legendre_polynomials.html","id":null,"dir":"Reference","previous_headings":"","what":"Legendre Polynomials and Related Functions — legendre_polynomials","title":"Legendre Polynomials and Related Functions — legendre_polynomials","text":"Functions compute Legendre polynomials first second kind, derivatives, zeros, related functions. Legendre polynomials orthogonal polynomials solutions Legendre's differential equation. appear physics (multipole expansions, solutions Laplace's equation spherical coordinates) numerical analysis (Gaussian quadrature). Legendre Polynomials First Kind P_n(x): Standard solutions Legendre differential equation. Domain: -1 <= x <= 1 (domain error outside range) Reflection formula: \\(P_{-l-1}(x) = P_l(x)\\) legendre_p(n, x): Evaluates P_n(x) legendre_p_prime(n, x): Derivative P_n(x) legendre_p_zeros(n): Returns zeros increasing order. odd n, first zero 0. Computed using Newton's method Tricomi's initial estimates (O(n^2) complexity) Associated Legendre Polynomials P_n^m(x): legendre_p_m(n, m, x): Evaluates P_n^m(x) Includes Condon-Shortley phase term (-1)^m matching Abramowitz & Stegun definition Negative values n m handled identity relations Legendre Polynomials Second Kind Q_n(x): Second solution Legendre differential equation. legendre_q(n, x): Evaluates Q_n(x) Domain: -1 <= x <= 1 (domain error otherwise) Recurrence Relations: Efficient computation using three-term recurrence fixed x increasing degree: legendre_next(n, x, Pl, Plm1): Computes \\(P_{n+1}(x)\\) \\(P_n\\) \\(P_{n-1}\\) legendre_next_m(n, m, x, Pl, Plm1): Computes \\(P_{n+1}^m(x)\\) previous values Recurrence relations guarantee low absolute error guarantee low relative error near polynomial roots.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/legendre_polynomials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Legendre Polynomials and Related Functions — legendre_polynomials","text":"","code":"legendre_p(n, x)  legendre_p_prime(n, x)  legendre_p_zeros(n)  legendre_p_m(n, m, x)  legendre_q(n, x)  legendre_next(n, x, Pl, Plm1)  legendre_next_m(n, m, x, Pl, Plm1)"},{"path":"https://andrjohns.github.io/boostmath/reference/legendre_polynomials.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Legendre Polynomials and Related Functions — legendre_polynomials","text":"n Degree polynomial x Argument polynomial (must \\([-1, 1]\\)) m Order polynomial (associated Legendre polynomials) Pl Value Legendre polynomial P_l(x) Plm1 Value Legendre polynomial \\(P_{l-1}(x)\\)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/legendre_polynomials.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Legendre Polynomials and Related Functions — legendre_polynomials","text":"single numeric value computed Legendre polynomial, derivative, zeros (vector).","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/legendre_polynomials.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Legendre Polynomials and Related Functions — legendre_polynomials","text":"","code":"# Legendre polynomial of the first kind P_2(0.5) legendre_p(2, 0.5) #> [1] -0.125 # Derivative of the Legendre polynomial of the first kind P_2'(0.5) legendre_p_prime(2, 0.5) #> [1] 1.5 # Zeros of the Legendre polynomial of the first kind P_2 legendre_p_zeros(2) #> [1] 0.5773503 # Associated Legendre polynomial P_2^1(0.5) legendre_p_m(2, 1, 0.5) #> [1] -1.299038 # Legendre polynomial of the second kind Q_2(0.5) legendre_q(2, 0.5) #> [1] -0.8186633 # Next Legendre polynomial of the first kind P_3(0.5) using P_2(0.5) and P_1(0.5) legendre_next(2, 0.5, legendre_p(2, 0.5), legendre_p(1, 0.5)) #> [1] -0.4375 # Next associated Legendre polynomial P_3^1(0.5) using P_2^1(0.5) and P_1^1(0.5) legendre_next_m(2, 1, 0.5, legendre_p_m(2, 1, 0.5), legendre_p_m(1, 1, 0.5)) #> [1] -0.3247595"},{"path":"https://andrjohns.github.io/boostmath/reference/linear_regression.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear Regression Functions — linear_regression","title":"Linear Regression Functions — linear_regression","text":"Functions perform simple ordinary least squares (OLS) linear regression. OLS fit finds $c_0$ $c_1$ minimize $$\\sum_{=1}^n (y_i - (c_0 + c_1 x_i))^2$$ producing model $f(x)=c_0+c_1x$. optional $R^2$ output uses $$R^2 = 1 - \\frac{\\sum_i (y_i - \\hat{y}_i)^2}{\\sum_i (y_i - \\bar{y})^2}$$ Accuracy Implementation Notes: Boost uses numerically stable one-pass approach based means, variances, covariances reduce cancellation error.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/linear_regression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear Regression Functions — linear_regression","text":"","code":"simple_ordinary_least_squares(x, y)  simple_ordinary_least_squares_with_R_squared(x, y)"},{"path":"https://andrjohns.github.io/boostmath/reference/linear_regression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear Regression Functions — linear_regression","text":"x numeric vector. y numeric vector.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/linear_regression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Linear Regression Functions — linear_regression","text":"two-element numeric vector containing intercept slope regression line, three-element vector containing intercept, slope, R-squared value applicable.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/linear_regression.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linear Regression Functions — linear_regression","text":"","code":"# Simple Ordinary Least Squares x <- c(1, 2, 3, 4, 5) y <- c(2, 3, 5, 7, 11) simple_ordinary_least_squares(x, y) #> [1] -1.0  2.2 # Simple Ordinary Least Squares with R-squared simple_ordinary_least_squares_with_R_squared(x, y) #> [1] -1.0000000  2.2000000  0.9453125"},{"path":"https://andrjohns.github.io/boostmath/reference/ljung_box_test.html","id":null,"dir":"Reference","previous_headings":"","what":"Ljung-Box Test for Autocorrelation — ljung_box_test","title":"Ljung-Box Test for Autocorrelation — ljung_box_test","text":"Functions perform Ljung-Box test autocorrelation residuals. test statistic $$Q = n(n+2)\\sum_{k=1}^{\\ell} \\frac{\\hat{\\rho}_k^2}{n-k}$$ $n$ sample size, $$\\ell$$ number lags, $$\\hat{\\rho}_k$$ sample autocorrelations. p-value computed chi-squared approximation adjusted degrees freedom. Implementation Notes: default, number lags chosen $$\\log(n)$$ $$O(n \\log n)$$ complexity. fit_dof adjusts p-value account model parameters.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/ljung_box_test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ljung-Box Test for Autocorrelation — ljung_box_test","text":"","code":"ljung_box(v, lags = -1, fit_dof = 0)"},{"path":"https://andrjohns.github.io/boostmath/reference/ljung_box_test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ljung-Box Test for Autocorrelation — ljung_box_test","text":"v numeric vector. lags single integer value (default uses $$\\log(n)$$). fit_dof single integer value.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/ljung_box_test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ljung-Box Test for Autocorrelation — ljung_box_test","text":"two-element numeric vector containing test statistic p-value.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/ljung_box_test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ljung-Box Test for Autocorrelation — ljung_box_test","text":"","code":"# Ljung-Box test for autocorrelation ljung_box(c(1, 2, 3, 4, 5), lags = 2, fit_dof = 0) #> [1] 1.5166667 0.4684465"},{"path":"https://andrjohns.github.io/boostmath/reference/logistic_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Logistic Distribution Functions — logistic_distribution","title":"Logistic Distribution Functions — logistic_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Logistic distribution. location $u$ scale $s>0$, PDF CDF $$f(x) = \\frac{e^{-(x-u)/s}}{s\\left(1+e^{-(x-u)/s}\\right)^2}$$ $$F(x) = \\frac{1}{1+e^{-(x-u)/s}}$$ quantile $$Q(p) = u - s\\log\\left(\\frac{1}{p}-1\\right)$$. Accuracy Implementation Notes: Implemented exp/log. logcdf specialised improved numerical accuracy. Quantiles can suffer catastrophic cancellation location parameter large; low absolute error can guaranteed regime.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/logistic_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logistic Distribution Functions — logistic_distribution","text":"","code":"logistic_distribution(location = 0, scale = 1)  logistic_pdf(x, location = 0, scale = 1)  logistic_lpdf(x, location = 0, scale = 1)  logistic_cdf(x, location = 0, scale = 1)  logistic_lcdf(x, location = 0, scale = 1)  logistic_quantile(p, location = 0, scale = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/logistic_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logistic Distribution Functions — logistic_distribution","text":"location Location parameter (default 0). scale Scale parameter (default 1). x Quantile value. p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/logistic_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logistic Distribution Functions — logistic_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/logistic_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logistic Distribution Functions — logistic_distribution","text":"","code":"# Logistic distribution with location = 0, scale = 1 dist <- logistic_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6224593 logcdf(dist, 0.5) #> [1] -0.474077 pdf(dist, 0.5) #> [1] 0.2350037 logpdf(dist, 0.5) #> [1] -1.448154 hazard(dist, 0.5) #> [1] 0.6224593 chf(dist, 0.5) #> [1] 0.974077 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -1.386294 standard_deviation(dist) #> [1] 1.813799 support(dist) #> [1] -1.797693e+308  1.797693e+308 variance(dist) #> [1] 3.289868 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 4.2 kurtosis_excess(dist) #> [1] 1.2  # Convenience functions logistic_pdf(0) #> [1] 0.25 logistic_lpdf(0) #> [1] -1.386294 logistic_cdf(0) #> [1] 0.5 logistic_lcdf(0) #> [1] -0.6931472 logistic_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/reference/logistic_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Logistic Functions — logistic_functions","title":"Logistic Functions — logistic_functions","text":"Functions compute logistic sigmoid function inverse, logit function. functions fundamental statistics, machine learning, probability theory, particularly logistic regression neural networks. Logistic Sigmoid Function: logistic sigmoid (also called logistic function expit) defined : $$\\sigma(x) = \\frac{1}{1 + e^{-x}} = \\frac{e^x}{1 + e^x}$$ logistic_sigmoid(x): Computes sigma(x) Domain: (-Inf, Inf) Range: (0, 1) S-shaped (sigmoid) curve Symmetric around x = 0: sigma(-x) = 1 - sigma(x) Special values: sigma(0) = 0.5 sigma(Inf) = 1 sigma(-Inf) = 0 Derivative: sigma'(x) = sigma(x)(1 - sigma(x)) Applications: Activation function neural networks Models probability logistic regression Converts log-odds probabilities Smooth approximation step functions Logit Function: logit function (log-odds inverse sigmoid) defined : $$logit(p) = \\log\\left(\\frac{p}{1 - p}\\right)$$ logit(x): Computes logit(x) = log(x/(1-x)) Domain: (0, 1) Range: (-Inf, Inf) Inverse logistic sigmoid: logit(sigma(x)) = x Odd function around p = 0.5: logit(1 - p) = -logit(p) Special values: logit(0.5) = 0 logit(0) = -Inf logit(1) = Inf Derivative: d/dp logit(p) = 1/(p(1-p)) Applications: Converts probabilities log-odds scale Link function logistic regression Transforms bounded quantities unbounded scale Used odds ratio calculations Numerical Stability: functions use numerically stable implementations avoid overflow/underflow extreme values arguments.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/logistic_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logistic Functions — logistic_functions","text":"","code":"logistic_sigmoid(x)  logit(x)"},{"path":"https://andrjohns.github.io/boostmath/reference/logistic_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logistic Functions — logistic_functions","text":"x Numeric value compute functions","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/logistic_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logistic Functions — logistic_functions","text":"single numeric value computed logit logistic sigmoid function.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/logistic_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logistic Functions — logistic_functions","text":"","code":"# Logistic Sigmoid Function logistic_sigmoid(0)     # Returns 0.5 #> [1] 0.5 logistic_sigmoid(2)     # Returns ~0.881 #> [1] 0.8807971 logistic_sigmoid(-2)    # Returns ~0.119 #> [1] 0.1192029  # Logit Function (inverse of sigmoid) logit(0.5)              # Returns 0 #> [1] 0 logit(0.7)              # Returns ~0.847 #> [1] 0.8472979 logit(0.881)            # Returns ~2 (inverse of sigmoid(2)) #> [1] 2.001934"},{"path":"https://andrjohns.github.io/boostmath/reference/lognormal_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Normal Distribution Functions — lognormal_distribution","title":"Log Normal Distribution Functions — lognormal_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Log Normal distribution. $$\\log X \\sim \\mathcal{N}(m, s^2)$$, $X$ lognormal. PDF $$f(x) = \\frac{1}{x s \\sqrt{2\\pi}}\\exp\\left(-\\frac{(\\log x - m)^2}{2 s^2}\\right), \\quad x>0$$ CDF $$\\Phi((\\log x - m)/s)$$. Accuracy Implementation Notes: Implemented log, exp, error function. CDF/quantile computed via normal distribution evaluated $$\\log(x)$$.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/lognormal_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Normal Distribution Functions — lognormal_distribution","text":"","code":"lognormal_distribution(location = 0, scale = 1)  lognormal_pdf(x, location = 0, scale = 1)  lognormal_lpdf(x, location = 0, scale = 1)  lognormal_cdf(x, location = 0, scale = 1)  lognormal_lcdf(x, location = 0, scale = 1)  lognormal_quantile(p, location = 0, scale = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/lognormal_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Normal Distribution Functions — lognormal_distribution","text":"location Location parameter (mean $$\\log X$$; default 0). scale Scale parameter (sd $$\\log X$$; default 1). x Quantile value (x > 0). p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/lognormal_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Normal Distribution Functions — lognormal_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/lognormal_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log Normal Distribution Functions — lognormal_distribution","text":"","code":"# Log Normal distribution with location = 0, scale = 1 dist <- lognormal_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.2441086 logcdf(dist, 0.5) #> [1] -1.410142 pdf(dist, 0.5) #> [1] 0.6274961 logpdf(dist, 0.5) #> [1] -0.4660179 hazard(dist, 0.5) #> [1] 0.8301405 chf(dist, 0.5) #> [1] 0.2798576 mean(dist) #> [1] 1.648721 median(dist) #> [1] 1 mode(dist) #> [1] 0.3678794 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.4310112 standard_deviation(dist) #> [1] 2.161197 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 4.670774 skewness(dist) #> [1] 6.184877 kurtosis(dist) #> [1] 113.9364 kurtosis_excess(dist) #> [1] 110.9364  # Convenience functions lognormal_pdf(0) #> [1] 0 lognormal_lpdf(0) #> [1] -Inf lognormal_cdf(0) #> [1] 0 lognormal_lcdf(0) #> [1] -Inf lognormal_quantile(0.5) #> [1] 1"},{"path":"https://andrjohns.github.io/boostmath/reference/makima.html","id":null,"dir":"Reference","previous_headings":"","what":"Modified Akima Interpolator — makima","title":"Modified Akima Interpolator — makima","text":"modified Akima interpolant takes non-equispaced data interpolates via cubic Hermite polynomials whose slopes chosen significantly. Properties: slopes chosen modification geometric construction proposed Akima. interpolant C1 evaluation O(log N) complexity. oscillates less cubic spline less smoothness. modification given Cosmin Ionita agrees Matlab's version.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/makima.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modified Akima Interpolator — makima","text":"","code":"makima(x, y, left_endpoint_derivative = NULL, right_endpoint_derivative = NULL)"},{"path":"https://andrjohns.github.io/boostmath/reference/makima.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modified Akima Interpolator — makima","text":"x Numeric vector abscissas (x-coordinates). y Numeric vector ordinates (y-coordinates). left_endpoint_derivative Optional numeric value derivative left endpoint. right_endpoint_derivative Optional numeric value derivative right endpoint.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/makima.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modified Akima Interpolator — makima","text":"object class makima methods: interpolate(xi): Evaluate interpolator point xi. prime(xi): Evaluate derivative interpolator point xi. push_back(x, y): Add new control point","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/makima.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modified Akima Interpolator — makima","text":"","code":"x <- c(0, 1, 2, 3) y <- c(0, 1, 0, 1) interpolator <- makima(x, y) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.7291667 interpolator$prime(xi) #> [1] 1.208333 interpolator$push_back(4, 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/mapairy_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Map-Airy Distribution Functions — mapairy_distribution","title":"Map-Airy Distribution Functions — mapairy_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Map-Airy distribution. Map-Airy distribution stable distribution $$\\alpha=3/2$$ $$\\beta=1$$, used model area Brownian excursion. parameterised location $$\\mu$$ scale $c$. Accuracy Implementation Notes: Boost reports errors within 4 epsilon except rapidly decaying left tail. moments (skewness, kurtosis) undefined raise errors requested.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/mapairy_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map-Airy Distribution Functions — mapairy_distribution","text":"","code":"mapairy_distribution(location = 0, scale = 1)  mapairy_pdf(x, location = 0, scale = 1)  mapairy_lpdf(x, location = 0, scale = 1)  mapairy_cdf(x, location = 0, scale = 1)  mapairy_lcdf(x, location = 0, scale = 1)  mapairy_quantile(p, location = 0, scale = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/mapairy_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map-Airy Distribution Functions — mapairy_distribution","text":"location Location parameter (default 0). scale Scale parameter (default 1). x Quantile value. p Probability (0 <= p <= 1).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/mapairy_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map-Airy Distribution Functions — mapairy_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/mapairy_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map-Airy Distribution Functions — mapairy_distribution","text":"","code":"# Map-Airy distribution with location 0 and scale 1 dist <- mapairy_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.7527466 logcdf(dist, 0.5) #> [1] -0.2840266 pdf(dist, 0.5) #> [1] 0.1477024 logpdf(dist, 0.5) #> [1] -1.912556 hazard(dist, 0.5) #> [1] 0.5973726 chf(dist, 0.5) #> [1] 1.397342 mean(dist) #> [1] 0 median(dist) #> [1] -0.7167107 mode(dist) #> [1] -1.161587 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -1.834427 standard_deviation(dist) #> [1] Inf support(dist) #> [1] -Inf  Inf variance(dist) #> [1] Inf  # Convenience functions mapairy_pdf(3) #> [1] 0.02799732 mapairy_lpdf(3) #> [1] -3.575647 mapairy_cdf(3) #> [1] 0.9316961 mapairy_lcdf(3) #> [1] -0.07074859 mapairy_quantile(0.5) #> [1] -0.7167107"},{"path":"https://andrjohns.github.io/boostmath/reference/negative_binomial_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Negative Binomial Distribution Functions — negative_binomial_distribution","title":"Negative Binomial Distribution Functions — negative_binomial_distribution","text":"Functions compute probability mass function (pmf), cumulative distribution function, quantile function Negative Binomial distribution. $r$ successes success fraction $p$, probability observing $k$ failures $r$-th success $$P(X = k) = \\binom{k+r-1}{k} p^r (1-p)^k, \\quad k \\\\{0,1,2,\\dots\\}$$ Accuracy Implementation Notes: Implemented using incomplete beta functions (ibeta, ibetac) derivatives PDF. discrete distribution, quantiles rounded outward ensure coverage. Confidence bounds use Clopper-Pearson style intervals.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/negative_binomial_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negative Binomial Distribution Functions — negative_binomial_distribution","text":"","code":"negative_binomial_distribution(successes, success_fraction)  negative_binomial_pdf(x, successes, success_fraction)  negative_binomial_lpdf(x, successes, success_fraction)  negative_binomial_cdf(x, successes, success_fraction)  negative_binomial_lcdf(x, successes, success_fraction)  negative_binomial_quantile(p, successes, success_fraction)  negative_binomial_find_lower_bound_on_p(trials, successes, alpha)  negative_binomial_find_upper_bound_on_p(trials, successes, alpha)  negative_binomial_find_minimum_number_of_trials(   failures,   success_fraction,   alpha )  negative_binomial_find_maximum_number_of_trials(   failures,   success_fraction,   alpha )"},{"path":"https://andrjohns.github.io/boostmath/reference/negative_binomial_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negative Binomial Distribution Functions — negative_binomial_distribution","text":"successes Number successes (successes > 0). success_fraction Probability success trial (0 <= success_fraction <= 1). x Quantile value. p Probability (0 <= p <= 1). trials Number trials. alpha Significance level (0 < alpha < 1). failures Number failures (failures >= 0).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/negative_binomial_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negative Binomial Distribution Functions — negative_binomial_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/negative_binomial_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negative Binomial Distribution Functions — negative_binomial_distribution","text":"","code":"# Negative Binomial distribution with successes = 5, success_fraction = 0.5 dist <- negative_binomial_distribution(5, 0.5) # Apply generic functions cdf(dist, 0.5) #> [1] 0.06449911 logcdf(dist, 0.5) #> [1] -2.741104 pdf(dist, 0.5) #> [1] 0.05437955 logpdf(dist, 0.5) #> [1] -2.911767 hazard(dist, 0.5) #> [1] 0.05812881 chf(dist, 0.5) #> [1] 0.06667318 mean(dist) #> [1] 5 median(dist) #> [1] 4 mode(dist) #> [1] 4 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 1 standard_deviation(dist) #> [1] 3.162278 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 10 skewness(dist) #> [1] 0.9486833 kurtosis(dist) #> [1] 4.3 kurtosis_excess(dist) #> [1] 1.3  # Convenience functions negative_binomial_pdf(3, 5, 0.5) #> [1] 0.1367188 negative_binomial_lpdf(3, 5, 0.5) #> [1] -1.989829 negative_binomial_cdf(3, 5, 0.5) #> [1] 0.3632812 negative_binomial_lcdf(3, 5, 0.5) #> [1] -1.012578 negative_binomial_quantile(0.5, 5, 0.5) #> [1] 4  if (FALSE) { # \\dontrun{ # Find lower bound on p given 10 trials and 5 successes with 95% confidence negative_binomial_find_lower_bound_on_p(10, 5, 0.05) # Find upper bound on p given 10 trials and 5 successes with 95% confidence negative_binomial_find_upper_bound_on_p(10, 5, 0.05) # Find minimum number of trials to observe 3 failures with success fraction 0.5 at 95% confidence negative_binomial_find_minimum_number_of_trials(3, 0.5, 0.05) # Find maximum number of trials to observe 3 failures with success fraction 0.5 at 95% confidence negative_binomial_find_maximum_number_of_trials(3, 0.5, 0.05) } # }"},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_beta_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Noncentral Beta Distribution Functions — non_central_beta_distribution","title":"Noncentral Beta Distribution Functions — non_central_beta_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Noncentral Beta distribution. noncentral beta distribution generalization Beta Distribution. defined ratio $$X = \\frac{\\chi_m^2(\\lambda)}{\\chi_m^2(\\lambda) + \\chi_n^2}$$ \\(\\chi_m^2(\\lambda)\\) noncentral \\(\\chi^2\\) random variable \\(m\\) degrees freedom, \\(\\chi_n^2\\) central \\(\\chi^2\\) random variable \\(n\\) degrees freedom. gives PDF can expressed Poisson mixture beta distribution PDFs: $$f(x; \\alpha, \\beta, \\lambda) = \\sum_{=0}^{\\infty} P(; \\lambda/2) '_x(\\alpha+, \\beta)$$ \\(P(; \\lambda/2)\\) discrete Poisson probability \\(\\), mean \\(\\lambda/2\\), \\('_x(\\alpha, \\beta)\\) derivative incomplete beta function. leads usual form CDF : $$F(x; \\alpha, \\beta, \\lambda) = \\sum_{=0}^{\\infty} P(; \\lambda/2) I_x(\\alpha+, \\beta)$$ \\(I_x(\\alpha, \\beta)\\) incomplete beta function. Accuracy Implementation Notes: CDF complement evaluated using approximation due Chattamvelli Shanmugam determine crossover point (mean). either CDF complement computed using relations . summation performed starting \\(= \\lambda/2\\), recursing directions (\"Method 2\" Benton Krishnamoorthy). Quantiles computed using specially modified version bracket solve, starting search root mean distribution.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_beta_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Noncentral Beta Distribution Functions — non_central_beta_distribution","text":"","code":"non_central_beta_distribution(alpha, beta, lambda)  non_central_beta_pdf(x, alpha, beta, lambda)  non_central_beta_lpdf(x, alpha, beta, lambda)  non_central_beta_cdf(x, alpha, beta, lambda)  non_central_beta_lcdf(x, alpha, beta, lambda)  non_central_beta_quantile(p, alpha, beta, lambda)"},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_beta_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Noncentral Beta Distribution Functions — non_central_beta_distribution","text":"alpha first shape parameter (alpha > 0) beta second shape parameter (beta > 0) lambda noncentrality parameter (lambda >= 0) x quantile (0 <= x <= 1) p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_beta_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Noncentral Beta Distribution Functions — non_central_beta_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_beta_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Noncentral Beta Distribution Functions — non_central_beta_distribution","text":"","code":"# Noncentral Beta distribution with shape parameters alpha = 2, beta = 3 # and noncentrality parameter lambda = 1 dist <- non_central_beta_distribution(2, 3, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.5977904 logcdf(dist, 0.5) #> [1] -0.514515 pdf(dist, 0.5) #> [1] 1.643543 logpdf(dist, 0.5) #> [1] 0.4968546 hazard(dist, 0.5) #> [1] 4.086286 chf(dist, 0.5) #> [1] 0.910782 mean(dist) #> [1] 0.44664 median(dist) #> [1] 0.4416064 mode(dist) #> [1] 0.4262677 range(dist) #> [1] 0 1 quantile(dist, 0.2) #> [1] 0.2549084 standard_deviation(dist) #> [1] 0.2040433 support(dist) #> [1] 0 1 variance(dist) #> [1] 0.04163366  # Convenience functions non_central_beta_pdf(0.5, 2, 3, 1) #> [1] 1.643543 non_central_beta_lpdf(0.5, 2, 3, 1) #> [1] 0.4968546 non_central_beta_cdf(0.5, 2, 3, 1) #> [1] 0.5977904 non_central_beta_lcdf(0.5, 2, 3, 1) #> [1] -0.514515 non_central_beta_quantile(0.5, 2, 3, 1) #> [1] 0.4416064"},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_chi_squared_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Noncentral Chi-Squared Distribution Functions — non_central_chi_squared_distribution","title":"Noncentral Chi-Squared Distribution Functions — non_central_chi_squared_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Noncentral Chi-Squared distribution. noncentral chi-squared distribution generalization Chi-Squared Distribution. \\(X_i\\) \\(\\nu\\) independent, normally distributed random variables means \\(\\mu_i\\) variances \\(\\sigma_i^2\\), random variable $$\\sum_{=1}^\\nu \\frac{X_i^2}{\\sigma_i^2}$$ distributed according noncentral chi-squared distribution. noncentral chi-squared distribution two parameters: \\(\\nu\\) specifies number degrees freedom (.e. number \\(X_i\\)), \\(\\lambda\\) related mean random variables \\(X_i\\) : $$\\lambda = \\sum_{=1}^\\nu \\frac{\\mu_i^2}{\\sigma_i^2}$$ (Note references define \\(\\lambda\\) one half sum). leads PDF : $$f(x;\\nu,\\lambda) = \\sum_{k=0}^\\infty \\frac{e^{-\\lambda/2}(\\lambda/2)^k}{k!} f(x; \\nu+2k)$$ \\(f(x;\\nu)\\) central chi-squared distribution PDF. Accuracy Implementation Notes: CDF complement evaluated using Temme's relation determine crossover point (approx \\(F(\\nu,\\lambda;\\nu+\\lambda) \\approx 0.5\\)). small \\(\\lambda\\), Ding's method (series representation) used. large \\(\\lambda (> 200)\\), Krishnamoorthy's method used, starting summation \\(\\lambda\\)-th term. Computed values comparable R Math library, failures mostly corner cases small probabilities.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_chi_squared_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Noncentral Chi-Squared Distribution Functions — non_central_chi_squared_distribution","text":"","code":"non_central_chi_squared_distribution(df, lambda)  non_central_chi_squared_pdf(x, df, lambda)  non_central_chi_squared_lpdf(x, df, lambda)  non_central_chi_squared_cdf(x, df, lambda)  non_central_chi_squared_lcdf(x, df, lambda)  non_central_chi_squared_quantile(p, df, lambda)  non_central_chi_squared_find_degrees_of_freedom(lambda, x, alpha)  non_central_chi_squared_find_non_centrality(df, x, alpha)"},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_chi_squared_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Noncentral Chi-Squared Distribution Functions — non_central_chi_squared_distribution","text":"df degrees freedom (df > 0) lambda noncentrality parameter (lambda >= 0) x quantile p probability (0 <= p <= 1) alpha acceptable probability Type error (false positive).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_chi_squared_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Noncentral Chi-Squared Distribution Functions — non_central_chi_squared_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_chi_squared_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Noncentral Chi-Squared Distribution Functions — non_central_chi_squared_distribution","text":"","code":"if (FALSE) { # \\dontrun{ # Noncentral Chi-Squared distribution with 3 degrees of freedom and noncentrality # parameter 1 dist <- non_central_chi_squared_distribution(3, 1) # Apply generic functions cdf(dist, 0.5) logcdf(dist, 0.5) pdf(dist, 0.5) logpdf(dist, 0.5) hazard(dist, 0.5) chf(dist, 0.5) mean(dist) median(dist) mode(dist) range(dist) quantile(dist, 0.2) standard_deviation(dist) support(dist) variance(dist) skewness(dist) kurtosis(dist) kurtosis_excess(dist)  # Convenience functions non_central_chi_squared_pdf(2, 3, 1) non_central_chi_squared_lpdf(2, 3, 1) non_central_chi_squared_cdf(2, 3, 1) non_central_chi_squared_lcdf(2, 3, 1) non_central_chi_squared_quantile(0.5, 3, 1)  # Find degrees of freedom needed for CDF at 2.0 with noncentrality parameter 1.0 = 0.05 non_central_chi_squared_find_degrees_of_freedom(1.0, 2.0, 0.05) # Find noncentrality parameter needed for CDF at 2.0 with 3 degrees of freedom = 0.05 non_central_chi_squared_find_non_centrality(3, 2.0, 0.05) } # }"},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_f_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Noncentral F Distribution Functions — non_central_f_distribution","title":"Noncentral F Distribution Functions — non_central_f_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Noncentral F distribution. noncentral F distribution generalization Fisher F Distribution. defined ratio $$F = \\frac{X/\\nu_1}{Y/\\nu_2}$$ \\(X\\) noncentral \\(\\chi^2\\) random variable \\(\\nu_1\\) degrees freedom non-centrality parameter \\(\\lambda\\), \\(Y\\) central \\(\\chi^2\\) random variable \\(\\nu_2\\) degrees freedom. Accuracy Implementation Notes: distribution implemented terms Noncentral Beta Distribution. Refer Noncentral Beta Distribution documentation details accuracy implementation method.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_f_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Noncentral F Distribution Functions — non_central_f_distribution","text":"","code":"non_central_f_distribution(df1, df2, lambda)  non_central_f_pdf(x, df1, df2, lambda)  non_central_f_lpdf(x, df1, df2, lambda)  non_central_f_cdf(x, df1, df2, lambda)  non_central_f_lcdf(x, df1, df2, lambda)  non_central_f_quantile(p, df1, df2, lambda)"},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_f_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Noncentral F Distribution Functions — non_central_f_distribution","text":"df1 degrees freedom numerator (df1 > 0) df2 degrees freedom denominator (df2 > 0) lambda noncentrality parameter (lambda >= 0) x quantile p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_f_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Noncentral F Distribution Functions — non_central_f_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_f_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Noncentral F Distribution Functions — non_central_f_distribution","text":"","code":"# Noncentral F distribution with df1 = 10, df2 = 10 and noncentrality # parameter 1 dist <- non_central_f_distribution(10, 10, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.1142528 logcdf(dist, 0.5) #> [1] -2.169342 pdf(dist, 0.5) #> [1] 0.5754471 logpdf(dist, 0.5) #> [1] -0.552608 hazard(dist, 0.5) #> [1] 0.6496742 chf(dist, 0.5) #> [1] 0.1213237 mean(dist) #> [1] 1.375 median(dist) #> [1] 1.10075 mode(dist) #> [1] 0.7349843 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.6363179 standard_deviation(dist) #> [1] 1.063113 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 1.130208 skewness(dist) #> [1] 3.609738 kurtosis(dist) #> [1] 51.0825 kurtosis_excess(dist) #> [1] 48.0825  # Convenience functions non_central_f_pdf(1, 5, 2, 1) #> [1] 0.3051418 non_central_f_lpdf(1, 5, 2, 1) #> [1] -1.186979 non_central_f_cdf(1, 5, 2, 1) #> [1] 0.3737987 non_central_f_lcdf(1, 5, 2, 1) #> [1] -0.9840377 non_central_f_quantile(0.5, 5, 2, 1) #> [1] 1.507635"},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_t_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Noncentral T Distribution Functions — non_central_t_distribution","title":"Noncentral T Distribution Functions — non_central_t_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Noncentral T distribution. noncentral T distribution generalization Student's t Distribution. Let \\(X\\) normal distribution mean \\(\\delta\\) variance 1, let \\(\\nu S^2\\) chi-squared distribution degrees freedom \\(\\nu\\). Assume \\(X\\) \\(S^2\\) independent. distribution \\(t_{\\nu}(\\delta) = X/S\\) called noncentral t distribution degrees freedom \\(\\nu\\) noncentrality parameter \\(\\delta\\). gives following PDF: $$f(x;\\nu,\\delta) = \\frac{\\nu^{\\nu/2} e^{-\\delta^2/2}}{\\sqrt{\\pi} \\Gamma(\\nu/2) (\\nu+x^2)^{(\\nu+1)/2}} \\sum_{=0}^{\\infty} \\frac{\\Gamma((\\nu++1)/2)}{!} \\left(\\frac{x\\delta\\sqrt{2}}{\\sqrt{\\nu+x^2}}\\right)^$$ sum involves confluent hypergeometric function. Accuracy Implementation Notes: CDF computed using modification method described Benton Krishnamoorthy (2003), involving incomplete beta function normal CDF. Iteration starts largest Poisson weighting terms proceeds directions. large \\(\\nu\\), distribution approximated Student's t distribution centered \\(\\delta\\).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_t_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Noncentral T Distribution Functions — non_central_t_distribution","text":"","code":"non_central_t_distribution(df, delta)  non_central_t_pdf(x, df, delta)  non_central_t_lpdf(x, df, delta)  non_central_t_cdf(x, df, delta)  non_central_t_lcdf(x, df, delta)  non_central_t_quantile(p, df, delta)"},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_t_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Noncentral T Distribution Functions — non_central_t_distribution","text":"df degrees freedom (df > 0) delta noncentrality parameter (delta >= 0) x quantile p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_t_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Noncentral T Distribution Functions — non_central_t_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/non_central_t_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Noncentral T Distribution Functions — non_central_t_distribution","text":"","code":"# Noncentral T distribution with 5 degrees of freedom and noncentrality parameter 1 dist <- non_central_t_distribution(5, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.3021259 logcdf(dist, 0.5) #> [1] -1.196912 pdf(dist, 0.5) #> [1] 0.3360046 logpdf(dist, 0.5) #> [1] -1.090631 hazard(dist, 0.5) #> [1] 0.4814687 chf(dist, 0.5) #> [1] 0.3597165 mean(dist) #> [1] 1.189416 median(dist) #> [1] 1.052851 mode(dist) #> [1] 0.8781834 range(dist) #> [1] -1.797693e+308  1.797693e+308 quantile(dist, 0.2) #> [1] 0.165306 standard_deviation(dist) #> [1] 1.385144 support(dist) #> [1] -1.797693e+308  1.797693e+308 variance(dist) #> [1] 1.918623 skewness(dist) #> [1] 1.26633 kurtosis(dist) #> [1] 13.32067 kurtosis_excess(dist) #> [1] 10.32067  # Convenience functions non_central_t_pdf(0, 5, 1) #> [1] 0.2302431 non_central_t_lpdf(0, 5, 1) #> [1] -1.46862 non_central_t_cdf(0, 5, 1) #> [1] 0.1586553 non_central_t_lcdf(0, 5, 1) #> [1] -1.841022 non_central_t_quantile(0.5, 5, 1) #> [1] 1.052851"},{"path":"https://andrjohns.github.io/boostmath/reference/normal_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Normal Distribution Functions — normal_distribution","title":"Normal Distribution Functions — normal_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Normal distribution. normal distribution probably well known statistical distribution: also known Gaussian Distribution. normal distribution mean zero standard deviation one known Standard Normal Distribution. Given mean \\(\\mu\\) standard deviation \\(\\sigma\\), PDF: $$f(x;\\mu,\\sigma) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$$ cumulative distribution function given : $$F(x;\\mu,\\sigma) = \\int_{-\\infty}^{x} f(t;\\mu,\\sigma) dt = \\frac{1}{2} \\text{erfc}\\left(\\frac{-(x-\\mu)}{\\sigma\\sqrt{2}}\\right)$$ Accuracy Implementation Notes: normal distribution implemented terms error function, low error rates.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/normal_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normal Distribution Functions — normal_distribution","text":"","code":"normal_distribution(mean = 0, sd = 1)  normal_pdf(x, mean = 0, sd = 1)  normal_lpdf(x, mean = 0, sd = 1)  normal_cdf(x, mean = 0, sd = 1)  normal_lcdf(x, mean = 0, sd = 1)  normal_quantile(p, mean = 0, sd = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/normal_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normal Distribution Functions — normal_distribution","text":"mean mean parameter (default 0) sd standard deviation parameter (default 1) x quantile p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/normal_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normal Distribution Functions — normal_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/normal_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normal Distribution Functions — normal_distribution","text":"","code":"# Normal distribution with mean = 0, sd = 1 dist <- normal_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6914625 logcdf(dist, 0.5) #> [1] -0.3689464 pdf(dist, 0.5) #> [1] 0.3520653 logpdf(dist, 0.5) #> [1] -1.043939 hazard(dist, 0.5) #> [1] 1.141078 chf(dist, 0.5) #> [1] 1.175912 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.8416212 standard_deviation(dist) #> [1] 1 support(dist) #> [1] -Inf  Inf variance(dist) #> [1] 1 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 3 kurtosis_excess(dist) #> [1] 0  # Convenience functions normal_pdf(0) #> [1] 0.3989423 normal_lpdf(0) #> [1] -0.9189385 normal_cdf(0) #> [1] 0.5 normal_lcdf(0) #> [1] -0.6931472 normal_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/reference/number_series.html","id":null,"dir":"Reference","previous_headings":"","what":"Number Series — number_series","title":"Number Series — number_series","text":"Functions compute Bernoulli numbers, Tangent numbers, Prime numbers, Fibonacci numbers. library provides efficient implementations using table lookups smaller indices advanced algorithms larger values. Bernoulli Numbers B(2n): Bernoulli numbers sequence rational numbers useful Taylor series expansions, Euler-Maclaurin formula, Riemann zeta function. bernoulli_b2n(n): Returns (2n)-th Bernoulli number \\(B_{2n}\\). Note odd Bernoulli numbers 0 (except B_1 = -1/2). max_bernoulli_b2n(): Returns largest n \\(B_{2n}\\) can represented return type. unchecked_bernoulli_b2n(n): faster version without overflow checks. bernoulli_b2n(start_index, number_of_bernoullis_b2n): Computes range Bernoulli numbers. Tangent Numbers T(n): Tangent numbers (zag functions) appear Maclaurin series tan(x). tangent_t2n(n): Returns n-th Tangent number. tangent_t2n(start_index, number_of_tangent_t2n): Computes range Tangent numbers. Prime Numbers: Fast table lookup first 10,000 prime numbers. prime(n): Returns n-th prime number (0-indexed, prime(0) = 2). max_prime(): Returns maximum index n supported (currently 10,000). Fibonacci Numbers F(n): Computes Fibonacci numbers defined \\(F_n = F_{n-1} + F_{n-2}\\) \\(F_0 = 0, F_1 = 1\\). fibonacci(n): Returns n-th Fibonacci number. unchecked_fibonacci(n): faster version without overflow checks. Implementation uses table lookup small values iterative algorithms larger values.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/number_series.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number Series — number_series","text":"","code":"bernoulli_b2n(n = NULL, start_index = NULL, number_of_bernoullis_b2n = NULL)  max_bernoulli_b2n()  unchecked_bernoulli_b2n(n)  tangent_t2n(n = NULL, start_index = NULL, number_of_tangent_t2n = NULL)  prime(n)  max_prime()  fibonacci(n)  unchecked_fibonacci(n)"},{"path":"https://andrjohns.github.io/boostmath/reference/number_series.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number Series — number_series","text":"n Index number compute (must non-negative integer). start_index starting index computing range numbers. number_of_bernoullis_b2n number Bernoulli numbers compute range. number_of_tangent_t2n number Tangent numbers compute range.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/number_series.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number Series — number_series","text":"single numeric integer value scalar inputs, vector range computations. max_ functions, returns maximum supported index.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/number_series.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number Series — number_series","text":"","code":"if (FALSE) { # \\dontrun{ # 10th Bernoulli number B_20 (index is doubled) bernoulli_b2n(10) # Maximum supported index for Bernoulli numbers max_bernoulli_b2n() # Range of Bernoulli numbers B_0, B_2, ..., B_18 (10 numbers) bernoulli_b2n(start_index = 0, number_of_bernoullis_b2n = 10)  # 10th Tangent number tangent_t2n(10)  # 10th Prime number (0-indexed) prime(10)  # 10th Fibonacci number fibonacci(10) } # }"},{"path":"https://andrjohns.github.io/boostmath/reference/numerical_differentiation.html","id":null,"dir":"Reference","previous_headings":"","what":"Numerical Differentiation — numerical_differentiation","title":"Numerical Differentiation — numerical_differentiation","text":"Functions numerical differentiation using finite difference complex step methods. Finite Difference Derivative: Calculates finite-difference approximation derivative function \\(f\\) point \\(x\\). problem ill-conditioned: truncation error (\\(O(h^k)\\)) decreases \\(h\\), roundoff error increases. function balances errors automatically. default order 6. Requires function differentiable (order requested). Complex Step Derivative: Computes derivative real-valued function \\(f(x)\\) using complex step approximation: $$f'(x) \\approx \\frac{\\Im(f(x + ih))}{h}$$ method avoids subtractive cancellation error inherent finite differences extremely accurate. However, requires \\(f\\) holomorphic function (complex-differentiable) takes real values real arguments. Ideally, function f able accept complex argument.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/numerical_differentiation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numerical Differentiation — numerical_differentiation","text":"","code":"finite_difference_derivative(f, x, order = 1)  complex_step_derivative(f, x)"},{"path":"https://andrjohns.github.io/boostmath/reference/numerical_differentiation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numerical Differentiation — numerical_differentiation","text":"f function differentiate. accept single numeric/complex value return single numeric/complex value. x point evaluate derivative. order order accuracy finite difference method. Can 1, 2, 4, 6, 8. Default 1.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/numerical_differentiation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Numerical Differentiation — numerical_differentiation","text":"approximate value derivative point x.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/numerical_differentiation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Numerical Differentiation — numerical_differentiation","text":"","code":"# Finite difference derivative of sin(x) at pi/4 finite_difference_derivative(sin, pi / 4) #> [1] 0.7071068  # Complex step derivative of exp(x) at 1.7 (Requires f to handle complex input ideally) # Note: In pure R, `exp` handles complex numbers automatically. complex_step_derivative(exp, 1.7) #> [1] 5.473947"},{"path":"https://andrjohns.github.io/boostmath/reference/numerical_integration.html","id":null,"dir":"Reference","previous_headings":"","what":"Numerical Integration — numerical_integration","title":"Numerical Integration — numerical_integration","text":"Functions numerical integration using Trapezoidal, Gauss-Legendre, Gauss-Kronrod methods. Trapezoidal Quadrature: Calculates integral function \\(f\\) using trapezoidal rule. integrand periodic integrated full period, trapezoidal rule converges faster power step size \\(h\\) (exponential convergence). non-periodic twice continuously differentiable functions, error \\(O(h^2)\\). Checks convergence halving interval tolerance met max_refinements reached. Useful periodic functions, bump functions, bell-shaped integrals infinite intervals. Gauss-Legendre Quadrature: Performs \"one-shot\" non-adaptive integration \\((, b)\\) using fixed number points. efficient smooth \"bell-like\" functions functions rapidly convergent power series. provide error estimate. Gauss-Kronrod Quadrature: adaptive extension Gaussian quadrature. Adds \\(n+1\\) nodes (Kronrod points) \\(n\\)-point Gaussian quadrature provide posteriori error estimate (\\(O(h^{3n+1})\\) vs \\(O(h^{2n-1})\\)). Preserves exponential convergence smooth functions. Best suited smooth functions end-point singularities.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/numerical_integration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numerical Integration — numerical_integration","text":"","code":"trapezoidal(f, a, b, tol = sqrt(.Machine$double.eps), max_refinements = 12)  gauss_legendre(f, a, b, points = 7)  gauss_kronrod(   f,   a,   b,   points = 15,   max_depth = 15,   tol = sqrt(.Machine$double.eps) )"},{"path":"https://andrjohns.github.io/boostmath/reference/numerical_integration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numerical Integration — numerical_integration","text":"f function integrate. accept single numeric value return single numeric value. lower limit integration. b upper limit integration. tol tolerance approximation. trapezoidal, default sqrt(.Machine$double.eps). Gauss-Kronrod, default sqrt(.Machine$double.eps). max_refinements maximum number refinements apply. Default 12. points number evaluation points use Gauss-Legendre Gauss-Kronrod quadrature. max_depth Sets maximum number interval splittings Gauss-Kronrod permitted stopping. Set zero non-adaptive quadrature.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/numerical_integration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Numerical Integration — numerical_integration","text":"single numeric value computed integral.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/numerical_integration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Numerical Integration — numerical_integration","text":"","code":"# Trapezoidal rule integration of sin(x) from 0 to pi (Periodic over 0 to 2*pi) trapezoidal(sin, 0, pi) #> [1] 2  # Gauss-Legendre integration of exp(x) from 0 to 1 gauss_legendre(exp, 0, 1, points = 7) #> [1] 1.718282  # Adaptive Gauss-Kronrod integration of log(x) from 1 to 2 gauss_kronrod(log, 1, 2, points = 15, max_depth = 10) #> [1] 0.3862944"},{"path":"https://andrjohns.github.io/boostmath/reference/ooura_fourier_integrals.html","id":null,"dir":"Reference","previous_headings":"","what":"Ooura Fourier Integrals — ooura_fourier_integrals","title":"Ooura Fourier Integrals — ooura_fourier_integrals","text":"Computes Fourier sine cosine integrals using Ooura's robust double exponential method (1999). methods designed handle oscillatory integrals problematic standard quadrature. Ooura Fourier Sine: Computes integral: $$\\int_0^\\infty f(t) \\sin(\\omega t) dt$$ Ooura Fourier Cosine: Computes integral: $$\\int_0^\\infty f(t) \\cos(\\omega t) dt$$","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/ooura_fourier_integrals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ooura Fourier Integrals — ooura_fourier_integrals","text":"","code":"ooura_fourier_sin(   f,   omega = 1,   relative_error_tolerance = sqrt(.Machine$double.eps),   levels = 8 )  ooura_fourier_cos(   f,   omega = 1,   relative_error_tolerance = sqrt(.Machine$double.eps),   levels = 8 )"},{"path":"https://andrjohns.github.io/boostmath/reference/ooura_fourier_integrals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ooura Fourier Integrals — ooura_fourier_integrals","text":"f function integrate. accept single numeric value return single numeric value. omega frequency parameter \\(\\omega\\) sine cosine term. relative_error_tolerance relative error tolerance approximation. Default sqrt(.Machine$double.eps). levels number levels refinement apply. Default 8.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/ooura_fourier_integrals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ooura Fourier Integrals — ooura_fourier_integrals","text":"single numeric value computed Fourier sine cosine integral.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/ooura_fourier_integrals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ooura Fourier Integrals — ooura_fourier_integrals","text":"method precomputes nodes weights efficiency. Convergence depends position poles integrand complex plane. poles close real axis, convergence may slow.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/ooura_fourier_integrals.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Ooura Fourier Integrals — ooura_fourier_integrals","text":"Ooura, Takuya, Masatake Mori. \"robust double exponential formula Fourier-type integrals.\" Journal computational applied mathematics 112.1-2 (1999): 229-241.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/ooura_fourier_integrals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ooura Fourier Integrals — ooura_fourier_integrals","text":"","code":"# Fourier sine integral of 1/x -> integral convergent to pi/2 approx # sin(x)/x from 0 to Inf is pi/2. Here we integrate 1/x * sin(1*x). ooura_fourier_sin(function(x) { 1 / x }, omega = 1) #> [1] 1.570796 #> attr(,\"relative_error\") #> [1] 1.265522e-11  # Fourier cosine integral of 1/(x^2 + 1) * cos(x) # Expected value is pi/(2*e) approx 0.57786 ooura_fourier_cos(function(x) { 1/ (x * x + 1) }, omega = 1) #> [1] 0.5778637 #> attr(,\"relative_error\") #> [1] 6.417739e-09"},{"path":"https://andrjohns.github.io/boostmath/reference/owens_t.html","id":null,"dir":"Reference","previous_headings":"","what":"Owens T Function — owens_t","title":"Owens T Function — owens_t","text":"Computes Owen's T function T(h, ), gives probability event (X > h 0 < Y < *X) X Y independent standard normal random variables. Geometric Interpretation: positive h , T(h, ) represents volume uncorrelated bivariate normal distribution zero means unit variances region bounded y = ax, y = 0, x = h. Special Cases: T(h, 0) = 0 T(0, ) = (1/2pi) arctan() T(h, 1) = (1/2) Phi(h) [1 - Phi(h)], Phi standard normal CDF T(h, Inf) = Phi(|h|) Applications: Owen's T function essential computing skew normal distribution probabilities bivariate multivariate normal distributions. appears statistical inference, power calculations, various probability computations involving correlated normal variables.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/owens_t.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Owens T Function — owens_t","text":"","code":"owens_t(h, a)"},{"path":"https://andrjohns.github.io/boostmath/reference/owens_t.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Owens T Function — owens_t","text":"h first argument Owens T function (boundary parameter) second argument Owens T function (slope parameter)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/owens_t.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Owens T Function — owens_t","text":"value Owens T function (h, ).","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/owens_t.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Owens T Function — owens_t","text":"","code":"# Owens T Function owens_t(1, 0.5) #> [1] 0.04306469"},{"path":"https://andrjohns.github.io/boostmath/reference/pareto_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Pareto Distribution Functions — pareto_distribution","title":"Pareto Distribution Functions — pareto_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Pareto distribution. Pareto distribution continuous distribution often describes larger compared smaller. classic example 80% wealth owned 20% population. probability density function (PDF): $$f(x; \\alpha, \\beta) = \\frac{\\alpha\\beta^\\alpha}{x^{\\alpha+1}}$$ shape parameter \\(\\alpha > 0\\), scale parameter \\(\\beta > 0\\), \\(x \\ge \\beta\\). \\(x < \\beta\\), pdf zero. Accuracy Implementation Notes: Pareto distribution implemented terms standard library exp functions plus expm1 small errors, usually epsilon.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/pareto_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pareto Distribution Functions — pareto_distribution","text":"","code":"pareto_distribution(scale = 1, shape = 1)  pareto_pdf(x, scale = 1, shape = 1)  pareto_lpdf(x, scale = 1, shape = 1)  pareto_cdf(x, scale = 1, shape = 1)  pareto_lcdf(x, scale = 1, shape = 1)  pareto_quantile(p, scale = 1, shape = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/pareto_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pareto Distribution Functions — pareto_distribution","text":"scale scale parameter (default 1) shape shape parameter (default 1) x quantile p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/pareto_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pareto Distribution Functions — pareto_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/pareto_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pareto Distribution Functions — pareto_distribution","text":"","code":"# Pareto distribution with scale = 10, shape = 5 dist <- pareto_distribution(10, 5) # Apply generic functions cdf(dist, 0.5) #> [1] 0 logcdf(dist, 0.5) #> [1] -Inf pdf(dist, 0.5) #> [1] 0 logpdf(dist, 0.5) #> [1] -Inf hazard(dist, 0.5) #> [1] 0 chf(dist, 0.5) #> [1] 0 mean(dist) #> [1] 12.5 median(dist) #> [1] 11.48698 mode(dist) #> [1] 10 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 10.4564 standard_deviation(dist) #> [1] 3.227486 support(dist) #> [1]  1.000000e+01 1.797693e+308 variance(dist) #> [1] 10.41667 skewness(dist) #> [1] 4.64758 kurtosis(dist) #> [1] 73.8 kurtosis_excess(dist) #> [1] 70.8  # Convenience functions pareto_pdf(1) #> [1] 1 pareto_lpdf(1) #> [1] 0 pareto_cdf(1) #> [1] 0 pareto_lcdf(1) #> [1] -Inf pareto_quantile(0.5) #> [1] 2"},{"path":"https://andrjohns.github.io/boostmath/reference/pchip.html","id":null,"dir":"Reference","previous_headings":"","what":"PCHIP Interpolator — pchip","title":"PCHIP Interpolator — pchip","text":"PCHIP (Piecewise Cubic Hermite Interpolating Polynomial) interpolant takes non-equispaced data interpolates via cubic Hermite polynomials whose slopes chosen preserve monotonicity. Details: interpolant C1 evaluation O(log N) complexity. See Fritsch Carlson details.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/pchip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PCHIP Interpolator — pchip","text":"","code":"pchip(x, y, left_endpoint_derivative = NULL, right_endpoint_derivative = NULL)"},{"path":"https://andrjohns.github.io/boostmath/reference/pchip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PCHIP Interpolator — pchip","text":"x Numeric vector abscissas (x-coordinates). y Numeric vector ordinates (y-coordinates). left_endpoint_derivative Optional numeric value derivative left endpoint. right_endpoint_derivative Optional numeric value derivative right endpoint.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/pchip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PCHIP Interpolator — pchip","text":"object class pchip methods: interpolate(xi): Evaluate interpolator point xi. prime(xi): Evaluate derivative interpolator point xi. push_back(x, y): Add new control point","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/pchip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PCHIP Interpolator — pchip","text":"","code":"x <- c(0, 1, 2, 3) y <- c(0, 1, 0, 1) interpolator <- pchip(x, y) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.625 interpolator$prime(xi) #> [1] 1.25 interpolator$push_back(4, 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/poisson_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Poisson Distribution Functions — poisson_distribution","title":"Poisson Distribution Functions — poisson_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Poisson distribution. Poisson distribution expresses probability number events (failures, arrivals, occurrences ...) occurring fixed period time, provided events occur known mean rate \\(\\lambda\\) (events/time), independent time since last event. Probability Mass Function: $$f(k;\\lambda) = \\frac{\\lambda^k e^{-\\lambda}}{k!}$$ \\(k\\) events, expected number events \\(\\lambda\\). Accuracy Implementation Notes: Poisson distribution implemented terms incomplete gamma functions (gamma_p gamma_q) low error rates. quantile function default return integer result rounded outwards ensure X% quantile requested, least requested coverage present central region, requested coverage present tails.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/poisson_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Poisson Distribution Functions — poisson_distribution","text":"","code":"poisson_distribution(lambda = 1)  poisson_pdf(x, lambda = 1)  poisson_lpdf(x, lambda = 1)  poisson_cdf(x, lambda = 1)  poisson_lcdf(x, lambda = 1)  poisson_quantile(p, lambda = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/poisson_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Poisson Distribution Functions — poisson_distribution","text":"lambda rate parameter (default 1) x quantile p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/poisson_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Poisson Distribution Functions — poisson_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/poisson_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Poisson Distribution Functions — poisson_distribution","text":"","code":"# Poisson distribution with lambda = 1 dist <- poisson_distribution(1) # Apply generic functions cdf(dist, 5) #> [1] 0.9994058 logcdf(dist, 5) #> [1] -0.0005943614 pdf(dist, 5) #> [1] 0.003065662 logpdf(dist, 5) #> [1] -5.787492 hazard(dist, 5) #> [1] 5.159442 chf(dist, 5) #> [1] 7.42832 mean(dist) #> [1] 1 median(dist) #> [1] 1 mode(dist) #> [1] 1 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0 standard_deviation(dist) #> [1] 1 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 1 skewness(dist) #> [1] 1 kurtosis(dist) #> [1] 4 kurtosis_excess(dist) #> [1] 1  # Convenience functions poisson_pdf(0, 1) #> [1] 0.3678794 poisson_lpdf(0, 1) #> [1] -1 poisson_cdf(0, 1) #> [1] 0.3678794 poisson_lcdf(0, 1) #> [1] -1 poisson_quantile(0.5, 1) #> [1] 1"},{"path":"https://andrjohns.github.io/boostmath/reference/polynomial_root_finding.html","id":null,"dir":"Reference","previous_headings":"","what":"Polynomial Root-Finding — polynomial_root_finding","title":"Polynomial Root-Finding — polynomial_root_finding","text":"Functions finding roots polynomials degree 2, 3, 4 (quadratic, cubic, quartic). Quadratic Roots: Solves \\(ax^2 + bx + c = 0\\). Returns real roots. roots complex, behavior depends implementation (typically NaN real-valued interface). Cubic Roots: Solves \\(ax^3 + bx^2 + cx + d = 0\\). Returns real roots. Quartic Roots: Solves \\(ax^4 + bx^3 + cx^2 + dx + e = 0\\). Returns real roots.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/polynomial_root_finding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Polynomial Root-Finding — polynomial_root_finding","text":"","code":"quadratic_roots(a, b, c)  cubic_roots(a, b, c, d)  cubic_root_residual(a, b, c, d, root)  cubic_root_condition_number(a, b, c, d, root)  quartic_roots(a, b, c, d, e)"},{"path":"https://andrjohns.github.io/boostmath/reference/polynomial_root_finding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Polynomial Root-Finding — polynomial_root_finding","text":"Coefficient highest degree term. b Coefficient second highest degree term. c Coefficient third highest degree term (constant quadratic). d Coefficient fourth highest degree term (constant cubic). root root evaluate residual condition number . e Constant term quartic.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/polynomial_root_finding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Polynomial Root-Finding — polynomial_root_finding","text":"numeric vector containing real roots polynomial.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/polynomial_root_finding.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Polynomial Root-Finding — polynomial_root_finding","text":"functions use analytic formulas possible numerically stable implementations avoid catastrophic cancellation.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/polynomial_root_finding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Polynomial Root-Finding — polynomial_root_finding","text":"","code":"# Quadratic: x^2 - 3x + 2 = 0 -> Roots: 1, 2 quadratic_roots(1, -3, 2) #> [1] 1 2  # Cubic: x^3 - 6x^2 + 11x - 6 = 0 -> Roots: 1, 2, 3 cubic_roots(1, -6, 11, -6) #> [1] 1 2 3  # Quartic: x^4 - 10x^3 + 35x^2 - 50x + 24 = 0 -> Roots: 1, 2, 3, 4 quartic_roots(1, -10, 35, -50, 24) #> [1] 1 2 3 4  # Residual and Condition Number cubic_root_residual(1, -6, 11, -6, 1) #> [1] 0.000000e+00 1.110223e-14 cubic_root_condition_number(1, -6, 11, -6, 1) #> [1] 12"},{"path":"https://andrjohns.github.io/boostmath/reference/quintic_hermite.html","id":null,"dir":"Reference","previous_headings":"","what":"Quintic Hermite Interpolator — quintic_hermite","title":"Quintic Hermite Interpolator — quintic_hermite","text":"quintic Hermite interpolator takes list possibly non-uniformly spaced abscissas, ordinates, velocities accelerations. Applications: constructs quintic interpolating polynomial segments. useful taking solution skeletons ODE steppers turning continuous function. interpolant C2 evaluation O(log N) complexity.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/quintic_hermite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quintic Hermite Interpolator — quintic_hermite","text":"","code":"quintic_hermite(x, y, dydx, d2ydx2)"},{"path":"https://andrjohns.github.io/boostmath/reference/quintic_hermite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quintic Hermite Interpolator — quintic_hermite","text":"x Numeric vector abscissas (x-coordinates). y Numeric vector ordinates (y-coordinates). dydx Numeric vector first derivatives (slopes) point. d2ydx2 Numeric vector second derivatives point.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/quintic_hermite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quintic Hermite Interpolator — quintic_hermite","text":"object class quintic_hermite methods: interpolate(xi): Evaluate interpolator point xi. prime(xi): Evaluate derivative interpolator point xi. double_prime(xi): Evaluate second derivative interpolator point xi. push_back(x, y, dydx, d2ydx2): Add new control point interpolator. domain(): Get domain interpolator.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/quintic_hermite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quintic Hermite Interpolator — quintic_hermite","text":"","code":"x <- c(0, 1, 2) y <- c(0, 1, 0) dydx <- c(1, 0, -1) d2ydx2 <- c(0, -1, 0) interpolator <- quintic_hermite(x, y, dydx, d2ydx2) xi <- 0.5 interpolator$interpolate(xi) #> [1] 0.640625 interpolator$prime(xi) #> [1] 1.40625 interpolator$double_prime(xi) #> [1] -1.25 interpolator$push_back(3, 0, 1, 0) #> NULL interpolator$domain() #> [1] 0 3"},{"path":"https://andrjohns.github.io/boostmath/reference/rayleigh_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Rayleigh Distribution Functions — rayleigh_distribution","title":"Rayleigh Distribution Functions — rayleigh_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Rayleigh distribution. Rayleigh distribution continuous distribution. often used two orthogonal components absolute value, example, wind velocity direction may combined yield wind speed, real imaginary components may absolute values Rayleigh distributed. probability density function (PDF): $$f(x; \\sigma) = \\frac{x}{\\sigma^2} e^{-x^2 / (2\\sigma^2)}$$ \\(\\sigma > 0\\) \\(x > 0\\). Accuracy Implementation Notes: Rayleigh distribution implemented terms standard library sqrt exp low error rates.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/rayleigh_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rayleigh Distribution Functions — rayleigh_distribution","text":"","code":"rayleigh_distribution(sigma = 1)  rayleigh_pdf(x, sigma = 1)  rayleigh_lpdf(x, sigma = 1)  rayleigh_cdf(x, sigma = 1)  rayleigh_lcdf(x, sigma = 1)  rayleigh_quantile(p, sigma = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/rayleigh_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rayleigh Distribution Functions — rayleigh_distribution","text":"sigma scale parameter (default 1) x quantile p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/rayleigh_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rayleigh Distribution Functions — rayleigh_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/rayleigh_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rayleigh Distribution Functions — rayleigh_distribution","text":"","code":"# Rayleigh distribution with sigma = 1 dist <- rayleigh_distribution(1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.1175031 logcdf(dist, 0.5) #> [1] -2.141291 pdf(dist, 0.5) #> [1] 0.4412485 logpdf(dist, 0.5) #> [1] -0.8181472 hazard(dist, 0.5) #> [1] 0.5 chf(dist, 0.5) #> [1] 0.125 mean(dist) #> [1] 1.253314 median(dist) #> [1] 1.17741 mode(dist) #> [1] 1 range(dist) #> [1]   0 Inf quantile(dist, 0.2) #> [1] 0.6680472 standard_deviation(dist) #> [1] 0.6551364 support(dist) #> [1]  0.000000e+00 1.797693e+308 variance(dist) #> [1] 0.4292037 skewness(dist) #> [1] 0.6311107 kurtosis(dist) #> [1] 3.245089 kurtosis_excess(dist) #> [1] 0.2450893  # Convenience functions rayleigh_pdf(1) #> [1] 0.6065307 rayleigh_lpdf(1) #> [1] -0.5 rayleigh_cdf(1) #> [1] 0.3934693 rayleigh_lcdf(1) #> [1] -0.9327521 rayleigh_quantile(0.5) #> [1] 1.17741"},{"path":"https://andrjohns.github.io/boostmath/reference/rootfinding_and_minimisation.html","id":null,"dir":"Reference","previous_headings":"","what":"Root-Finding and Minimisation — rootfinding_and_minimisation","title":"Root-Finding and Minimisation — rootfinding_and_minimisation","text":"Functions finding roots equations minimizing functions using various numerical methods. Root Finding Without Derivatives: methods require bracket (interval \\([, b]\\) function opposite signs) guess. Bisection (bisect): robust method repeatedly subdivides interval. Guaranteed converge slowly (linear convergence). TOMS 748 (toms748_solve): asymptotically efficient algorithm (Alefeld, Potra, Shi) combines interpolation bisection. higher-order convergence often optimal smooth functions. Bracket Solve (bracket_and_solve_root): convenience wrapper attempts find bracket around guess solves using TOMS 748. Root Finding Derivatives: methods require user provide derivatives function. Newton-Raphson (newton_raphson_iterate): Second-order convergence. Requires \\(f(x)\\) \\(f'(x)\\). Halley's Method (halley_iterate): Third-order convergence. Requires \\(f(x)\\), \\(f'(x)\\), \\(f''(x)\\). Schroder's Method (schroder_iterate): Third-order convergence. Similar Halley's method robust ensuring quadratic convergence multiple roots. Minimization: Brent's Method (brent_find_minima): Finds minimum function given interval. hybrid method using combination golden section search quadratic interpolation.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/rootfinding_and_minimisation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Root-Finding and Minimisation — rootfinding_and_minimisation","text":"","code":"bisect(   f,   lower,   upper,   digits = .Machine$double.digits,   max_iter = .Machine$integer.max )  bracket_and_solve_root(   f,   guess,   factor,   rising,   digits = .Machine$double.digits,   max_iter = .Machine$integer.max )  toms748_solve(   f,   lower,   upper,   digits = .Machine$double.digits,   max_iter = .Machine$integer.max )  newton_raphson_iterate(   f,   guess,   lower,   upper,   digits = .Machine$double.digits,   max_iter = .Machine$integer.max )  halley_iterate(   f,   guess,   lower,   upper,   digits = .Machine$double.digits,   max_iter = .Machine$integer.max )  schroder_iterate(   f,   guess,   lower,   upper,   digits = .Machine$double.digits,   max_iter = .Machine$integer.max )  brent_find_minima(   f,   lower,   upper,   digits = .Machine$double.digits,   max_iter = .Machine$integer.max )"},{"path":"https://andrjohns.github.io/boostmath/reference/rootfinding_and_minimisation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Root-Finding and Minimisation — rootfinding_and_minimisation","text":"f function find root minimise. -derivative methods: function returning single numeric value. Newton-Raphson: function returning vector c(f(x), f'(x)). Halley/Schroder: function returning vector c(f(x), f'(x), f''(x)). Minimization: function returning single numeric value. lower lower bound interval search. upper upper bound interval search. digits number significant digits root minimum found. Default double precision. max_iter maximum number iterations perform. guess numeric value guess root. factor Size steps take searching root (bracket_and_solve_root). rising TRUE, function assumed rising (bracket_and_solve_root).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/rootfinding_and_minimisation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Root-Finding and Minimisation — rootfinding_and_minimisation","text":"list containing root minimum value, value function point, number iterations performed.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/rootfinding_and_minimisation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Root-Finding and Minimisation — rootfinding_and_minimisation","text":"","code":"# --- Root Finding Without Derivatives --- # Bisection for x^2 - 2 = 0 f_bi <- function(x) x^2 - 2 bisect(f_bi, lower = 0, upper = 2) #> $lower #> [1] 1.414214 #>  #> $upper #> [1] 1.414214 #>  #> $iterations #> [1] 54 #>   # TOMS 748 for x^2 - 2 = 0 toms748_solve(f_bi, lower = 0, upper = 2) #> $lower #> [1] 1.414214 #>  #> $upper #> [1] 1.414214 #>  #> $iterations #> [1] 9 #>   # Bracket and Solve bracket_and_solve_root(f_bi, guess = 1, factor = 2, rising = TRUE) #> $lower #> [1] 1.414214 #>  #> $upper #> [1] 1.414214 #>  #> $iterations #> [1] 10 #>   # --- Root Finding With Derivatives --- # Newton-Raphson: Need f(x) and f'(x) # x^2 - 2 = 0  => f(x) = x^2 - 2, f'(x) = 2x f_newton <- function(x) c(x^2 - 2, 2 * x) newton_raphson_iterate(f_newton, guess = 1, lower = 0, upper = 2) #> [1] 1.414214 #> attr(,\"iterations\") #> [1] 6  # Halley/Schroder: Need f(x), f'(x), f''(x) # x^2 - 2 = 0  => f''(x) = 2 f_halley <- function(x) c(x^2 - 2, 2 * x, 2) halley_iterate(f_halley, guess = 1, lower = 0, upper = 2) #> [1] 1.414214 #> attr(,\"iterations\") #> [1] 4 schroder_iterate(f_halley, guess = 1, lower = 0, upper = 2) #> [1] 1.414214 #> attr(,\"iterations\") #> [1] 5  # --- Minimization --- # Find minimum of (x-2)^2 + 1 f_min <- function(x) (x - 2)^2 + 1 brent_find_minima(f_min, lower = 0, upper = 4) #> $minimum #> [1] 2 #>  #> $value #> [1] 1 #>  #> $iterations #> [1] 5 #>"},{"path":"https://andrjohns.github.io/boostmath/reference/runs_tests.html","id":null,"dir":"Reference","previous_headings":"","what":"Runs Tests — runs_tests","title":"Runs Tests — runs_tests","text":"runs test statistical test checks randomness hypothesis two-valued data sequence. can used test hypothesis elements sequence mutually independent. Runs Median: Determines sequence random observing number consecutive values exceed () median sequence. Values equal median ignored. expected number runs variance calculated according NIST standards derive test statistic p-value. function calculates median internally. Runs Threshold: similar median test, uses user-specified threshold instead calculated median. efficient median already known different threshold required.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/runs_tests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Runs Tests — runs_tests","text":"","code":"runs_above_and_below_threshold(v, threshold)  runs_above_and_below_median(v)"},{"path":"https://andrjohns.github.io/boostmath/reference/runs_tests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Runs Tests — runs_tests","text":"v numeric vector containing sequence test. threshold single numeric value serve threshold test (runs_above_and_below_threshold).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/runs_tests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Runs Tests — runs_tests","text":"two-element numeric vector: first element t-statistic. second element p-value (two-sided).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/runs_tests.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Runs Tests — runs_tests","text":"test statistic approximated standard normal distribution extract p-value. p-value small (e.g., < 0.05), null hypothesis randomness rejected.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/runs_tests.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Runs Tests — runs_tests","text":"NIST/SEMATECH e-Handbook Statistical Methods, \"Runs Test Detecting Non-randomness\", https://www.itl.nist.gov/div898/handbook/eda/section3/eda35d.htm","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/runs_tests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Runs Tests — runs_tests","text":"","code":"# Runs Above and Below Threshold with a known threshold v <- c(1, 2, 3, 4, 5, 1, 2, 3, 4, 5) runs_above_and_below_threshold(v, threshold = 3) #> [1] -0.7637626  0.4450087  # Runs Above and Below Median (calculates median = 3 internally) runs_above_and_below_median(v) #> [1] -0.7637626  0.4450087  # Example of a non-random sequence (fewer runs than expected) v_non_random <- c(rep(1, 5), rep(10, 5)) runs_above_and_below_median(v_non_random) #> [1] -2.683281573  0.007290358"},{"path":"https://andrjohns.github.io/boostmath/reference/saspoint5_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"S\\(\\alpha\\)S Point5 Distribution Functions — saspoint5_distribution","title":"S\\(\\alpha\\)S Point5 Distribution Functions — saspoint5_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function S\\(\\alpha\\)S Point5 distribution. S\\(\\alpha\\)S Point5 distribution special case stable distribution shape parameter \\(\\alpha=1/2\\), \\(\\beta=0\\). probability density function (PDF): $$f(x; \\mu, \\gamma) = \\frac{1}{\\sqrt{2\\pi}} x^{-3/2} e^{-\\frac{1}{2x}}$$ (Note: boost documentation reference shows standard form, generalised location \\(\\mu\\) scale \\(\\gamma\\)). distribution heavier tails Cauchy distribution. Note S\\(\\alpha\\)S Point5 distribution defined mean standard deviation. Accuracy Implementation Notes: error within 4 epsilon.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/saspoint5_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"S\\(\\alpha\\)S Point5 Distribution Functions — saspoint5_distribution","text":"","code":"saspoint5_distribution(location = 0, scale = 1)  saspoint5_pdf(x, location = 0, scale = 1)  saspoint5_lpdf(x, location = 0, scale = 1)  saspoint5_cdf(x, location = 0, scale = 1)  saspoint5_lcdf(x, location = 0, scale = 1)  saspoint5_quantile(p, location = 0, scale = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/saspoint5_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"S\\(\\alpha\\)S Point5 Distribution Functions — saspoint5_distribution","text":"location location parameter (default 0) scale scale parameter (default 1) x quantile p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/saspoint5_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"S\\(\\alpha\\)S Point5 Distribution Functions — saspoint5_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/saspoint5_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"S\\(\\alpha\\)S Point5 Distribution Functions — saspoint5_distribution","text":"","code":"# SaS Point5 distribution with location 0 and scale 1 dist <- saspoint5_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6686904 logcdf(dist, 0.5) #> [1] -0.402434 pdf(dist, 0.5) #> [1] 0.1707624 logpdf(dist, 0.5) #> [1] -1.767482 hazard(dist, 0.5) #> [1] 0.5154165 chf(dist, 0.5) #> [1] 1.104702 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -2.397479 support(dist) #> [1] -Inf  Inf  # Convenience functions saspoint5_pdf(3) #> [1] 0.02379919 saspoint5_lpdf(3) #> [1] -3.738104 saspoint5_cdf(3) #> [1] 0.8164545 saspoint5_lcdf(3) #> [1] -0.2027841 saspoint5_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/reference/signal_statistics.html","id":null,"dir":"Reference","previous_headings":"","what":"Signal Statistics — signal_statistics","title":"Signal Statistics — signal_statistics","text":"Functions computing statistics commonly used signal analysis, sparsity measures Signal--Noise Ratio (SNR) estimators. Absolute Gini Coefficient: Gini coefficient measure sparsity signal (expansion basis). absolute_gini_coefficient: Computes population Gini coefficient. sample_absolute_gini_coefficient: Computes sample Gini coefficient. Gini coefficient 0 implies every element equal magnitude (least sparse). Gini coefficient 1 implies one element non-zero (sparse). Hoyer Sparsity: measure sparsity based ratio L1 L2 norms: $$H(v) = \\frac{\\sqrt{N} - \\frac{\\|v\\|_1}{\\|v\\|_2}}{\\sqrt{N} - 1}$$ Returns 1 maximum sparsity (one non-zero element) 0 minimum sparsity (elements equal). Oracle SNR: Computes Signal--Noise Ratio (SNR) true signal known (Oracle). oracle_snr: \\(\\frac{\\|s\\|^2}{\\|s - x\\|^2}\\) \\(s\\) signal \\(x\\) noisy signal. oracle_snr_db: Returns SNR decibels (dB): \\(10 \\log_{10}(\\text{SNR})\\). M2M4 SNR Estimator: \"blind\" estimator (requires clean signal reference) using M2M4 property (uses 2nd 4th moments). Useful \"-service\" estimation. m2m4_snr_estimator: Returns estimated SNR ratio. m2m4_snr_estimator_db: Returns estimated SNR dB. Works best SNR -3 dB 15 dB. Requires assumptions signal noise kurtosis (default signal=1, noise=3 Gaussian).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/signal_statistics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Signal Statistics — signal_statistics","text":"","code":"absolute_gini_coefficient(x)  sample_absolute_gini_coefficient(x)  hoyer_sparsity(x)  oracle_snr(signal, noisy_signal)  oracle_snr_db(signal, noisy_signal)  m2m4_snr_estimator(noisy_signal, signal_kurtosis = 1, noise_kurtosis = 3)  m2m4_snr_estimator_db(noisy_signal, signal_kurtosis = 1, noise_kurtosis = 3)"},{"path":"https://andrjohns.github.io/boostmath/reference/signal_statistics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Signal Statistics — signal_statistics","text":"x numeric vector representing signal coefficients. signal numeric vector representing true (clean) signal. noisy_signal numeric vector representing signal noise. signal_kurtosis Kurtosis signal (M2M4). Default 1 (e.g., constant amplitude). noise_kurtosis Kurtosis noise (M2M4). Default 3 (Gaussian noise).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/signal_statistics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Signal Statistics — signal_statistics","text":"numeric value representing computed statistic.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/signal_statistics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Signal Statistics — signal_statistics","text":"Hurley, N., & Rickard, S. (2009). Comparing measures sparsity. IEEE Transactions Information Theory, 55(10), 4723-4741. Pauluzzi, D. R., & Beaulieu, N. C. (2000). comparison SNR estimation techniques AWGN channel. IEEE Transactions Communications, 48(10), 1681-1691.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/signal_statistics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Signal Statistics — signal_statistics","text":"","code":"# --- Sparsity Measures ---  # Gini Coefficient vec <- c(1, 0, 0, 0) # High sparsity -> High Gini coefficient sample_absolute_gini_coefficient(vec) #> [1] 1  vec_uniform <- c(1, 1, 1, 1) # Low sparsity -> Low Gini coefficient absolute_gini_coefficient(vec_uniform) #> [1] 0  # Hoyer Sparsity hoyer_sparsity(vec)      # Returns 1 #> [1] 1 hoyer_sparsity(vec_uniform) # Returns 0 #> [1] 0  # --- SNR Estimation ---  s <- sin(seq(0, 10, length.out = 100)) n <- rnorm(100, sd = 0.5) x <- s + n  # Oracle SNR (Known signal) oracle_snr_db(s, x) #> [1] 1.994808  # M2M4 Blind SNR Estimation # Assuming signal kurtosis = 1.5 (sinusoid) and Gaussian noise (kurtosis = 3) m2m4_snr_estimator_db(x, signal_kurtosis = 1.5, noise_kurtosis = 3) #> [1] 0.4114626"},{"path":"https://andrjohns.github.io/boostmath/reference/sinus_cardinal_hyperbolic_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Sinus Cardinal and Hyperbolic Sinus Cardinal Functions — sinus_cardinal_hyperbolic_functions","title":"Sinus Cardinal and Hyperbolic Sinus Cardinal Functions — sinus_cardinal_hyperbolic_functions","text":"Functions compute sinus cardinal (sinc) hyperbolic sinus cardinal (sinhc) functions. functions appear signal processing, Fourier analysis, various mathematical applications. implementations avoid numerical instability near x = 0. Sinus Cardinal Function: sinc function defined : $$sinc(\\pi x) = \\frac{\\sin(\\pi x)}{\\pi x}$$ sinc_pi(x): Computes sinc(pix) = sin(pix)/(pix) Special value: sinc_pi(0) = 1 (L'Hopital's rule Taylor series) function oscillates decreasing amplitude |x| increases Used extensively signal processing (ideal low-pass filter impulse response) Appears Whittaker-Shannon interpolation formula Hyperbolic Sinus Cardinal Function: hyperbolic sinc function defined : $$sinhc(\\pi x) = \\frac{\\sinh(\\pi x)}{\\pi x}$$ sinhc_pi(x): Computes sinhc(pix) = sinh(pix)/(pix) Special value: sinhc_pi(0) = 1 (L'Hopital's rule Taylor series) function grows exponentially large |x| Analogous sinc using hyperbolic sine instead circular sine Numerical Stability: functions use Taylor series expansions near x = 0 avoid division zero loss precision. x away 0, direct evaluation used.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/sinus_cardinal_hyperbolic_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sinus Cardinal and Hyperbolic Sinus Cardinal Functions — sinus_cardinal_hyperbolic_functions","text":"","code":"sinc_pi(x)  sinhc_pi(x)"},{"path":"https://andrjohns.github.io/boostmath/reference/sinus_cardinal_hyperbolic_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sinus Cardinal and Hyperbolic Sinus Cardinal Functions — sinus_cardinal_hyperbolic_functions","text":"x Input value","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/sinus_cardinal_hyperbolic_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sinus Cardinal and Hyperbolic Sinus Cardinal Functions — sinus_cardinal_hyperbolic_functions","text":"single numeric value computed sinus cardinal hyperbolic sinus cardinal function.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/sinus_cardinal_hyperbolic_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sinus Cardinal and Hyperbolic Sinus Cardinal Functions — sinus_cardinal_hyperbolic_functions","text":"","code":"# Sinus cardinal function at x = 0.5: sinc(pi/2) sinc_pi(0.5) #> [1] 0.9588511 # Sinus cardinal at zero (returns exactly 1) sinc_pi(0) #> [1] 1 # Hyperbolic sinus cardinal function sinhc_pi(0.5) #> [1] 1.042191 # Hyperbolic sinus cardinal at zero (returns exactly 1) sinhc_pi(0) #> [1] 1"},{"path":"https://andrjohns.github.io/boostmath/reference/skew_normal_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Skew Normal Distribution Functions — skew_normal_distribution","title":"Skew Normal Distribution Functions — skew_normal_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Skew Normal distribution. skew normal distribution variant well known Gaussian statistical distribution. standard (mean = 0, scale = 1) normal distribution probability density function \\(\\phi(x)\\) cumulative distribution function \\(\\Phi(x)\\), PDF skew normal distribution shape parameter \\(\\alpha\\) : $$f(x;\\alpha) = 2\\phi(x)\\Phi(\\alpha x)$$ Given location \\(\\xi\\), scale \\(\\omega\\), shape \\(\\alpha\\), can transformed : $$f(x) = \\frac{2}{\\omega}\\phi\\left(\\frac{x-\\xi}{\\omega}\\right)\\Phi\\left(\\alpha\\frac{x-\\xi}{\\omega}\\right)$$ Accuracy Implementation Notes: skew_normal distribution shape = zero equivalent normal distribution uses error function excellent accuracy. CDF requires Owen's T function, evaluated using algoritms Patefield Tandy. median mode calculated iterative root finding may less accurate estimates.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/skew_normal_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Skew Normal Distribution Functions — skew_normal_distribution","text":"","code":"skew_normal_distribution(location = 0, scale = 1, shape = 0)  skew_normal_pdf(x, location = 0, scale = 1, shape = 0)  skew_normal_lpdf(x, location = 0, scale = 1, shape = 0)  skew_normal_cdf(x, location = 0, scale = 1, shape = 0)  skew_normal_lcdf(x, location = 0, scale = 1, shape = 0)  skew_normal_quantile(p, location = 0, scale = 1, shape = 0)"},{"path":"https://andrjohns.github.io/boostmath/reference/skew_normal_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Skew Normal Distribution Functions — skew_normal_distribution","text":"location location parameter (default 0) scale scale parameter (default 1) shape shape parameter (default 0) x quantile p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/skew_normal_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Skew Normal Distribution Functions — skew_normal_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/skew_normal_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Skew Normal Distribution Functions — skew_normal_distribution","text":"","code":"# Skew Normal distribution with location = 0, scale = 1, shape = 0 dist <- skew_normal_distribution(0, 1, 0) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6914625 logcdf(dist, 0.5) #> [1] -0.3689464 pdf(dist, 0.5) #> [1] 0.3520653 logpdf(dist, 0.5) #> [1] -1.043939 hazard(dist, 0.5) #> [1] 1.141078 chf(dist, 0.5) #> [1] 1.175912 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.8416212 standard_deviation(dist) #> [1] 1 support(dist) #> [1] -1.797693e+308  1.797693e+308 variance(dist) #> [1] 1 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 3 kurtosis_excess(dist) #> [1] 0  # Convenience functions skew_normal_pdf(0) #> [1] 0.3989423 skew_normal_lpdf(0) #> [1] -0.9189385 skew_normal_cdf(0) #> [1] 0.5 skew_normal_lcdf(0) #> [1] -0.6931472 skew_normal_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/reference/spherical_harmonics.html","id":null,"dir":"Reference","previous_headings":"","what":"Spherical Harmonics — spherical_harmonics","title":"Spherical Harmonics — spherical_harmonics","text":"Functions compute spherical harmonics related functions.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/spherical_harmonics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spherical Harmonics — spherical_harmonics","text":"","code":"spherical_harmonic(n, m, theta, phi)  spherical_harmonic_r(n, m, theta, phi)  spherical_harmonic_i(n, m, theta, phi)"},{"path":"https://andrjohns.github.io/boostmath/reference/spherical_harmonics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spherical Harmonics — spherical_harmonics","text":"n Degree spherical harmonic m Order spherical harmonic theta Polar angle (colatitude) phi Azimuthal angle (longitude)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/spherical_harmonics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spherical Harmonics — spherical_harmonics","text":"single complex value computed spherical harmonic function, real imaginary parts.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/spherical_harmonics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spherical Harmonics — spherical_harmonics","text":"","code":"# Spherical harmonic function Y_2^1(0.5, 0.5) spherical_harmonic(2, 1, 0.5, 0.5) #> [1] -0.2852481-0.1558318i # Real part of the spherical harmonic function Y_2^1(0.5, 0.5) spherical_harmonic_r(2, 1, 0.5, 0.5) #> [1] -0.2852481 # Imaginary part of the spherical harmonic function Y_2^1(0.5, 0.5) spherical_harmonic_i(2, 1, 0.5, 0.5) #> [1] -0.1558318"},{"path":"https://andrjohns.github.io/boostmath/reference/students_t_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Student's T Distribution Functions — students_t_distribution","title":"Student's T Distribution Functions — students_t_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Student's t distribution. Student's t-distribution defined distribution random variable \\(t\\) (loosely) \"best\" can knowing true standard deviation sample. Given \\(N\\) independent measurements, let $$t = \\frac{\\mu - M}{s / \\sqrt{N}}$$ \\(M\\) population mean, \\(\\mu\\) sample mean, \\(s\\) sample variance. PDF: $$f(x;\\nu) = \\frac{\\Gamma((\\nu+1)/2)}{\\sqrt{\\nu\\pi}\\Gamma(\\nu/2)} \\left(1+\\frac{x^2}{\\nu}\\right)^{-(\\nu+1)/2}$$ \\(\\nu\\) degrees freedom. Accuracy Implementation Notes: Student's t distribution implemented terms incomplete beta function inverses.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/students_t_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Student's T Distribution Functions — students_t_distribution","text":"","code":"students_t_distribution(df = 1)  students_t_pdf(x, df = 1)  students_t_lpdf(x, df = 1)  students_t_cdf(x, df = 1)  students_t_lcdf(x, df = 1)  students_t_quantile(p, df = 1)  students_t_find_degrees_of_freedom(   difference_from_mean,   alpha,   beta,   sd,   hint = 100 )"},{"path":"https://andrjohns.github.io/boostmath/reference/students_t_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Student's T Distribution Functions — students_t_distribution","text":"df degrees freedom (default 1) x quantile p probability (0 <= p <= 1) difference_from_mean difference assumed nominal mean detected. alpha acceptable probability Type error (false positive). beta acceptable probability Type II error (false negative). sd assumed standard deviation. hint initial guess degrees freedom start search (current sample size good start).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/students_t_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Student's T Distribution Functions — students_t_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/students_t_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Student's T Distribution Functions — students_t_distribution","text":"","code":"# Student's t distribution with 5 degrees of freedom dist <- students_t_distribution(5) # Apply generic functions cdf(dist, 0.5) #> [1] 0.6808506 logcdf(dist, 0.5) #> [1] -0.3844124 pdf(dist, 0.5) #> [1] 0.3279185 logpdf(dist, 0.5) #> [1] -1.11499 hazard(dist, 0.5) #> [1] 1.027476 chf(dist, 0.5) #> [1] 1.142096 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -Inf  Inf quantile(dist, 0.2) #> [1] -0.9195438 standard_deviation(dist) #> [1] 1.290994 support(dist) #> [1] -Inf  Inf variance(dist) #> [1] 1.666667 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 9 kurtosis_excess(dist) #> [1] 6  # Convenience functions students_t_pdf(0, 5) #> [1] 0.3796067 students_t_lpdf(0, 5) #> [1] -0.9686196 students_t_cdf(0, 5) #> [1] 0.5 students_t_lcdf(0, 5) #> [1] -0.6931472 students_t_quantile(0.5, 5) #> [1] 0  # Find degrees of freedom needed to detect a difference from mean of 2.0 # with alpha = 0.05 and beta = 0.2 when the standard deviation is 3.0 students_t_find_degrees_of_freedom(2.0, 0.05, 0.2, 3.0) #> [1] 14.49448"},{"path":"https://andrjohns.github.io/boostmath/reference/t_tests.html","id":null,"dir":"Reference","previous_headings":"","what":"Student's T-Tests — t_tests","title":"Student's T-Tests — t_tests","text":"Functions performing various Student's t-tests compare means populations. One-Sample T-Test: Tests population mean differs specified assumed_mean. $$t = \\frac{\\bar{x} - \\mu_0}{s / \\sqrt{n}}$$ Available two forms: one_sample_t_test: Takes vector data. one_sample_t_test_params: Takes summary statistics (mean, variance, sample size) directly. Two-Sample T-Test (two_sample_t_test): Tests means two independent samples differ. Automatically handles unequal variances (Welch's t-test) equal variances based data. Paired Samples T-Test (paired_samples_t_test): Tests means two dependent (paired) samples differ. Equivalent one-sample t-test differences pairs.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/t_tests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Student's T-Tests — t_tests","text":"","code":"one_sample_t_test_params(   sample_mean,   sample_variance,   num_samples,   assumed_mean )  one_sample_t_test(u, assumed_mean)  two_sample_t_test(u, v)  paired_samples_t_test(u, v)"},{"path":"https://andrjohns.github.io/boostmath/reference/t_tests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Student's T-Tests — t_tests","text":"sample_mean Sample mean (one_sample_t_test_params). sample_variance Sample variance (one_sample_t_test_params). num_samples Number samples (one_sample_t_test_params). assumed_mean hypothesised population mean compare . u numeric vector data values first sample. v numeric vector data values second sample.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/t_tests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Student's T-Tests — t_tests","text":"two-element numeric vector containing: t-statistic. p-value (two-sided).","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/t_tests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Student's T-Tests — t_tests","text":"","code":"# --- One Sample T-Test --- # Using raw data: data <- c(5, 6, 7, 5, 6) one_sample_t_test(data, assumed_mean = 4) #> [1] 4.810702354 0.008580919  # Using summary statistics: # Mean = 5.8, Variance = 0.7, N = 5 one_sample_t_test_params(sample_mean = 5.8, sample_variance = 0.7,                          num_samples = 5, assumed_mean = 4) #> [1] 4.810702354 0.008580919  # --- Two Sample T-Test --- sample1 <- c(5, 6, 7, 5, 6) sample2 <- c(4, 5, 6, 4, 5) two_sample_t_test(sample1, sample2) #> [1] 1.88982237 0.09545201  # --- Paired Samples T-Test --- # Pre-test vs Post-test pre <- c(5, 6, 7, 5, 6) post <- c(6, 7, 8, 6, 7) paired_samples_t_test(pre, post) #> [1] -Inf    0"},{"path":"https://andrjohns.github.io/boostmath/reference/triangular_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Triangular Distribution Functions — triangular_distribution","title":"Triangular Distribution Functions — triangular_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Triangular distribution. triangular distribution continuous probability distribution lower limit \\(\\), mode \\(c\\), upper limit \\(b\\). often used distribution vaguely known, upper lower limits known, \"best guess\" (mode) added. probability density function (PDF): $$f(x) = \\frac{2(x-)}{(b-)(c-)} \\quad \\text{} \\le x \\le c$$ $$f(x) = \\frac{2(b-x)}{(b-)(b-c)} \\quad \\text{} c < x \\le b$$ Accuracy Implementation Notes: triangular distribution implemented simple arithmetic operators errors within epsilon two.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/triangular_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Triangular Distribution Functions — triangular_distribution","text":"","code":"triangular_distribution(lower = -1, mode = 0, upper = 1)  triangular_pdf(x, lower = -1, mode = 0, upper = 1)  triangular_lpdf(x, lower = -1, mode = 0, upper = 1)  triangular_cdf(x, lower = -1, mode = 0, upper = 1)  triangular_lcdf(x, lower = -1, mode = 0, upper = 1)  triangular_quantile(p, lower = -1, mode = 0, upper = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/triangular_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Triangular Distribution Functions — triangular_distribution","text":"lower lower limit distribution (default -1) mode mode distribution (default 0) upper upper limit distribution (default 1) x quantile p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/triangular_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Triangular Distribution Functions — triangular_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/triangular_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Triangular Distribution Functions — triangular_distribution","text":"","code":"# Triangular distribution with lower = -1, mode = 0, upper = 1 dist <- triangular_distribution(-1, 0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.875 logcdf(dist, 0.5) #> [1] -0.1335314 pdf(dist, 0.5) #> [1] 0.5 logpdf(dist, 0.5) #> [1] -0.6931472 hazard(dist, 0.5) #> [1] 4 chf(dist, 0.5) #> [1] 2.079442 mean(dist) #> [1] 0 median(dist) #> [1] 0 mode(dist) #> [1] 0 range(dist) #> [1] -1.797693e+308  1.797693e+308 quantile(dist, 0.2) #> [1] -0.3675445 standard_deviation(dist) #> [1] 0.4082483 support(dist) #> [1] -1  1 variance(dist) #> [1] 0.1666667 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 2.4 kurtosis_excess(dist) #> [1] -0.6  # Convenience functions triangular_pdf(1) #> [1] 0 triangular_lpdf(1) #> [1] -Inf triangular_cdf(1) #> [1] 1 triangular_lcdf(1) #> [1] 0 triangular_quantile(0.5) #> [1] 0"},{"path":"https://andrjohns.github.io/boostmath/reference/uniform_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Uniform Distribution Functions — uniform_distribution","title":"Uniform Distribution Functions — uniform_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Uniform distribution. uniform distribution, also known rectangular distribution, probability distribution constant probability. continuous uniform distribution probability density function (PDF): $$f(x) = \\frac{1}{\\text{upper} - \\text{lower}} \\quad \\text{} \\text{lower} \\le x \\le \\text{upper}$$ $$f(x) = 0 \\quad \\text{} x < \\text{lower} \\text{ } x > \\text{upper}$$ Accuracy Implementation Notes: uniform distribution implemented simple arithmetic operators errors within epsilon two.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/uniform_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Uniform Distribution Functions — uniform_distribution","text":"","code":"uniform_distribution(lower = 0, upper = 1)  uniform_pdf(x, lower = 0, upper = 1)  uniform_lpdf(x, lower = 0, upper = 1)  uniform_cdf(x, lower = 0, upper = 1)  uniform_lcdf(x, lower = 0, upper = 1)  uniform_quantile(p, lower = 0, upper = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/uniform_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Uniform Distribution Functions — uniform_distribution","text":"lower lower bound distribution (default 0) upper upper bound distribution (default 1) x quantile p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/uniform_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Uniform Distribution Functions — uniform_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/uniform_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Uniform Distribution Functions — uniform_distribution","text":"","code":"# Uniform distribution with lower = 0, upper = 1 dist <- uniform_distribution(0, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.5 logcdf(dist, 0.5) #> [1] -0.6931472 pdf(dist, 0.5) #> [1] 1 logpdf(dist, 0.5) #> [1] 0 hazard(dist, 0.5) #> [1] 2 chf(dist, 0.5) #> [1] 0.6931472 mean(dist) #> [1] 0.5 median(dist) #> [1] 0.5 mode(dist) #> [1] 0 range(dist) #> [1] -1.797693e+308  1.797693e+308 quantile(dist, 0.2) #> [1] 0.2 standard_deviation(dist) #> [1] 0.2886751 support(dist) #> [1] 0 1 variance(dist) #> [1] 0.08333333 skewness(dist) #> [1] 0 kurtosis(dist) #> [1] 1.8 kurtosis_excess(dist) #> [1] -1.2  # Convenience functions uniform_pdf(0.5) #> [1] 1 uniform_lpdf(0.5) #> [1] 0 uniform_cdf(0.5) #> [1] 0.5 uniform_lcdf(0.5) #> [1] -0.6931472 uniform_quantile(0.5) #> [1] 0.5"},{"path":"https://andrjohns.github.io/boostmath/reference/univariate_statistics.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate Statistics — univariate_statistics","title":"Univariate Statistics — univariate_statistics","text":"Functions compute robust univariate statistics dataset. Central Tendency: mean_boost: Computes arithmetic mean using Higham's numerically stable algorithm. median_boost: Computes median (robust outliers). mode: Computes mode(s) dataset. Dispersion (Spread): variance: Computes population variance using Higham's algorithm. sample_variance: Computes sample variance (unbiased estimator). mean_and_sample_variance: Efficiently computes mean sample variance one pass. median_absolute_deviation: Computes Median Absolute Deviation (MAD), robust measure variability. interquartile_range: Computes Interquartile Range (IQR = Q3 - Q1), robust outliers. Shape: skewness: Measures asymmetry distribution (Pebay's algorithm). kurtosis: Measures \"tailedness\" distribution (Pebay's algorithm). excess_kurtosis: Kurtosis minus 3 (Normal distribution 0 excess kurtosis). first_four_moments: Computes Mean, Variance, Skewness, Kurtosis single pass. Inequality: gini_coefficient: Computes Gini coefficient (population). range \\([0, 1 - 1/n]\\). sample_gini_coefficient: Computes sample Gini coefficient. range \\([0, 1]\\).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/univariate_statistics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate Statistics — univariate_statistics","text":"","code":"mean_boost(x)  # Default S3 method variance(x, ...)  sample_variance(x)  mean_and_sample_variance(x)  # Default S3 method skewness(x, ...)  # Default S3 method kurtosis(x, ...)  excess_kurtosis(x)  first_four_moments(x)  median_boost(x)  median_absolute_deviation(x)  interquartile_range(x)  gini_coefficient(x)  sample_gini_coefficient(x)  # Default S3 method mode(x, ...)"},{"path":"https://andrjohns.github.io/boostmath/reference/univariate_statistics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate Statistics — univariate_statistics","text":"x numeric vector containing dataset. ... Additional arguments (S3 compatibility, e.g., defaults).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/univariate_statistics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate Statistics — univariate_statistics","text":"numeric value (vector moments/mode) computed statistic.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/univariate_statistics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Univariate Statistics — univariate_statistics","text":"functions designed numerically stable efficient. implementations follow algorithms described Higham (Accuracy Stability Numerical Algorithms) Pebay (Sandia Labs) one-pass parallel computation.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/univariate_statistics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Univariate Statistics — univariate_statistics","text":"Higham, N. J. (2002). Accuracy stability numerical algorithms. SIAM. Pebay, P. P. (2008). Formulas Robust, One-Pass Parallel Computation Covariances Arbitrary-Order Statistical Moments. Sandia Report.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/univariate_statistics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate Statistics — univariate_statistics","text":"","code":"data <- c(1, 2, 3, 4, 100) # Dataset with an outlier  # --- Central Tendency --- mean_boost(data) #> [1] 22 median_boost(data) # Less affected by 100 #> [1] 3 mode(c(1, 2, 2, 3)) #> [1] 2  # --- Dispersion --- variance(data) #> [1] 1522 sample_variance(data) #> [1] 1902.5 median_absolute_deviation(data) # Robust #> [1] 1 interquartile_range(data)       # Robust #> [1] 50.5  # --- Shape --- skewness(data) #> [1] 1.497537 excess_kurtosis(data) #> [1] 0.2467165 first_four_moments(data) #> [1]      22    1522   88920 7520967  # --- Inequality --- gini_coefficient(c(1, 0, 0, 0)) # High inequality #> [1] 0.75 # Gini Coefficient gini_coefficient(c(1, 2, 3, 4, 5)) #> [1] 0.2666667 # Sample Gini Coefficient sample_gini_coefficient(c(1, 2, 3, 4, 5)) #> [1] 0.3333333 # Mode mode(c(1, 2, 2, 3, 4)) #> [1] 2"},{"path":"https://andrjohns.github.io/boostmath/reference/vector_functionals.html","id":null,"dir":"Reference","previous_headings":"","what":"Vector Norms and Distances — vector_functionals","title":"Vector Norms and Distances — vector_functionals","text":"Functions compute various vector norms, distances, functional properties. functionals form basis many numerical analysis signal processing algorithms. Norms (Magnitude): l1_norm: Computes L1 norm (Manhattan norm), sum absolute values. l2_norm: Computes L2 norm (Euclidean norm), square root sum squares. sup_norm: Computes Supremum (L-infinity) norm, maximum absolute value. lp_norm: Computes Lp norm arbitrary integer p. Distances (Difference): l1_distance: Computes L1 distance two vectors. l2_distance: Computes L2 (Euclidean) distance two vectors. sup_distance: Computes Supremum (L-infinity) distance/Chebyshev distance. lp_distance: Computes Lp distance arbitrary integer p. Sparsity & Structure: l0_pseudo_norm: Counts number non-zero elements (Hamming weight). hamming_distance: Counts number mismatching elements two vectors. total_variation: Computes total variation (sum absolute differences adjacent elements).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/vector_functionals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vector Norms and Distances — vector_functionals","text":"","code":"l0_pseudo_norm(x)  hamming_distance(x, y)  l1_norm(x)  l1_distance(x, y)  l2_norm(x)  l2_distance(x, y)  sup_norm(x)  sup_distance(x, y)  lp_norm(x, p)  lp_distance(x, y, p)  total_variation(x)"},{"path":"https://andrjohns.github.io/boostmath/reference/vector_functionals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vector Norms and Distances — vector_functionals","text":"x numeric vector. y numeric vector length x (distance functions). p positive integer indicating order norm distance (Lp functions).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/vector_functionals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vector Norms and Distances — vector_functionals","text":"single numeric value computed norm distance.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/vector_functionals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vector Norms and Distances — vector_functionals","text":"L0 Pseudo-Norm: true norm (satisfy homogeneity), useful sparsity (e.g., Compressed Sensing). L1 Norm: Often used sparse signal recovery (LASSO). Total Variation: Useful signal processing denoising preserving edges (Total Variation Denoising). implementations designed efficient work various numeric types.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/vector_functionals.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Vector Norms and Distances — vector_functionals","text":"Higham, N. J. (2002). Accuracy stability numerical algorithms. SIAM. Mallat, S. (2008). wavelet tour signal processing: sparse way. Academic press.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/vector_functionals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vector Norms and Distances — vector_functionals","text":"","code":"v1 <- c(1, -2, 3) v2 <- c(4, -5, 6)  # --- Norms --- l1_norm(v1)      # |1| + |-2| + |3| = 6 #> [1] 6 l2_norm(v1)      # sqrt(1^2 + (-2)^2 + 3^2) = sqrt(14) #> [1] 3.741657 sup_norm(v1)     # max(|1|, |-2|, |3|) = 3 #> [1] 3 lp_norm(v1, 3)   # Cube root of sum of cubes #> [1] 3.301927  # --- Distances --- l1_distance(v1, v2) #> [1] 9 l2_distance(v1, v2) #> [1] 5.196152 hamming_distance(c(1, 0, 1), c(0, 1, 1)) # 2 differences (pos 1 and 2) #> [1] 2  # --- Structure --- l0_pseudo_norm(c(0, 5, 0, 2)) # Returns 2 (two non-zeros) #> [1] 2 total_variation(c(1, 5, 2))   # |5-1| + |2-5| = 4 + 3 = 7 #> [1] 7"},{"path":"https://andrjohns.github.io/boostmath/reference/weibull_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Weibull Distribution Functions — weibull_distribution","title":"Weibull Distribution Functions — weibull_distribution","text":"Functions compute probability density function, cumulative distribution function, quantile function Weibull distribution. Weibull distribution continuous distribution often used field failure analysis; particular can mimic distributions failure rate varies time. probability density function (PDF): $$f(x; \\alpha, \\beta) = \\frac{\\alpha}{\\beta} \\left(\\frac{x}{\\beta}\\right)^{\\alpha-1} e^{-(x/\\beta)^\\alpha}$$ shape parameter \\(\\alpha > 0\\), scale parameter \\(\\beta > 0\\), \\(x > 0\\). Accuracy Implementation Notes: Weibull distribution implemented terms standard library log exp functions plus expm1 log1p low error rates.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/weibull_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weibull Distribution Functions — weibull_distribution","text":"","code":"weibull_distribution(shape, scale = 1)  weibull_pdf(x, shape, scale = 1)  weibull_lpdf(x, shape, scale = 1)  weibull_cdf(x, shape, scale = 1)  weibull_lcdf(x, shape, scale = 1)  weibull_quantile(p, shape, scale = 1)"},{"path":"https://andrjohns.github.io/boostmath/reference/weibull_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weibull Distribution Functions — weibull_distribution","text":"shape shape parameter scale scale parameter (default 1) x quantile p probability (0 <= p <= 1)","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/weibull_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Weibull Distribution Functions — weibull_distribution","text":"single numeric value computed probability density, log-probability density, cumulative distribution, log-cumulative distribution, quantile depending function called.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/weibull_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Weibull Distribution Functions — weibull_distribution","text":"","code":"# Weibull distribution with shape = 1, scale = 1 dist <- weibull_distribution(1, 1) # Apply generic functions cdf(dist, 0.5) #> [1] 0.3934693 logcdf(dist, 0.5) #> [1] -0.9327521 pdf(dist, 0.5) #> [1] 0.6065307 logpdf(dist, 0.5) #> [1] -0.5 hazard(dist, 0.5) #> [1] 1 chf(dist, 0.5) #> [1] 0.5 mean(dist) #> [1] 1 median(dist) #> [1] 0.6931472 mode(dist) #> [1] 0 range(dist) #> [1]  0.000000e+00 1.797693e+308 quantile(dist, 0.2) #> [1] 0.2231436 standard_deviation(dist) #> [1] 1 support(dist) #> [1] 2.225074e-308 1.797693e+308 variance(dist) #> [1] 1 skewness(dist) #> [1] 2 kurtosis(dist) #> [1] 9 kurtosis_excess(dist) #> [1] 6  # Convenience functions weibull_pdf(1, shape = 1, scale = 1) #> [1] 0.3678794 weibull_lpdf(1, shape = 1, scale = 1) #> [1] -1 weibull_cdf(1, shape = 1, scale = 1) #> [1] 0.6321206 weibull_lcdf(1, shape = 1, scale = 1) #> [1] -0.4586751 weibull_quantile(0.5, shape = 1, scale = 1) #> [1] 0.6931472"},{"path":"https://andrjohns.github.io/boostmath/reference/z_tests.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-Tests — z_tests","title":"Z-Tests — z_tests","text":"Statistical hypothesis tests population means using Normal (Z) distribution. Z-tests typically used : population variance known. sample size large (N > 30), allowing sample variance approximate population variance (via Central Limit Theorem). One-Sample Tests: one_sample_z_test: Performs Z-test data vector u assumed_mean. one_sample_z_test_params: Performs Z-test given summary statistics (mean, variance, N). Two-Sample Tests: two_sample_z_test: Performs Z-test comparing means two data vectors u v.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/z_tests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-Tests — z_tests","text":"","code":"one_sample_z_test_params(   sample_mean,   sample_variance,   num_samples,   assumed_mean )  one_sample_z_test(u, assumed_mean)  two_sample_z_test(u, v)"},{"path":"https://andrjohns.github.io/boostmath/reference/z_tests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Z-Tests — z_tests","text":"sample_mean Numeric. mean sample. sample_variance Numeric. variance sample. num_samples Integer. size sample. assumed_mean Numeric. null hypothesis mean value test . u numeric vector containing first sample. v numeric vector containing second sample (two-sample test).","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/z_tests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Z-Tests — z_tests","text":"numeric vector containing: Statistic: computed Z-statistic. P-Value: two-sided p-value associated Z-statistic.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/z_tests.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Z-Tests — z_tests","text":"Statistic: Z-statistic calculated $$Z = \\frac{\\bar{x} - \\mu}{\\sigma / \\sqrt{n}}$$. Assumptions: underlying distribution Normal, sample size large enough CLT apply.","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/z_tests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Z-Tests — z_tests","text":"","code":"# --- One-Sample Z-Test --- data1 <- c(5, 6, 7, 5, 6, 8) # Test if population mean is 4 one_sample_z_test(data1, assumed_mean = 4) #> [1] 4.539796923 0.006169843  # Using Summary Statistics # Mean = 2, Variance = 1, N = 30, Null Mean = 0 one_sample_z_test_params(sample_mean = 2,                          sample_variance = 1,                          num_samples = 30,                          assumed_mean = 0) #> [1] 1.095445e+01 8.021287e-12  # --- Two-Sample Z-Test --- data2 <- c(4, 5, 6, 4, 5, 7) # Test if data1 and data2 have different means two_sample_z_test(data1, data2) #> [1] 1.4815944 0.1692572"},{"path":"https://andrjohns.github.io/boostmath/reference/zeta.html","id":null,"dir":"Reference","previous_headings":"","what":"Riemann Zeta Function — zeta","title":"Riemann Zeta Function — zeta","text":"Computes Riemann zeta function zeta(z), one important functions analytic number theory. Mathematical Definition: Riemann zeta function defined series: $$\\zeta(z) = \\sum_{n=1}^\\infty \\frac{1}{n^z}$$ Re(z) > 1, analytic continuation elsewhere. Special Values: zeta(2) = pi^2/6 (Basel problem) zeta(4) = pi^4/90 zeta(0) = -1/2 zeta(-1) = -1/12 Closed forms exist even positive integers negative integers odd positive integers > 1, values computed numerically Implementation: function uses different computational strategies depending argument: 0 < z < 1: Rational approximation form 1 < z < 4: Rational approximation around nearby integers z > 4: Simple rational approximation series Reflection formula negative arguments Pre-computed cached values positive odd integers Specialised rational approximations standard floating-point precisions Applications: Riemann zeta function appears number theory (distribution primes), physics (quantum field theory, statistical mechanics), probability theory. famous Riemann Hypothesis concerns non-trivial zeros function.","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/zeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Riemann Zeta Function — zeta","text":"","code":"zeta(z)"},{"path":"https://andrjohns.github.io/boostmath/reference/zeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Riemann Zeta Function — zeta","text":"z Real number input","code":""},{"path":"https://andrjohns.github.io/boostmath/reference/zeta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Riemann Zeta Function — zeta","text":"value Riemann zeta function zeta(z).","code":""},{"path":[]},{"path":"https://andrjohns.github.io/boostmath/reference/zeta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Riemann Zeta Function — zeta","text":"","code":"# Riemann Zeta Function zeta(2)  # Should return pi^2 / 6 ~= 1.6449340668 #> [1] 1.644934 zeta(3)  # Apery's constant ~= 1.2020569032 #> [1] 1.202057 zeta(4)  # pi^4 / 90 ~= 1.0823232337 #> [1] 1.082323"},{"path":"https://andrjohns.github.io/boostmath/news/index.html","id":"boostmath-140","dir":"Changelog","previous_headings":"","what":"boostmath 1.4.0","title":"boostmath 1.4.0","text":"CRAN release: 2025-12-15 Added logit logistic_sigmoid functions Added log_pi constant Ooura fourier integrals now supported platforms without long double support","code":""},{"path":"https://andrjohns.github.io/boostmath/news/index.html","id":"boostmath-130","dir":"Changelog","previous_headings":"","what":"boostmath 1.3.0","title":"boostmath 1.3.0","text":"CRAN release: 2025-11-03 Added support Boost distribution functions (e.g., pdf, kurtosis, variance, etc.) Exposed additional distribution utility functions (e.g., binomial_find_lower_bound_on_p, chi_squared_find_degrees_of_freedom)","code":""},{"path":"https://andrjohns.github.io/boostmath/news/index.html","id":"boostmath-120","dir":"Changelog","previous_headings":"","what":"boostmath 1.2.0","title":"boostmath 1.2.0","text":"CRAN release: 2025-09-15 Added filters Interpolators now use $interpolate() instead $spline()","code":""},{"path":"https://andrjohns.github.io/boostmath/news/index.html","id":"boostmath-110","dir":"Changelog","previous_headings":"","what":"boostmath 1.1.0","title":"boostmath 1.1.0","text":"CRAN release: 2025-09-04 Added statistics, interpolators, constants","code":""},{"path":"https://andrjohns.github.io/boostmath/news/index.html","id":"boostmath-102","dir":"Changelog","previous_headings":"","what":"boostmath 1.0.2","title":"boostmath 1.0.2","text":"CRAN release: 2025-07-31 Remove UseLTO DESCRIPTION avoid R CMD check warning Use non-versioned Boost URL DESCRIPTION (thanks Dirk Eddelbuettel)","code":""},{"path":"https://andrjohns.github.io/boostmath/news/index.html","id":"boostmath-101","dir":"Changelog","previous_headings":"","what":"boostmath 1.0.1","title":"boostmath 1.0.1","text":"Fix ODR violation warning","code":""},{"path":"https://andrjohns.github.io/boostmath/news/index.html","id":"boostmath-100","dir":"Changelog","previous_headings":"","what":"boostmath 1.0.0","title":"boostmath 1.0.0","text":"CRAN release: 2025-07-25 Initial release","code":""}]
