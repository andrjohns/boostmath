% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vector_functionals.R
\name{vector_functionals}
\alias{vector_functionals}
\alias{l0_pseudo_norm}
\alias{hamming_distance}
\alias{l1_norm}
\alias{l1_distance}
\alias{l2_norm}
\alias{l2_distance}
\alias{sup_norm}
\alias{sup_distance}
\alias{lp_norm}
\alias{lp_distance}
\alias{total_variation}
\title{Vector Norms and Distances}
\usage{
l0_pseudo_norm(x)

hamming_distance(x, y)

l1_norm(x)

l1_distance(x, y)

l2_norm(x)

l2_distance(x, y)

sup_norm(x)

sup_distance(x, y)

lp_norm(x, p)

lp_distance(x, y, p)

total_variation(x)
}
\arguments{
\item{x}{A numeric vector.}

\item{y}{A numeric vector of the same length as \code{x} (for distance functions).}

\item{p}{A positive integer indicating the order of the norm or distance (for Lp functions).}
}
\value{
A single numeric value with the computed norm or distance.
}
\description{
Functions to compute various vector norms, distances, and functional properties.
These functionals form the basis of many numerical analysis and signal processing algorithms.

\strong{Norms (Magnitude):}
\itemize{
\item \code{l1_norm}: Computes the L1 norm (Manhattan norm), sum of absolute values.
\item \code{l2_norm}: Computes the L2 norm (Euclidean norm), square root of sum of squares.
\item \code{sup_norm}: Computes the Supremum (L-infinity) norm, the maximum absolute value.
\item \code{lp_norm}: Computes the Lp norm for an arbitrary integer \code{p}.
}

\strong{Distances (Difference):}
\itemize{
\item \code{l1_distance}: Computes the L1 distance between two vectors.
\item \code{l2_distance}: Computes the L2 (Euclidean) distance between two vectors.
\item \code{sup_distance}: Computes the Supremum (L-infinity) distance/Chebyshev distance.
\item \code{lp_distance}: Computes the Lp distance for an arbitrary integer \code{p}.
}

\strong{Sparsity & Structure:}
\itemize{
\item \code{l0_pseudo_norm}: Counts the number of non-zero elements (Hamming weight).
\item \code{hamming_distance}: Counts the number of mismatching elements between two vectors.
\item \code{total_variation}: Computes the total variation (sum of absolute differences between adjacent elements).
}
}
\details{
\itemize{
\item \strong{L0 Pseudo-Norm:} Not a true norm (doesn't satisfy homogeneity), but useful for sparsity (e.g., Compressed Sensing).
\item \strong{L1 Norm:} Often used in sparse signal recovery (LASSO).
\item \strong{Total Variation:} Useful in signal processing for denoising while preserving edges (Total Variation Denoising).
}

The implementations are designed to be efficient and work with various numeric types.
}
\examples{
v1 <- c(1, -2, 3)
v2 <- c(4, -5, 6)

# --- Norms ---
l1_norm(v1)      # |1| + |-2| + |3| = 6
l2_norm(v1)      # sqrt(1^2 + (-2)^2 + 3^2) = sqrt(14)
sup_norm(v1)     # max(|1|, |-2|, |3|) = 3
lp_norm(v1, 3)   # Cube root of sum of cubes

# --- Distances ---
l1_distance(v1, v2)
l2_distance(v1, v2)
hamming_distance(c(1, 0, 1), c(0, 1, 1)) # 2 differences (pos 1 and 2)

# --- Structure ---
l0_pseudo_norm(c(0, 5, 0, 2)) # Returns 2 (two non-zeros)
total_variation(c(1, 5, 2))   # |5-1| + |2-5| = 4 + 3 = 7
}
\references{
Higham, N. J. (2002). Accuracy and stability of numerical algorithms. SIAM.
Mallat, S. (2008). A wavelet tour of signal processing: the sparse way. Academic press.
}
\seealso{
\href{https://www.boost.org/doc/libs/latest/libs/math/doc/html/vector_functionals.html}{Boost Documentation}
}
